<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hugo Architecture # We can learn how to use Hugo to create our own sites and theme. Here are examples: Personal Site and Custom Theme. It is easy to learn and use.
At the same time, Hugo is an open source project based on the Apache 2.0 protocol, which means that you can boldly use your creativity.
For example, for sites in the source code field, such as Understanding Hugo in Depth, the source code and notes are separated and can be executed on GolangPlay."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Hugo Architecture # We can learn how to use Hugo to create our own sites and theme. Here are examples: Personal Site and Custom Theme. It is easy to learn and use.
At the same time, Hugo is an open source project based on the Apache 2.0 protocol, which means that you can boldly use your creativity.
For example, for sites in the source code field, such as Understanding Hugo in Depth, the source code and notes are separated and can be executed on GolangPlay."><meta property="og:type" content="article"><meta property="og:url" content="https://hugo.notes.sunwei.xyz/en/docs/how/arch/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-02-08T19:33:08+08:00"><title>Index | Deep Understanding of Hugo</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.991e596001ff320d45347e928c846f4c22aae6f2117f905369bc3426b8f44eea.js integrity="sha256-mR5ZYAH/Mg1FNH6SjIRvTCKq5vIRf5BTabw0Jrj0Tuo=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/en/><span>Deep Understanding of Hugo</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></label><ul><li><a href=https://hugo.notes.sunwei.xyz/>Chinese</a></li></ul></li></ul><ul><li><p><strong>Hugo usage examples</strong></p></li><li><p><a href=/en/docs/what/site/>Create Site</a></p></li><li><p><a href=/en/docs/what/theme/>Custom Theme</a><br></p></li><li><p><strong>Hugo Architecture</strong></p></li><li><p><a href=/en/docs/how/playground/>Playground</a></p></li><li><p><a href=/en/docs/how/event-storming/>Event Storming</a></p></li><li><p><a href=/en/docs/how/arch/ class=active>Architecture</a><br></p></li><li><p><a href=/en/docs/code/><strong>Source Code</strong></a></p></li><li><p><a href=/en/docs/code/config/>Configuration</a></p></li><li><p><a href=/en/docs/code/deps/>Deps Management</a></p><ul><li><a href=/en/docs/code/deps/pathspec/>PathSpec</a></li><li><a href=/en/docs/code/deps/contentspec/>ContentSpec</a></li></ul></li><li><p><a href=/en/docs/code/site/>Site Creating</a></p><ul><li><a href=/en/docs/code/site/create/>Create Site</a></li><li><a href=/en/docs/code/site/resources/>Load Resources</a></li><li><a href=/en/docs/code/site/markdown/>Markdown</a></li></ul></li><li><p><a href=/en/docs/code/build/>Site Building</a></p><ul><li><a href=/en/docs/code/build/template/>Template Exec</a><br></li></ul></li></ul><ul><li><a href=/en/posts/>Blog</a></li><li><a href=https://github.com/sunwei/hugo-book target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Index</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#hugo-architecture>Hugo Architecture</a><ul><li><a href=#architecture-design-of-hugo>Architecture Design of Hugo</a></li><li><a href=#hugos-component-design>Hugo&rsquo;s component design</a><ul><li><a href=#the-relationship-between-configuration-and-language>The relationship between configuration and language</a></li><li><a href=#hugo-modules>Hugo modules</a></li><li><a href=#文件系统的组织>文件系统的组织</a></li><li><a href=#站点内容的收集方案>站点内容的收集方案</a></li><li><a href=#模板的生命周期>模板的生命周期</a></li><li><a href=#发布的流程>发布的流程</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=hugo-architecture>Hugo Architecture
<a class=anchor href=#hugo-architecture>#</a></h1><p>We can learn how to use Hugo to create our own sites and theme.
Here are examples:
<a href=https://hugo.notes.sunwei.xyz/s/what/site/>Personal Site</a> and
<a href=https://hugo.notes.sunwei.xyz/en/docs/what/theme/>Custom Theme</a>.
It is easy to learn and use.</p><p>At the same time, Hugo is an open source project based on the Apache 2.0 protocol, which means that you can boldly use your creativity.</p><p>For example, for sites in the source code field, such as
<a href=https://c.sunwei.xyz/>Understanding Hugo in Depth</a>, the source code and notes are separated and can be executed on
<a href=https://go.dev/play/>GolangPlay</a>.
Make the learning experience of source code more three-dimensional, not only have interpretation, but also participate in it, modify the example to further help understanding.</p><p>At present, Hugo cannot support the construction of such a site for two main reasons.
The first reason is
<a href=https://gohugo.io/content-network/formats/>Content Format</a>.
The content format currently supported by Hugo is Markdown, and the above content format is .go source code file.
The second reason is
<a href=https://gohugo.io/functions/>Functions</a>.
Hugo does not have a function that handles code and can be used directly.
To parse the source code and notes.
Although the string function can be combined for processing, it is cumbersome to use, difficult to expand, and even more impressive to maintain.</p><p>But we have the source codes.
Can we ask for more?
After all, we are software engineers in pursuit!</p><p>Whether it is from a practical perspective or from the perspective of learning excellent sources to communicate and learn, we have every reason to explore this treasure.</p><p>The goal of this chapter is to open the Treasure Map to understand the infrastructure of the Hugo, which is mainly carried out in the following two directions:</p><ul><li><p>Provides an overview of the architectural thinking and a comprehensive understanding of the infrastructure</p></li><li><p>Start with module code and discuss the relationship between configuration and language, Hugo modules, organization of file systems, collection of site content, lifecycle of templates, and publishing processes.</p></li><li><p>By reading this chapter, we will have a comprehensive understanding of the Hugo site construction tool and a clear understanding of the relationship between the stages, laying a foundation for the next detailed source implementation chapters.</p></li></ul><p>Let&rsquo;s go, great engineer!</p><h2 id=architecture-design-of-hugo>Architecture Design of Hugo
<a class=anchor href=#architecture-design-of-hugo>#</a></h2><p>Combining the Hugo site construction domain
<a href=https://hugo.notes.sunwei.xyz//en/docs/how/event-storming/>event</a>,
and
<a href=https://github.com/sun.com/hugo-playground>Hugo playground</a> source code, the architecture design of Hugo will become very clear:</p><p><img src=images/3.0-hugo-arch.svg alt="Hugo Arch"></p><p>Hugo&rsquo;s architecture idea is easy to understand.
It is mainly divided into three major blocks: configuration module, site module and dependency module.</p><p><strong>Configuration Module</strong></p><p>The first thing Hugo parses is the configuration file <code>config.toml</code> of the user project.
Initiated by <code>configLoader</code>, the configuration file is read from the hard disk and stored as a key-value pair object after parsing.</p><p><code>configLoader</code> mainly needs to complete three things:</p><ol><li>Load the user project configuration file to understand the user&rsquo;s custom requirements.</li><li>Complete the default configuration <code>Defaults Config</code>, to ensure the normal operation of other modules.</li><li>Generate module configuration information, starting from the user project, using the user project as the first module - <code>project module</code>, and in our example there is a second module, that is the theme module <code>mytheme</code>.</li></ol><p>There are dependencies between modules and there is only one Owner <code>Owner</code>.
The project module <code>project module</code> is special, because it is the initial module, so it does not belong to any other modules.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Module</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Owner In the dependency tree, this is the first 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// module that defines this module as a dependency.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Owner</span>() <span style=color:#a6e22e>Module</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After all the information is collected, the <code>config.Provider</code> service will be provided externally: it can be queried and configuration items can be updated.</p><p><strong>HugoSites Module</strong></p><p>This is the core module of building a site, which is equivalent to the aggregate root in DDD.
It organizes all the information needed to build a site internally and provides site building services externally.</p><p>The initialization of <code>HugoSites</code> depends on <code>DepsCfg</code> and <code>Site</code>, yes, there are two sites.
The relationship between HugoSites and Site is one-to-many, and the relationship between Site and Language is one-to-one,
so a multilingual site will create a site for each language, which together form HugoSites.</p><p>Language items are created by DepsCfg, but will be stored in <code>config.Provider</code>, so they are marked in light yellow.
The initialization of DepsCfg depends on <code>Fs</code> and <code>config.Provider</code>.
<code>Fs</code> records the source file address and release address.
The source files come from the user project, which is the actual hard disk file system.
The publishing address is obtained from config.Provider, and the default is the public folder.
It will check whether it already exists here, and create it actively if not.
Finally, synchronize the newly created information such as <code>workingDir</code> back to config.Provider.</p><p>As can be seen, their dependencies are <code>HugoSites &lt;- Site &lt;- Language &lt;- DepsCfg &lt;- Fs</code>.</p><p><strong>Deps Module</strong></p><p>Hugo refers to all the services and objects needed to build a site as dependencies, and puts them all in <code>Deps</code>.</p><p>In the process of building dependencies, <code>TemplateProvider</code> that provides templates will be generated;
Clear input and output media type <code>MediaType</code>; and output format <code>OutputFormats</code>;
will be updated to <code>config.Provider</code>.</p><p>It will also be prepared for collecting site content, and there will be a <code>Page Collection</code> to help collect.
The publishing service that needs to be used when finally publishing the site is <code>Publisher</code>.
These will be updated to <code>Site</code>.</p><p>At the same time, it is also necessary to manage resources in a unified manner with clear specifications,
which can ensure the convenience of use and conform to the principle of single responsibility in the principle of oriented design.
Contains <code>Path Spec</code> that provides a unified standard file structure service;
and a <code>Resources Spec</code> with all media type and output format information;
and a <code>Content Spec</code> that provides services for <code>Content</code> information;
Plus <code>Source Spec</code> to help define resource policies, such as filtering functions.</p><p>With the help of Deps, all the information needed to build the site, such as raw materials, rules,
and output formats, etc., are prepared.</p><p>All is ready except for the opportunity!</p><h2 id=hugos-component-design>Hugo&rsquo;s component design
<a class=anchor href=#hugos-component-design>#</a></h2><p>The architecture diagram can help us understand Hugo&rsquo;s architecture design from a global perspective.
Now let&rsquo;s go a step closer and look at the details of Hugo&rsquo;s architecture from a module perspective</p><h3 id=the-relationship-between-configuration-and-language>The relationship between configuration and language
<a class=anchor href=#the-relationship-between-configuration-and-language>#</a></h3><p>Hugo provides powerful configuration features, such as configuration files, configuration directories,
configuration themes, and more.
In the process of building a site, as long as it is a customized requirement that you can think of,
it can basically be realized through configuration.</p><p>In order to meet different customization needs,
Hugo&rsquo;s idea is to deal with the relationship between many configuration files first,
so some configuration items need to be merged, which requires case insensitivity.
Customization is only a small part, and other general information is explained with the default configuration.</p><p>Supporting multiple languages is a common requirement,
and the strategy followed by much software is to give priority to internationalization.
So how does Hugo understand the relationship between language and configuration?</p><p>In the
<a href=https://hugo.notes.sunwei.xyz/en/docs/what/site/>personal site</a> example,
we configure language-related configurations in <code>config.toml</code> as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#a6e22e>defaultContentLanguage</span> = <span style=color:#e6db74>&#39;zh&#39;</span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>languages</span>]
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>languages</span>.<span style=color:#a6e22e>zh</span>]
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>languageName</span> = <span style=color:#e6db74>&#39;中文&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>contentDir</span> = <span style=color:#e6db74>&#39;content&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>weight</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>languages</span>.<span style=color:#a6e22e>en</span>]
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>languageName</span> = <span style=color:#e6db74>&#39;English&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>contentDir</span> = <span style=color:#e6db74>&#39;content.en&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>weight</span> = <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>The default language can be configured, and the supported languages are Chinese and English.</p><p>From this point of view, the configuration should include the language.
In other words, the language should be a field in the configuration structure.
And is this the case?
Let&rsquo;s start from the source code of
<a href=https://github.com/sunwei/hugo-playground>Hugo Playground</a> to find out.</p><p>Before that, let&rsquo;s look for clues from the architecture diagram:
<img src=images/3.1-hugo-arch-config-language.svg alt="Language and Config"></p><p>It can be seen that the place where Language is finally created is in DepsCfg, not Config.
This is counter to our intuition, let&rsquo;s take a look at the key config.Provider, DepsCfg and Language related code snippets.</p><p><strong>config.Provider</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Provider provides the configuration settings for Hugo.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Provider</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>any</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>value</span> <span style=color:#a6e22e>any</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It can be seen that the Provider interface provides <code>Get</code> and <code>Set</code> methods, just like a key/value warehouse.
The language-related configuration is also stored in the Provider.</p><p><strong>DepsCfg</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// DepsCfg contains configuration options that can be used to configure Hugo
</span></span></span><span style=display:flex><span><span style=color:#75715e>// on a global level, i.e. logging etc.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Nil values will be given default values.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>DepsCfg</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The language to use.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Language</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>langs</span>.<span style=color:#a6e22e>Language</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The configuration to use.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Cfg</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Provider</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>DepsCfg contains config.Provider and Language.</p><p>When creating a site, the direct input is DepsCfg:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// newSite creates a new site with the given configuration.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newSite</span>(<span style=color:#a6e22e>cfg</span> <span style=color:#a6e22e>deps</span>.<span style=color:#a6e22e>DepsCfg</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Site</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Before calling to create a site, DepsCfg has already prepared Language:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createSitesFromConfig</span>(<span style=color:#a6e22e>cfg</span> <span style=color:#a6e22e>deps</span>.<span style=color:#a6e22e>DepsCfg</span>) ([]<span style=color:#f92672>*</span><span style=color:#a6e22e>Site</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>languages</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getLanguages</span>(<span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>Cfg</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>lang</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>languages</span> {
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span> 
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>Language</span> = <span style=color:#a6e22e>lang</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>newSite</span>(<span style=color:#a6e22e>cfg</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sites</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From the Language structure, it can be seen that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Language manages specific-language configuration.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Language</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Lang</span>   <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Weight</span> <span style=color:#66d9ef>int</span> <span style=color:#75715e>// for sort
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Global config.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For internal use.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Cfg</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Provider</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Language contains Cfg config.Provider.
That is to say, the relationship between Language and Config is actually an inclusive relationship, not as we felt above.
Think about it carefully, it makes sense.
Config focuses on providing configuration key/value warehouse management services,
while Language and Site are in one-to-one correspondence, and additional configuration information is required.</p><h3 id=hugo-modules>Hugo modules
<a class=anchor href=#hugo-modules>#</a></h3><p>When it comes to modularization, you may think of Nginx modules, IDEA plug-ins and so on.
Usually, I can meet my differentiated needs by uploading some modules.
The reason why everyone likes this kind of module is mainly because it is flexible enough to meet their own needs without too much effort.
Because many times, although they are roughly the same, there are always some differences in details.
This also shows the complexity of software, in addition to technical complexity, there is also business complexity.
In most cases, what we are facing is mainly business complexity.
This is also the best explanation of the saying &ldquo;interlacing lines are like mountains&rdquo; in the field of software.
Nowadays, not only the Internet industry, the financial industry,
but also the traditional manufacturing industry have used information systems to help enterprises in production and management.
The same leave application system, even in the same industry and different companies, will be different.</p><p>However, Hugo&rsquo;s modules are a bit different from the modules in everyone&rsquo;s impression.
They do not use functions as units to meet differentiated needs.
Instead, the directory structure is used to identify the same structure.</p><p>Let&rsquo;s take a look at the location of the module in our architecture:</p><p><img src=images/3.2-hugo-arch-module.svg alt="Hugo Arch Module"></p><p>In the architecture diagram, <code>Modules</code> needs to be organized in a unified manner,
relying on the description information of <code>Modules Config</code>,
and the loading of this information is the responsibility of configLoader.</p><p>Let&rsquo;s take a look at the actual call timing from the source code of
<a href=https://github.com/sunwei/hugo-playground>Hugo Playground</a>:</p><p><img src=images/3.2.1-hugo-arch-module.svg alt="Hugo Arch Module flow"></p><p>It can be seen that in our playground, the main function calls the <code>LoadConfig</code> method,
and does two things for <code>Modules</code> in this method.
One is <code>loadModulesConfig</code>, which organizes configuration information related to Modules into Module Config.
The other is <code>collectModules</code>, which standardizes the module information according to the module standard according to the collected configuration information.</p><p>Let&rsquo;s take a look at the source code definition of <code>Module Config</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Config holds a module config.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Config</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Mounts</span>  []<span style=color:#a6e22e>Mount</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Imports</span> []<span style=color:#a6e22e>Import</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Meta info about this module (license information etc.).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Params</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>any</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It can be seen that there are two important fields, one is Mounts and the other is Imports.
<code>loadModulesConfig</code> mainly deals with the Imports field, in our example:</p><pre tabindex=0><code>-- config.toml --
theme = &#34;mytheme&#34;
...
</code></pre><p>The configuration information of the theme is <code>theme = "mytheme"</code>,
and when parsed into module configuration information, it becomes <code>c.Imports = [mytheme]</code>.</p><p>The next step is to collect the module <code>collectModules</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#a6e22e>configLoader</span>) <span style=color:#a6e22e>collectModules</span>(<span style=color:#a6e22e>modConfig</span> <span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Config</span>, <span style=color:#f92672>...</span>) (<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Modules</span>, <span style=color:#f92672>...</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pass in the module configuration information just collected, and output standard module information.
However, the configuration information we just collected has only Imports and only one value &ldquo;mytheme&rdquo;.
The output example is shown in the following figure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%#v\n&#34;</span>, <span style=color:#a6e22e>modulesConfig</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Mounts</span>:[]<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>(<span style=color:#66d9ef>nil</span>), 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Imports</span>:[]<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Import</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Import</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Path</span>:<span style=color:#e6db74>&#34;mytheme&#34;</span>, 
</span></span><span style=display:flex><span>			<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	}}, 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Params</span>:<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span> {}(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>**Why does Hugo call Theme a module? **</p><p>Enter the following command to create a site:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>➜  tmp hugo new site xyz
</span></span></code></pre></div><p>查看目录结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>➜  xyz tree
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── archetypes
</span></span><span style=display:flex><span>│   └── default.md
</span></span><span style=display:flex><span>├── config.toml
</span></span><span style=display:flex><span>├── content
</span></span><span style=display:flex><span>├── data
</span></span><span style=display:flex><span>├── layouts
</span></span><span style=display:flex><span>├── public
</span></span><span style=display:flex><span>├── static
</span></span><span style=display:flex><span>└── themes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> directories, <span style=color:#ae81ff>2</span> files
</span></span></code></pre></div><p>Then enter the following command to create a theme:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>➜  tmp hugo new theme mytheme
</span></span></code></pre></div><p>Also look at the directory structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>➜  mytheme tree
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── LICENSE
</span></span><span style=display:flex><span>├── archetypes
</span></span><span style=display:flex><span>│   └── default.md
</span></span><span style=display:flex><span>├── layouts
</span></span><span style=display:flex><span>│   ├── 404.html
</span></span><span style=display:flex><span>│   ├── _default
</span></span><span style=display:flex><span>│   │   ├── baseof.html
</span></span><span style=display:flex><span>│   │   ├── list.html
</span></span><span style=display:flex><span>│   │   └── single.html
</span></span><span style=display:flex><span>│   ├── index.html
</span></span><span style=display:flex><span>│   └── partials
</span></span><span style=display:flex><span>│       ├── footer.html
</span></span><span style=display:flex><span>│       ├── head.html
</span></span><span style=display:flex><span>│       └── header.html
</span></span><span style=display:flex><span>├── static
</span></span><span style=display:flex><span>│   ├── css
</span></span><span style=display:flex><span>│   └── js
</span></span><span style=display:flex><span>└── theme.toml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> directories, <span style=color:#ae81ff>11</span> files
</span></span></code></pre></div><p>Let&rsquo;s compare the directory structures of Site and Theme together:</p><p><img src=images/3.2.2-hugo-arch-site-theme-folder-struct.png alt="Hugo Arch Modules site and theme folder structure"></p><p>By comparison, it is not difficult to find that the directory structure is basically the same,
including <code>archetypes</code>, <code>layouts</code>, <code>static</code> and so on.</p><p>On the Hugo official website, there is a clear description of
<a href=https://gohugo.io/getting-started/directory-structure/>directory structure</a>.
You can also see from the source code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugofs/files/classifier.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ComponentFolderArchetypes</span> = <span style=color:#e6db74>&#34;archetypes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ComponentFolderStatic</span>     = <span style=color:#e6db74>&#34;static&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ComponentFolderLayouts</span>    = <span style=color:#e6db74>&#34;layouts&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ComponentFolderContent</span>    = <span style=color:#e6db74>&#34;content&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ComponentFolderData</span>       = <span style=color:#e6db74>&#34;data&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ComponentFolderAssets</span>     = <span style=color:#e6db74>&#34;assets&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ComponentFolderI18n</span>       = <span style=color:#e6db74>&#34;i18n&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ComponentFolders</span> = []<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ComponentFolderArchetypes</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ComponentFolderStatic</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ComponentFolderLayouts</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ComponentFolderContent</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ComponentFolderData</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ComponentFolderAssets</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ComponentFolderI18n</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>It can be seen that Hugo makes each module follow this unified principle by standardizing the directory structure,
so that there are rules to follow no matter when parsing themes or user projects.</p><p>Take a look at Hugo&rsquo;s description of
<a href=https://gohugo.io/hugo-modules/configuration/>module</a>:</p><blockquote><p>Hugo Modules are the core building blocks in Hugo.
A module can be your main project or a smaller module providing
one or more of the 7 component types defined in Hugo:
static, content, layouts, data, assets, i18n, and archetypes.</p></blockquote><p>That is to say <code>static, content, layouts, data, assets, i18n, and archetypes</code>
Any combination of these 7 components is considered to meet the requirements of the module.</p><p>Hugo&rsquo;s modules are built on top of Go Modules and are easy to use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>module</span>]
</span></span><span style=display:flex><span>[[<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>imports</span>]]
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>path</span> = <span style=color:#e6db74>&#39;github.com/sunwei/zero&#39;</span>
</span></span></code></pre></div><p>That is to say, we can now load the theme in the form of loading modules,
instead of importing the theme as a git submodule, which is more convenient and reasonable.</p><p>After figuring out why the theme is also a module,
let&rsquo;s take a look at the final configuration information of the module we got:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/config.go 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 140
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Process</span>(<span style=color:#e6db74>&#34;collectModules&#34;</span>, <span style=color:#e6db74>&#34;set active modules to config with key &#39;allModules&#39;&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>moduleConfig</span>.<span style=color:#a6e22e>ActiveModules</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%#v\n&#34;</span>, <span style=color:#a6e22e>m</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Output</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>&gt; <span style=color:#a6e22e>Process</span> <span style=color:#a6e22e>collectModules</span>: <span style=color:#a6e22e>set</span> <span style=color:#a6e22e>active</span> <span style=color:#a6e22e>modules</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>config</span> <span style=color:#a6e22e>with</span> <span style=color:#a6e22e>key</span> <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#a6e22e>allModules</span><span style=color:#960050;background-color:#1e0010>&#39;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>moduleAdapter</span>{<span style=color:#a6e22e>path</span>:<span style=color:#e6db74>&#34;project&#34;</span>, <span style=color:#f92672>...</span> <span style=color:#a6e22e>projectMod</span>:<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>owner</span>:<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Module</span>(<span style=color:#66d9ef>nil</span>), 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mounts</span>:[]<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>{
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>{<span style=color:#a6e22e>Source</span>:<span style=color:#e6db74>&#34;mycontent&#34;</span>, <span style=color:#a6e22e>Target</span>:<span style=color:#e6db74>&#34;content&#34;</span>, <span style=color:#a6e22e>Lang</span>:<span style=color:#e6db74>&#34;en&#34;</span>}, 
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>{<span style=color:#a6e22e>Source</span>:<span style=color:#e6db74>&#34;data&#34;</span>, <span style=color:#a6e22e>Target</span>:<span style=color:#e6db74>&#34;data&#34;</span>, <span style=color:#a6e22e>Lang</span>:<span style=color:#e6db74>&#34;&#34;</span>}, 
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>{<span style=color:#a6e22e>Source</span>:<span style=color:#e6db74>&#34;layouts&#34;</span>, <span style=color:#a6e22e>Target</span>:<span style=color:#e6db74>&#34;layouts&#34;</span>, <span style=color:#a6e22e>Lang</span>:<span style=color:#e6db74>&#34;&#34;</span>}, 
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>{<span style=color:#a6e22e>Source</span>:<span style=color:#e6db74>&#34;i18n&#34;</span>, <span style=color:#a6e22e>Target</span>:<span style=color:#e6db74>&#34;i18n&#34;</span>, <span style=color:#a6e22e>Lang</span>:<span style=color:#e6db74>&#34;&#34;</span>}, 
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>{<span style=color:#a6e22e>Source</span>:<span style=color:#e6db74>&#34;archetypes&#34;</span>, <span style=color:#a6e22e>Target</span>:<span style=color:#e6db74>&#34;archetypes&#34;</span>, <span style=color:#a6e22e>Lang</span>:<span style=color:#e6db74>&#34;&#34;</span>}, 
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>{<span style=color:#a6e22e>Source</span>:<span style=color:#e6db74>&#34;assets&#34;</span>, <span style=color:#a6e22e>Target</span>:<span style=color:#e6db74>&#34;assets&#34;</span>, <span style=color:#a6e22e>Lang</span>:<span style=color:#e6db74>&#34;&#34;</span>}, 
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>{<span style=color:#a6e22e>Source</span>:<span style=color:#e6db74>&#34;static&#34;</span>, <span style=color:#a6e22e>Target</span>:<span style=color:#e6db74>&#34;static&#34;</span>, <span style=color:#a6e22e>Lang</span>:<span style=color:#e6db74>&#34;&#34;</span>}}, <span style=color:#f92672>...</span>}
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>moduleAdapter</span>{<span style=color:#a6e22e>path</span>:<span style=color:#e6db74>&#34;mytheme&#34;</span>, <span style=color:#f92672>...</span> <span style=color:#a6e22e>projectMod</span>:<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>owner</span>:(<span style=color:#f92672>*</span><span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>moduleAdapter</span>)(<span style=color:#ae81ff>0xc00019e410</span>), 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mounts</span>:[]<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Mount</span>(<span style=color:#66d9ef>nil</span>), <span style=color:#f92672>...</span>}
</span></span></code></pre></div><p>From the output results, there are two modules in total, one is <code>project</code> and the other is <code>mytheme</code>.
Because in our example, <code>mytheme</code> has only one txt file, none of the seven components,
so the mounts are empty, and the project module has Mounts for each component.</p><p>Hugo implements Hugo Module through a clever standardized directory structure design.
Strong scalability and convenience allow users to focus on content creation, and personalization is also greatly satisfied.</p><h3 id=文件系统的组织>文件系统的组织
<a class=anchor href=#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%bb%84%e7%bb%87>#</a></h3><p>Hugo目前主要的操作都是对本地文件进行的。
比如读取配置信息、模版信息、博客内容，写入站点信息等等。
因为这些操作都离不开文件系统，Hugo因此对文件信息的组织做了许多工作，以确保调用方良好的使用体验。</p><h4 id=afero>Afero
<a class=anchor href=#afero>#</a></h4><p>首先是选择基础文件系统
<a href=https://github.com/spf13/afero>afero.Fs</a>:</p><blockquote><p>Afero is a filesystem framework providing a simple,
uniform and universal API interacting with any filesystem,
as an abstraction layer providing interfaces, types and methods.
Afero has an exceptionally clean interface and simple design without needless
constructors or initialization methods.</p></blockquote><p>Afero提供的服务基本和Golang原生Fs接口一致，其次兼容多操作系统，这样就既对语言兼容，还对系统兼容，并且使用体验还和原生一致。
确实为Hugo提供了良好的文件系统基础。</p><p>为了直观查看Hugo中多种Fs的关联，我们把afero.Fs标作如下结构，包含文件系统的基础操作样例：</p><p><img src=images/4.1-hfs-afero.Fs.svg alt="Hugo FS afero.Fs"></p><h4 id=hugo架构中的fs>Hugo架构中的Fs
<a class=anchor href=#hugo%e6%9e%b6%e6%9e%84%e4%b8%ad%e7%9a%84fs>#</a></h4><p>我们再来回顾下，Hugo架构中Fs应用的场景：</p><p><img src=images/4.0-hugo-arch-fs.svg alt="Hugo Arch Fs"></p><p>最先出现的是Fs，用来记录最贴近真实目录的文件系统，作为DpesCfg的参数，最终由HugoSites创建Deps的时候，透传给了Deps。
Deps是真正组织构建整个文件系统体系的模块，最终用PathSpec将前面的原始文件系统组织成了Hugo所需要的文件系统。
最终供给Template和Page相关操作使用。</p><h4 id=hugofs>HugoFs
<a class=anchor href=#hugofs>#</a></h4><p>我们先看基础的Fs，也就是HugoFs：</p><p><img src=images/4.2-hgf-hugoFs.svg alt="Hugo Fs hugoFs"></p><p>可以看到，基础hugoFs包含输入源Source，和输出目标地址PublishDir，以及用来只读的WorkingDir。
并且第一项都是afero.Fs类型，所以颜色和afero.Fs颜色一致。
后面也会用来颜色来对不同类型的文件系统进行关联。</p><h4 id=pathspec>PathSpec
<a class=anchor href=#pathspec>#</a></h4><p>通过上面的Hugo架构图我们知道，最终HugoFs被传入Dpes，并由PathSpec来统一组织和管理所有路径相关信息：</p><p><img src=images/4.3-hfs-PathSpec.svg alt="Hugo Fs PathSpec"></p><p>从上图看出PathSpec包含了hugoFs和Paths，还有另一个重要的BaseFs。</p><p>先看Paths，包含了基础文件系统，还包含了主题和工作目录信息，以及Modules相关的信息。
基于Fs和Path，PathSpec需要消化这些基础信息，并提供完整的文件系统服务。</p><h4 id=basefs>BaseFs
<a class=anchor href=#basefs>#</a></h4><p>通过准备好的基础信息hugoFs和Paths，BaseFs不仅要提供一些基础服务，比如源文件系统和发布目标文件系统，以及工作目录等相关信息。
还需要按Hugo要求的基础目录对文件进行组织，像Content, Data, i18n, Layouts, Archetypes, Assets。
并且要求严格按模块加载顺序，提供最终的文件服务，比如用户在工程目录增自定义了一些模板，需要覆盖主题里自带的模板时。</p><p><img src=images/4.4-hfs-BaseFs.svg alt="Hugo Fs BaseFs"></p><p>如上图所示，BaseFs用SourceFilesystems来对基础目录进行组织，用theBigFs来提供最终合并文件系统服务。</p><h4 id=sourcefilesystems>SourceFilesystems
<a class=anchor href=#sourcefilesystems>#</a></h4><p><img src=images/4.5-hfs-SourceFilesystems.svg alt="Hugo Fs SourceFilesystems"></p><p>想要映射出Hugo的基础文件结构，Hugo设计出了对应的结构SourceFilesystems来表示，并用字段一一对应。
每一项又具有共同的特征，既SourceFilesystem。</p><p>大家可以回忆下，在上一节
<a href=/en/#hugo%e7%9a%84%e6%a8%a1%e5%9d%97>Hugo的模块</a>中有提到，每一个模块是如何在Mount中存储这些信息的。</p><h4 id=thebigfs>theBigFs
<a class=anchor href=#thebigfs>#</a></h4><p><img src=images/4.6-hgs-theBigFs.svg alt="Hugo Fs theBigFs"></p><p>多模块会生成多个相同结构的文件系统，谁在前，谁在后，由模块配置信息决定。
那最终如何合并这些文件系统呢？
由上图可以看出，Hugo给出的答案是Overlay，工作原理可参考
<a href=https://zh.wikipedia.org/wiki/OverlayFS>Wikipedia OverlayFS</a>。</p><p>Overlay的组织是由filesystemCollector来进行的，用到了文件元数据FileMetaInfo来进行描述，方便相关的文件操作，如查询，排序等。
在生成最终状态的Overlay视图前，需要RootMappingFs来帮助组织按Content, Static等进行分类的文件系统。
最终由Collector来将对应的文件放到对应的集合中。</p><p>有了以上这些组织好的文件系统后，想想可能的应用场景？</p><h4 id=文件系统场景一---contentspec>文件系统场景一 - ContentSpec
<a class=anchor href=#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%9c%ba%e6%99%af%e4%b8%80---contentspec>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/deps/deps.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 145
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Process</span>(<span style=color:#e6db74>&#34;New content Spec&#34;</span>, <span style=color:#e6db74>&#34;content converter provider inside&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>contentSpec</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>helpers</span>.<span style=color:#a6e22e>NewContentSpec</span>(<span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>Language</span>, <span style=color:#a6e22e>ps</span>.<span style=color:#a6e22e>BaseFs</span>.<span style=color:#a6e22e>Content</span>.<span style=color:#a6e22e>Fs</span>)
</span></span></code></pre></div><p>准备好PathSpec后，ContentSpec的创建立马就用到了Content.Fs，也就是SourceFilesystem.Fs，依赖于theBigFs.overlayMountsContent。</p><h4 id=文件系统场景二---loadtemplates>文件系统场景二 - loadTemplates
<a class=anchor href=#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%9c%ba%e6%99%af%e4%ba%8c---loadtemplates>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/tpl/tplimpl/template.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 340
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>helpers</span>.<span style=color:#a6e22e>SymbolicWalk</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Layouts</span>.<span style=color:#a6e22e>Fs</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>walker</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>IsNotExist</span>(<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在加载用户自定义模板时，就用到了<code>Layouts.Fs</code>。
通过walker对文件系统中的模板文件进行相应的处理，依赖于<code>b.theBigFs.overlayDirs[files.ComponentFolderLayouts]</code></p><p>结合以上文件系统的设计和应用，我们可以感受到Hugo文件系统的设计需求来自于自身的特点。
因为用到了模块的理念，以及模块基础结构的设计。
基础的hugoFs并不能满足Hugo在操作文件系统过程中的所有需求，因此需要进一步封装。</p><p>Hugo的做法是用PathSpec来组织所有信息，隐藏复杂度，抽象出BaseFs提供更为贴近使用场景的综合服务。
用SourceFilesystems组织出符合Hugo基础结构特点的直观服务，并用OverlayFs底层技术，实现了多文件系统合并的需求，最终支持到真正的实际使用场景。
包括提供文章内容服务的Content文件系统，和加载自定义模板时的Layouts文件系统，等等。</p><h3 id=站点内容的收集方案>站点内容的收集方案
<a class=anchor href=#%e7%ab%99%e7%82%b9%e5%86%85%e5%ae%b9%e7%9a%84%e6%94%b6%e9%9b%86%e6%96%b9%e6%a1%88>#</a></h3><p><a href=/en/#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%bb%84%e7%bb%87>文件系统的组织</a>已经帮我们将用户站点项目按Hugo基础组件的结构进行了组织。
我们从<code>BaseFs.Content.Fs</code>可以直接获取站点内容的文件系统索引，可以直接读取文件信息，生成站点面面了。</p><p>但Hugo不这么认为，我们可以用下面两个场景来了解一下Hugo的鸿鹄之志。</p><p><strong>场景一：Headless Bundle</strong></p><p>有一种页面，我们不希望她单独作为一个页面来发布。
但可以在需要她的时候，以变量的形式获取到她。
这就是Hugo对这种需求提供的解决方案：
<a href=https://gohugo.io/content-management/page-bundles/#headless-bundle>Headless Bundle</a>。</p><p>如果直接遍历文件系统，我们在处理该文件的时候，需要知道她的类型，如果是Headless类型的，就不按常规类型处理。
那文件类型就需要在解析文件的时候，从文件信息中获取到。
页面类型的信息可以放在文件配置中，也可以通过特殊的命名规则来表明，此类方案还有许多。</p><p>如果其它的页面依赖于Headless页面，就要考虑页面解析顺序所带来的问题。
如果Headless在前面被解析，就要存储好相关索引信息，以方便后续依赖于她的文件进行查询。
如果在其它页面之后解析，可能的方案是将之前处理的页面标记为未完成状态，并指明所依赖的Headless页面，并挂起等待条件成熟时被唤醒。
等相应的Headless页面解析完成后，时机成熟时，恢复之前页面的解析流程。
这种方案在依赖的Headless页面较多的情况下，会出现不断挂起的状况。
加上这些配置都依赖于手工维护，解析效率和正确性都很难保障。</p><p><strong>场景二：Page Resources</strong></p><p>Hugo Page可以包含不同的资源，常见的有图片类型的，还有音频、视频、数据、压缩包等等多种类型的资源。</p><p>下载页面会提供资源的下载链接，比如软件的安装包，针对不同的操作系统，会提供不同的版本。
Hugo可以很聪明的识别，哪个文件是页面文件，哪些页面是资源文件，并将资源文件信息放在页面的<code>Resources</code>属性里。
这样就方便用户根据页面，来灵活组织这些资源，可以生成一个某一类型软件的下载汇总信息，还可以生成某一章节的下载软件信息。</p><p>如果直接遍历文件系统，每个文件都是相对独立的，需要通过配置信息或者其它的方式标明同一层级的从属关系，还要标明不同层级之间的引用关系。
这些都需要在全局构建信息中存储。
因为互相独立，遍历过程中又会有先后顺序，关系越复杂，重复信息出现的概率就会越高。
当有新的需求出现时，复杂的逻辑处理也不利于软件的拓展。</p><p>从以上两个场景中，可以观察到。
简单的遍历文件系统，确实可以获取基本的文件信息。
但如果需要灵活地组织各种不同的信息，如依赖关系，资源汇总等等跨页面处理场景，我们还需要进一步对站点内容进行发掘，以页面为单位进行组织和管理。</p><h4 id=磨刀不误砍柴工>磨刀不误砍柴工
<a class=anchor href=#%e7%a3%a8%e5%88%80%e4%b8%8d%e8%af%af%e7%a0%8d%e6%9f%b4%e5%b7%a5>#</a></h4><p>从
<a href=./%e4%ba%8b%e4%bb%b6%e9%a3%8e%e6%9a%b4.md>Hugo事件风暴</a>中可以清楚的看到Hugo正式收集站点内容是在<code>Hugo Build</code>阶段，之前都是在做准备：</p><p><img src=images/5.1-hugo-ddd-content-collection.svg alt="Hugo DDD - Content Collection"></p><h4 id=分工明确高效协作>分工明确，高效协作
<a class=anchor href=#%e5%88%86%e5%b7%a5%e6%98%8e%e7%a1%ae%e9%ab%98%e6%95%88%e5%8d%8f%e4%bd%9c>#</a></h4><p>电商现在的状态已然不是正在融入我们的生活，而是成为了我们生活的一部分。
并且过了拼产品类目的时期，基本上你家有的，我这也有。
现在拼的更多的是特色，和服务。
既然是特色，那每家多多少少都有些不一样。
而服务，基本上都是相同的，其中最重要的要属快递服务。
谁能以最短的时间将包裹送达消费者手中，谁将最容易获得消费者的认可，从而占有更高的市场份额，获得投资者的青睐，进入良性的循环发展。</p><p>Hugo也认同最短时间送达这样的服务理念。
拿到待处理的内容后，立马出库装车送到离消费者最近的分拣中心，再由高效的分类机器人对货品进行分类。</p><p><strong>Hugo对内容处理的目标</strong></p><p><img src=images/5.2-cpf-goal.svg alt="Content Process Flow Goal"></p><p>在我们的样例中，我们的Content就是<code>mycontent</code>目录所代表的文件系统，经过<code>PathSpec</code>处理后，文件系统可通过<code>site.BaseFs.Content.Fs</code>得到。
最终，Hugo需要对内容文件系统中的所有内容进行分类，并存放在PageMap货架上，这样方便快递小哥快速取货，装车并将包裹送达用户手中。</p><p>那Hugo到底是怎么做到的呢？</p><p><strong>陆地集装箱 &ndash; 大卡车</strong></p><p><img src=images/5.3-cpf-pagescollector.svg alt="Content Process Flow PagesCollector"></p><p>在实际生活中，包裹会从全球各地通过分拣中心网络，靠大卡车运输到离消费者最近的分拣点。
而Hugo的"大卡车"就是PagesCollector，不像现实世界那么复杂，货物都在<code>site.BaseFs.Content.Fs</code>中。</p><p><strong>分拣机器人</strong></p><p><img src=images/5.4-cpf-pagesprocessor.svg alt="Content Process Flow PagesProcessor"></p><p>等货物运到分拣中心后，经过不断对分拣效率进行优化，现在已经做到可以完全自动化。
PagesController将所有文件送达后，自动分拣机器人PagesProcessor便开始工作，无缝衔接。
为了提高处理效率，Hugo为每一个站点都提供了一个机器人，由PagesProcessor负责分发任务，sitePagesProcessor专注处理自己所擅长的语言类别。</p><p>通过明确的分工，高效的协作，最终将所有文件分门别类，规整的放在中心货架上。</p><p><img src=images/5.0-content-process-flow.svg alt="Content Process Flow"></p><h3 id=模板的生命周期>模板的生命周期
<a class=anchor href=#%e6%a8%a1%e6%9d%bf%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f>#</a></h3><p>在
<a href=%e4%ba%8b%e4%bb%b6%e9%a3%8e%e6%9a%b4.md>Hugo事件风暴</a>中，我们了解到Hugo的设计理念 - 给用户提供始终如一的轻松写作体现。
而实现这一理念则是以Golang Template为基础，开发出更多实用功能，让内容创造者专于内容创作的同时，还拥有良好的体验。</p><p>让我们回顾一下Golang Template的实现步骤：
<img src=images/1-golang-template.svg alt="Golang Template"></p><p>再看看Hugo是如何围绕其展开的：
<img src=images/2.1-hugo-whole-process-map-go-template.svg alt="hugo whole process with golang template"></p><p>Hugo围绕着Golang Template做了很多设计，现在我们通过和模板相关的领域事件，一起来看看模板的生命周期，从而能够有更全面的理解。</p><h4 id=hugo模板生命周期领域事件>Hugo模板生命周期领域事件
<a class=anchor href=#hugo%e6%a8%a1%e6%9d%bf%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e9%a2%86%e5%9f%9f%e4%ba%8b%e4%bb%b6>#</a></h4><p>还是从领域事件入手，来看看有哪些关键事件和模板强相关：</p><p><img src=images/6.0-template-ddd-events.svg alt="Template DDD Events"></p><p>除了上面和Golang Template一一映射的事件外，还有更细节的事件，为了直观好看，我们把这些事件收集到一起来进行分析：</p><p><img src=images/6.0.1-template-ddd-events-simple.svg alt="Template DDD Events simple version"></p><p>可以看到和模板强相关的事件，主要集中在创建HugoSites和Build阶段。
进一步细分，可发现模板生命周期可分为三个阶段：</p><ol><li>开始阶段，包括注册回调，并选定模板服务提供方，并出发模板更新。<ul><li>注册layouts回调到HugoSites初始化字段</li><li>设置默认模板提供方到配置项</li><li>通知模板提供者开始更新</li></ul></li><li>准备阶段，包括准备好模板执行器，收集模板相关的功能函数，解析Hugo内置和用户自定义模板，将所有模板存储到模板命名空间，以及用layout处理器连接layout和模板。<ul><li>新建模板执行器</li><li>收集模板函数到函数映射</li><li>收集文本函数到函数映射</li><li>新建模板命名空间</li><li>新建layout处理器</li></ul></li><li>渲染阶段，准备好页面内容后，回调在开始阶段注册的layouts事项，通过layout处理器查找相应的模板，最终用模板进行渲染，生成站点页面<ul><li>为内容结点创建页面</li><li>回调layout注册项进行初始化</li><li>为页面查找模板</li><li>用模板渲染页面</li></ul></li></ol><p>事件可以帮助我们清晰地了解到Hugo设计的模板生命周期。
下面我们再通过
<a href=%e6%b8%b8%e4%b9%90%e5%9c%ba.md>Hugo游乐场</a>源码梳理一遍具体实现流程，好让我们能更立体地了解到模板生命周期，同时也可以为后面的代码实现讲解章节做好准备。</p><p><strong>Template vs Layouts</strong></p><p>我们先来看看Hugo中两个容易混淆的概念，Template和Layouts。</p><p>在创建
<a href=../what/%e8%87%aa%e5%ae%9a%e4%b9%89%e4%b8%bb%e9%a2%98.md>自定义Hugo主题</a>的时候，我们接触最多的就是Layouts。
官方文档解释Layouts就是用来当模板的，这样解释并没有问题，但这会让我们很容易产生一种Layouts既模板的错觉，并将Layouts和模板直接划上等号。</p><p>但真的是这样的吗，让我们从代码层面看看他们的关联：</p><p><img src=images/6.2-layouts-vs-template.svg alt="Template vs Layouts"></p><p>通过查看新建主题的目录结构，我们会发现自动生成的的文件主要在layouts目录下，里面有首页模板，还有页头和页尾模板，等等。
在代码中，Layouts的出现通过都是以<code>[]string</code>字符串数组的形式出现的。
也就是说在<strong>代码中Layouts就是用来记录layout相关的文件路径信息</strong>的。</p><p>如果想将Layouts转换成Golang Template，首先需要将其转换成<code>templateInfo</code>。
并记录文件名，分析是否是文本类型，将layout文件内容以字符串存储在tempalte字段中。</p><p>其中是否是文本类型，涉及到Golang Template的设计知识。</p><blockquote><p>Golang将Template按类型进行了划分。如HTML和Text，通过对HTML标签进行转换，最终也会被转换成Text。
说到底，通过对不同模板类型的转换，都会变成文本类型。</p></blockquote><p>通过templateInfo，最终Hugo会生成真正的Hugo模板结构体<code>templateState</code>。
可以看出该结构体实现了<code>Template</code>接口。</p><p>所以我们可以得出结论：Layouts不等于Template，是制作Template的原材料。</p><p>弄清了Template和Layouts之间的关系，我们分别来看看Template生命周期中的开始、准备和渲染阶段。</p><p><strong>开始阶段</strong></p><p><img src=images/6.1.1-template-cycle-start.svg alt="Template Cycle Start"></p><p><code>HugoSites</code>中的init字段是<code>hugoSitesInit</code>类型的，其中就包含了lazy.init类型的layouts。
这样就可以在layouts字段注册一些回调方法，方便在时机成熟的时候回调。</p><p>同时，对于HugoSites而言，直接面对的是模板服务的提供商，所以需要在这个阶段将<code>TemplateProvider</code>作为提供商，设置在配置信息中。
等信息都准备妥当后，就可以通知模板服务提供商开始工作更新了。</p><p><strong>准备阶段</strong></p><p><img src=images/6.1.2-template-cycle-prepare.svg alt="Template Cycle Prepare"></p><p>对外提供整体服务，并和Deps关联的是<code>templateExec</code>。
包含了<code>texttemplate.executer</code>和<code>templateHandler</code>，以及所有的模板功能函数。
颜色表明各结构之间的关联关系。</p><p>可以看出，<code>texttemplate.executer</code>包含了<code>templateExecHelper</code>，因为在执行的过程中，通过对模板的分析，可能会用上功能函数。</p><p>而<code>templateHander</code>则需要处理和template相关的一些操作。
<code>main</code>字段是<code>templateNamespace</code>类型，里面存储了HTML和Text原型信息，并存储了由原型创建的所有<code>templateState</code>在<code>templateStateMap</code>中。
<code>layoutHandler</code>则是连接layout和template的关键，比如通过layout查询template时，就由layoutHandler全权负责。</p><p><strong>渲染阶段</strong></p><p>结合开始阶段和准备阶段一览：</p><p><img src=images/6.1.3-template-cycle-start-and-prepare.svg alt="Template Cycle Start and Prepare"></p><p>通过前期的准备和组织，我们来看看渲染阶段是怎么发生的：</p><p><img src=images/6.3-template-cycle-execute.svg alt="Template Cycle Render"></p><p>页面渲染发生在<code>site_render.go</code>中，从<code>pageRender</code>正式开始。</p><p>总共分为两大步，一是<code>page.resolveTemplate</code>解析模板，拿到模板后再开始<code>site.renderAndWritePage</code>渲染和写入页面。</p><ol><li><p>解析模板
因为Site组合了Deps，所以也和Deps一样，同样持有<code>templateExec</code>信息，通过调用<code>templateExec</code>的<code>LookupLayout</code>方法，查询模板信息。
因为这些模板信息都已经存储在了<code>templateNamespace</code>里的<code>templateStateMap</code>中。</p></li><li><p>渲染页面
在<code>pageRender</code>中已经拥有了页面信息<code>pageState</code>，通过上一步又获取了模板信息，所以是时候开始真正地<code>site.renderForTemplate</code>渲染了。
还是通过<code>templateExec</code>调用<code>Execute</code>方法。
因为当前的执行器是<code>texttemplate.executer</code>类型，所以真正地执行是在<code>texttemplate.executer</code>的<code>ExecuteWithContext</code>方法中。
这里是直接用的Golang Template源码，而不是调用Golang的默认包。
因为Golang默认包中自带的功能函数，并不能完全满足Hugo的诉求。
在后续代码实现章节将会详细讲述，这里还是专注在基础架构的初步理解上。</p></li></ol><h4 id=小结>小结
<a class=anchor href=#%e5%b0%8f%e7%bb%93>#</a></h4><p><img src=images/6.1-template-cycle.svg alt="Template Cycle"></p><p>从Golang Template应用示例开始，我们了解到了Golang中模板工作的基本流程。
这有助于我们进一步理解Hugo的设计和实现。</p><p>通过对Hugo领域事件中模板强相关的核心事件进行分析，我们将Hugo模板的生命周期大致分为三个阶段：开始、准备、渲染。</p><p>为了立体的理解模板生命周期，我们不仅从领域事件进行梳理，还从代码结构进行分析。
看到了Hugo是基于HTML和Text模板原型，帮助将所有的Layouts转换成Template，并存储在了Template命名空间中。
还看到为了拓展Golang Template的功能，Hugo将强大的自定义函数保存在了执行器中。
这让模板在渲染过程中，有了更多的帮手。
而这一切，都封装在了对外统一提供的服务<code>templateExec</code>中，不仅对内进行封装，还对外提供了便捷。</p><p>还有更多有意思的事情，比如Hugo为什么不能直接用Golang内置的Template包，而要独立维护？
我们也会在后续代码实现章节，进一步展开讲解。
和大家一起，一探究竟。</p><h3 id=发布的流程>发布的流程
<a class=anchor href=#%e5%8f%91%e5%b8%83%e7%9a%84%e6%b5%81%e7%a8%8b>#</a></h3><p>通过
<a href=/en/#%e6%a8%a1%e6%9d%bf%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f>模板的生命周期</a>我们可以看到在最后的渲染阶段，先找到页面的Template，然后对页面进行渲染。
这样我们就有了根据模板生成的待发布内容。</p><p>站点发布主要的任务就是将作者所创作的内容，通过模板转换生成待发布的内容，按照站点的输出格式，写入到我们指定的文件目录。</p><p>那这里就会有两个问题：</p><ol><li>作者所创作的内容是怎么存储在页面中的，又要怎么使用呢？</li><li>发布过程中的信息，如输出格式、文件名、写入地址又是谁提供的呢？</li></ol><p>我们还是从Golang Template基本原理出发:</p><p><img src=images/1-golang-template.svg alt="Golang Template"></p><p>在index.html模板中，我们计划用<code>{{.Content}}</code>属性来获取内容。
如果要成功获取，就需要在我们的内容提供商<code>Post</code>实例中，在Content字段设置上正确的值。
如果都按约定准备好后，在最终Golang Template执行结果中，我们就能发现右上角的内容。</p><p>在我们的
<a href=%e6%b8%b8%e4%b9%90%e5%9c%ba.md>游乐场示例</a>中，我们也有一个用到了<code>.Content</code>的layout - <code>layouts/_default/single.html</code>：</p><pre tabindex=0><code>-- mycontent/blog/post.md --
---
title: &#34;Post Title&#34;
---
### first blog
Hello Blog

-- layouts/_default/single.html --
{{ .Content }}
===
Static Content
===
</code></pre><p>single.html会用做独立页面的模板，如上面的<code>mycontent/blog/post.md</code>。
通过模板渲染过后，<code>post.md</code>中的内容就会替换掉<code>single.html</code>中的<code>{{ .Content }}</code>。</p><p>那Hugo的页面对象PageState又是怎么提供内容服务的呢，也和上面一样，放在属性里吗？
我们在
<a href=https://github.com/sunwei/hugo-playground>Hugo Playground</a>源码中，很快找到了答案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Page is the core interface in Hugo.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Page</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ContentProvider</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ContentProvider provides the content related values for a Page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ContentProvider</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Content</span>() (<span style=color:#a6e22e>any</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>没错，就是ContentProvider。
可以看出Golang Template不仅支持属性，同时还支持方法。
共同的特点就是要对外可见 - 都是大写字母开头。</p><p>那上面的两个问题就变得更具体了：</p><ol><li>PageState中的ContentProvider是谁？</li><li>发布流程中所需的详细信息是怎么来的？</li></ol><p><strong>发布相关的领域事件</strong></p><p>同样，我们还是可以通过
<a href=%e4%ba%8b%e4%bb%b6%e9%a3%8e%e6%9a%b4.md>领域事件风暴</a>中，发布相关的领域事件入手：</p><p><img src=images/7.0-publish-events.svg alt="Publish Events"></p><p>可以看到，关键时机有两个。
一个是在站点Site创建的时期，另一个则是在构建时期。</p><p>让我们专注在和发布相关的事件上：</p><p><img src=images/7.0.1-publish-events-simple.svg alt="Publish Events Simple"></p><p>这些事件的解读在
<a href=%e4%ba%8b%e4%bb%b6%e9%a3%8e%e6%9a%b4.md>领域事件风暴</a>中有具体描述，这里就不再赘叙。</p><p>结合
<a href=https://github.com/sunwei/hugo-playground>源码</a>，我们进一步将上述事件转换成代码流程图：</p><p><img src=images/7.1-publish-work-flow.svg alt="Publish Work Flow"></p><p>不出所料，为PageState提供内容和其它信息服务的对象确实存在，那就是<code>pageOutputs</code>。
但心中不禁升起一丝疑问，为什么是个复数？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// We create a pageOutput for every output format combination, even if this
</span></span></span><span style=display:flex><span><span style=color:#75715e>// particular page isn&#39;t configured to be rendered to that format.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>pageOutput</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// These interface provides the functionality that is specific for this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// output format.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>pagePerOutputProviders</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>ContentProvider</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// these will be shifted out when rendering a given output format.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>pagePerOutputProviders</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>targetPather</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过查阅上述源码定义，我们更加确定了我们分析的正确性。
<code>PageOutput</code>确实如我们所料，提供了<code>ContentProvider</code>服务和<code>targetPather</code>服务，这样我们前面的两个问题就有了着落。
再加上注解：</p><blockquote><p>We create a pageOutput for every output format combination, even if this
particular page isn&rsquo;t configured to be rendered to that format.</p></blockquote><p>我们发现pageOutput是和output format一一对应的，也就是说有多少种输出格式，就有多少个pageOutput，这也解释了上面关于复数的疑问。</p><p>那究竟是个什么样的对应关系，为什么要这样设计呢？
让我们还是结合上面的流程图来进行分析。</p><p><strong>站点创建时做的准备工作</strong></p><p><img src=images/7.2-publish-start.svg alt="Publish Site Creating"></p><p>我们先看在创建Site的时候，都准备了哪些和发布相关的信息。
上图右边是流程图站点的部分，从对象引用关系来看，可以了解到OutputFormats依赖于OutputFormat，但不是聚合关系。
而OutputFormat又依赖于MediaType。</p><p><strong>MediaType</strong></p><p>从上图左侧的结构图可以看出，OutputFormat是拥有MediaType字段的。
在MediaType包含的主要字段是main和sub。</p><p>那这些字段是干什么用的呢？
我们可以通过上图中间的部分来进一步了解。
在Hugo的DefaultTypes中，经过简化，我们保留了HTML, MD, TOML, TEXT四种类型。
拿HTML MediaType举例，实际上长这样<code>text/html</code>。
没错main字段就是text，而sub字段才是html。
因为首先HTML媒体类型的文件是以文本形式存储在磁盘上的，然后才是内容是以HTML格式进行组织的。
关于Media Type的详细介绍，可以参考
<a href=https://en.wikipedia.org/wiki/Media_type>Wikipedia</a>。</p><p><strong>OutputFormat</strong></p><p>再来看看OutputFormat：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Format represents an output representation, usually to a file on disk.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Format</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>   <span style=color:#75715e>// The Name is used as an identifier. Internal output formats (i.e. HTML and RSS)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// can be overridden by providing a new definition for those types.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name&#34;`</span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>MediaType</span> <span style=color:#a6e22e>media</span>.<span style=color:#a6e22e>Type</span> <span style=color:#e6db74>`json:&#34;-&#34;`</span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#75715e>// The base output file name used when not using &#34;ugly URLs&#34;, defaults to &#34;index&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>BaseName</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;baseName&#34;`</span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过注解可以看到，实际的作用就是记载了要将一个文件输出到磁盘上的相关说明信息。
比如BaseName的默认值就是index，首页就会用到，默认文件名是index.html。</p><p>Hugo提供的<code>DefaultFormats</code>根据我们的示例简化后，保留了HTML, JSON, MD三种。
其中HTML是指我们将以HTML的输出格式将文件写入到磁盘。</p><p>实例如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>HTMLFormat</span> = <span style=color:#a6e22e>Format</span>{
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>Name</span>:          <span style=color:#e6db74>&#34;HTML&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>MediaType</span>:     <span style=color:#a6e22e>media</span>.<span style=color:#a6e22e>HTMLType</span>,
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>BaseName</span>:      <span style=color:#e6db74>&#34;index&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>Rel</span>:           <span style=color:#e6db74>&#34;canonical&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>IsHTML</span>:        <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>Permalinkable</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#75715e>// Weight will be used as first sort criteria. HTML will, by default,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#75715e>// be rendered first, but set it to 10 so it&#39;s easy to put one above it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#a6e22e>Weight</span>: <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p><strong>OutputFormats</strong></p><p>如果OutputFormats和OutputFormat不是聚合关系，那又是什么关系呢？</p><p>我们直接来看看OutputFormats的结构，就清楚答案了。</p><p><img src=images/7.2.1-publish-start-output-formats.svg alt="Publish Start Output Formats"></p><p>这里的OutputFormats实际上就是按照Hugo页面的五种类型，分别提供的OutputFormat映射关系。
如果是home类型的页面，那这种类型的页面只提供按HTML格式渲染的结果，而不是其它的格式，如JSON。
也就是说<strong>在一个站点下，会为每个类型的页面都定义清楚合法的输出格式</strong>。
这将会有效保障页面在渲染的过程中，输出格式的有效性。</p><p><strong>renderFormats</strong></p><p>有了全面的站点页面输出规范后，为什么还要这个renderFormats呢？</p><p><img src=images/7.3-publish-output.svg alt="Publish Output"></p><p>从上图右下角可以看到，实际上renderFormats来自于outputFormats。
是将所有页面的outputFormats合并，去重后产生的。
可以理解为renderFormats代表着这个站点所有输出的类型。
在我们的实例中，因为所有页面只支持HTML一种类型，所以合并去重后，自然我们这个站点的renderFormats只有一个，就是HTML了。</p><p>从值的角度我们已经知道了两者之间的关联了，那为何Hugo要设置一个renderFormats呢？
从名字上看是以站点Site为单位，可以理解为站点在渲染时所有的渲染格式。</p><p>那为什么HugoSites也有一个一模一样的renderFormats呢？
从上图左上方可以看出，Site的renderFormats组成了HugoSites的renderFormats。
这个好理解，因为HugoSites是由多个不同语言的Site所组成的，那就是说HugoSites的renderFormats代表了全站点的渲染格式。</p><p>继续通过上图往右看，可以发现更多的线索。
原来pageOutputs和HugoSites的renderFormats是一一对应关系，也就是说全站点有多少种渲染格式，就有多少个pageOutputs。</p><p>这里不禁又冒出另一个大大的问号 - 每个站点都拥有自己的页面，也都有自己的输出格式，<strong>为什么要为单个站点页面提供全站点输出格式的pageOutputs呢？</strong></p><p>同样，我们还是可以从源码中找到答案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/page__new.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 97
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Prepare output formats for all sites.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We do this even if this page does not get rendered on
</span></span></span><span style=display:flex><span><span style=color:#75715e>// its own. It may be referenced via .Site.GetPage and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// it will then need an output format.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ps</span>.<span style=color:#a6e22e>pageOutputs</span> = make([]<span style=color:#f92672>*</span><span style=color:#a6e22e>pageOutput</span>, len(<span style=color:#a6e22e>ps</span>.<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>renderFormats</span>))
</span></span></code></pre></div><p>从上面的代码中可以看到，这样设计的原因是页面可能会被其它的页面引用，甚至被不同语言的页面所调用。</p><p>对应的<code>.Site.GetPage</code>功能函数在多语言使用场景下的
<a href=https://gohugo.io/functions/getpage/#getpage-and-multilingual-sites>具体说明</a>如下：</p><blockquote><p>The previous examples have used the full content filename to lookup the post.
Depending on how you have organized your content (whether you have the language
code in the file name or not, e.g. my-post.en.md), you may want to do the lookup
without extension. This will get you the current language’s version of the page:</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>{{ <span style=color:#a6e22e>with</span> .<span style=color:#a6e22e>Site</span>.<span style=color:#a6e22e>GetPage</span> <span style=color:#e6db74>&#34;/blog/my-post&#34;</span> }}{{ .<span style=color:#a6e22e>Title</span> }}{{ <span style=color:#a6e22e>end</span> }}
</span></span></code></pre></div><p>既然存在跨站点调用的情况，那就得为调用方准备好调用方所需要的输出格式。
这样回过头来看，为每个页面pageState准备全站点渲染格式的pageOutputs是必需的。</p><p><strong>pageOutputs</strong></p><p>在发布流程中，除了内容，还有一些基础信息也很重用，如发布到哪，以什么名字写入等等。
pageOutput做为输出信息的总载体，这些信息自然了也包在其中，通过上图右上方可以看到负责提供这些信息的对象是PagePaths。
其中提供目标文件名的则是其中的targetPaths。</p><p><strong>PagePaths</strong></p><p>细心的小伙伴会发现Site的OutputFormats和PagePaths之间有一条虚线连接。
之所以是虚线，是因为PagePaths实际上是从pageMeta中获取的信息，但根源，实际上还是来源于Site的OutputFormats。</p><p>结合中下方有进一步实样例解释。
可以看到PagePaths会根据当前页面pageState的类型<code>pageKind</code>来获取当前类型的OutputFormats。
会根据每一种OutputFormat生成相应的targetPathsHolder。</p><p>根据每一个PageOutput的OutputFormat类型，选中相应的targetPathsHolder，设置在<code>pagePerOutputProviders</code>之中。
这样在渲染页面时：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pageRenderer</span>(
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>siteRenderContext</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Site</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pages</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>pageState</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>results</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>error</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>pages</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>templ</span>, <span style=color:#a6e22e>found</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>resolveTemplate</span>()
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>targetPath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>targetPaths</span>().<span style=color:#a6e22e>TargetFilename</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>renderAndWritePage</span>(<span style=color:#e6db74>&#34;page &#34;</span><span style=color:#f92672>+</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Title</span>(), <span style=color:#a6e22e>targetPath</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>templ</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34; render err&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%#v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>results</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就可以通过<code>p.targetPaths().TargetFilename</code>获取到目标文件名了。</p><h4 id=独立页面的发布流程>独立页面的发布流程
<a class=anchor href=#%e7%8b%ac%e7%ab%8b%e9%a1%b5%e9%9d%a2%e7%9a%84%e5%8f%91%e5%b8%83%e6%b5%81%e7%a8%8b>#</a></h4><p>Hugo将页面分成了两大类，一类就是上面介绍的常规页面，另一类就是接下来要看的独立Standalone页面，如404页面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Site</span>) <span style=color:#a6e22e>render404</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newPageStandalone</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pageMeta</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>s</span>:    <span style=color:#a6e22e>s</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>kind404</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>urlPaths</span>: <span style=color:#a6e22e>pagemeta</span>.<span style=color:#a6e22e>URLPath</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>URL</span>: <span style=color:#e6db74>&#34;404.html&#34;</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	},
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>output</span>.<span style=color:#a6e22e>HTMLFormat</span>,
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>render</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#a6e22e>output</span>.<span style=color:#a6e22e>LayoutDescriptor</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>Kind</span> = <span style=color:#a6e22e>kind404</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>templ</span>, <span style=color:#a6e22e>found</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Tmpl</span>().<span style=color:#a6e22e>LookupLayout</span>(<span style=color:#a6e22e>d</span>, <span style=color:#a6e22e>output</span>.<span style=color:#a6e22e>HTMLFormat</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>found</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>targetPath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>targetPaths</span>().<span style=color:#a6e22e>TargetFilename</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>targetPath</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;failed to create targetPath for 404 page&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>renderAndWritePage</span>(<span style=color:#e6db74>&#34;404 page&#34;</span>, <span style=color:#a6e22e>targetPath</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>templ</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代码流程很清晰，先通过<code>newPageStandalone</code>创建页面，紧接着查找模板，获取目标文件名，最后渲染并写入页面。
整体流程基本一致。</p><p>既然PageOutput是发布流程上的关系所在，那我们还是用PageOutput的视角来看看独立页面会有哪些不同，同时也可以检测一下我们之前的理解是否正确。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/page__new.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 92
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newPageFromMeta</span>(
</span></span><span style=display:flex><span><span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>contentNode</span>,
</span></span><span style=display:flex><span><span style=color:#a6e22e>parentBucket</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>pagesMapBucket</span>,
</span></span><span style=display:flex><span><span style=color:#a6e22e>meta</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>any</span>,
</span></span><span style=display:flex><span><span style=color:#a6e22e>metaProvider</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>pageMeta</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>pageState</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ps</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>standalone</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ps</span>.<span style=color:#a6e22e>pageOutput</span> = <span style=color:#a6e22e>makeOut</span>(<span style=color:#a6e22e>ps</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>outputFormats</span>()[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>shouldRenderPage</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>outputFormatsForPage</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ps</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>outputFormats</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过<code>newPageFromMeta</code>源码我们发现，对<code>standalone</code>的页面是有特殊处理的，而且用的就是<code>render404</code>中传入的<code>output.HTMLFormat</code>生成了pageOutput。</p><p>这样一来，我们可以确定的说，无论是普通页面，还是独立页面，基本上都是以pageOutput为核心进行展开的，符合同一套发布流程。
让我们再来回顾一下发布流程全景图：</p><p><img src=images/7.4-publish-full.svg alt="Publish Process Full Process"></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/sunwei/hugo-notes/commit/c8541af0232f673aa57394d32318b50c8012ca6f title='Last modified by sunwei | February 8, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 8, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/sunwei/hugo-notes/edit/main/content/docs/how/arch/index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#hugo-architecture>Hugo Architecture</a><ul><li><a href=#architecture-design-of-hugo>Architecture Design of Hugo</a></li><li><a href=#hugos-component-design>Hugo&rsquo;s component design</a><ul><li><a href=#the-relationship-between-configuration-and-language>The relationship between configuration and language</a></li><li><a href=#hugo-modules>Hugo modules</a></li><li><a href=#文件系统的组织>文件系统的组织</a></li><li><a href=#站点内容的收集方案>站点内容的收集方案</a></li><li><a href=#模板的生命周期>模板的生命周期</a></li><li><a href=#发布的流程>发布的流程</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>