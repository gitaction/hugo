<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Deep Understanding of Hugo</title><link>https://hugo.notes.sunwei.xyz/en/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</link><description>Recent content on Deep Understanding of Hugo</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hugo.notes.sunwei.xyz/en/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://hugo.notes.sunwei.xyz/en/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E5%86%85%E5%AE%B9%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/en/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E5%86%85%E5%AE%B9%E8%A7%84%E8%8C%83/</guid><description>ContentSpec # 从基础架构中提到的Template vs Layouts章节，我们了解到Layouts是Template的重要组成部分。 Template将站点样式和内容分离，我们只需要提供内容就可以。
这里就会出现一个疑问：在写作的时候，我们用的明明是Markdown语法，并不是HTML超文本，而Template接收的内容格式是HTML。 那是在什么时候，由谁将Markdown转换成HTML的呢？
这就要聊到咱们Deps中的另一个依赖ContentSpec了。
了然于胸 - ContentSpec时序图 # 先通过新建时序图，来看看ContentSpec是如何进行组织和构建的。
我们先看创建和返回，新建ContentSpec的时候，首先调用的是markup.NewConverterProvider，由此返回的也是converterRegistry。 由此可见，ContentSpec实际上是ConverterProvider - 转换器提供方，实例就是converterRegistry - 转换器注册处。 也就是说，Hugo采用的是注册制，可能会有多个转换器注册在注册处，可根据请求的类型，返回相应的转换器，正是让专业的人干专业的事。
那我们接着来看看Hugo是如何设计这个转换器注册处的。
通过中间栏可以看到，Hugo先解析相关的配置项，可以了解到用户的定制化需求和默认的配置信息，如这么多markdown的开源工具，我们默认用哪一个。 再创建一些通用的工具，如高亮组件，可以用来满足用户的高亮需求。 做好了上述的准备工作后，注册处就可以开始营业了，提供的服务当然就是注册Markdown提供方了，在我这注册后，有活的时候，就可以分派给你了。 上图示例中的提供方就是goldmark.Provider，goldmark下是现在Hugo采用的默认markdown解析器。
在注册处里，并没有直接提供goldmark实例，而是提供了标准的converter.Provider，在这里面，包含了由goldmark.New提供的goldmark实例。 就像注册到滴滴平台的网约车，要求能够提供符合滴滴标准的车辆服务。
注册处为了方便查找服务提供方，还给这些提供方取了别名，给goldmark取的别名就是default。 如果没有特殊要求，注册处派出的服务提供方都是goldmark。 在网约车中，相当于滴滴的官方推荐。
注册处，是一个服务提供方。 我在打车的时候，才会打开滴滴的应用。 那在Hugo里，什么时候，会用到转换器注册处呢？
我们接着再来看看具体地使用场景。 如上述时序图所示，正是站点在渲染内容时使用到转换器的实际场景。
这个场景是由render渲染阶段触发的，正是Hugo在构建站点过程中对转换器使用的主要场景。 在上图最右边，我们可以看到，将需要渲染的内容renderContent交给converter进行转换，最终返回转换过后的结果convert.Result。 正是在这里，我们将用户所书写的markdown内容，转换成了我们所需要的HTML内容。
顺带看一下Hugo的渲染思路。 通过时序图的左侧可以看到，这是发生在render的准备阶段，Hugo为所有的Pages精心打扮一番，为渲染做好准备。
从基础架构中介绍的 OutputFormats我们了解到，每个Page页面可以有多个OutputFormats输出格式。 在渲染的过程中，会明确具体要渲染的格式RenderFormats，RenderFormats是对OutputFormats去重后，处理生成的。
为了满足render时的要求，在准备阶段，Hugo为所有的Page，根据OutputFormat，都生成了相应的PageContentOutput。 如上图中间部分所示。
这样，我们的content就为render做好了准备。 合并后的RenderFormats也拥有了符合格式要求的内容信息，再配合Template，就可以生成最终的站点页面了。
这样一来，我们了解了Hugo是如何对注册处进行管理的。 以及转换器提供方要到什么地方，是如何完成注册操作的。 还了解到Hugo是在何时用到转换器的。 这样，从使用场景，到服务提供方，我们对全流程有了清晰的认识。 但还是感觉好像缺了什么似的，没错，那就是这些提供发究竟是如何将Markdown一步步转换成HTML的？
带着这个问题，拿Hugo Markdown默认转换器goldmark为例，我们来一探究竟。 详情请查看Markdown文件是如何被翻译成HTML的章节。
抽象总结 - 输入Markdown格式内容，输出HTML格式渲染结果 # 想要将Markdown格式的内容，渲染成最终的HTML，需要先从注册处获取转换器，新建实例后，用实例来进行最终渲染。
工欲善其事，必先利其器 - 获取转换器：
在转换器注册处，注册了不同的提供方。 为了方便查找，用名字作为索引。 这样调用方就能通过名字方便地获取能满足诉求的转换器提供方。 需要正式使用的时候，只需要调用New新建方法，就可以得到拥有实际转换功能的转换器。
进入转换环节后。 面对Markdown语法结构的字符流，解析器选择的数据结构是AST语法抽象树，这种结构的优点是树状结可以帮助表达内容Block之间的依赖关系。 不仅如此，树状结构很容易对树结点进行走查。 这样等进入到渲染阶段时，我们就可以专注在具体地渲染事项上，再不用关心结点之间的关联和依赖了。 这样，在调用相应的渲染方法，只需专注在具体地渲染细节上了。 比如在渲染heading的时候只需要关注标题的级别，选用对应的HTML标签就可以了。</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/en/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E8%B7%AF%E5%BE%84%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/en/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E8%B7%AF%E5%BE%84%E8%A7%84%E8%8C%83/</guid><description>PathSpec # 我们一个个来看，先看PathSpec。 通过基础架构中介绍的 文件系统的组织我们了解到，PathSepc正是文件系统的关键所在。
了然于胸 - NewPathSpec时序图 # 从上图可以看出，Hugo为自己量身打造的文件系统，庞大且复杂。 光文件系统就有很多种，仅上面提到的就有BasePathFs，BaseFs，baseFileDecoratorFs，OverlayFs，RootMappingFs，SliceFs, LanguageFs。 可以说琳琅满目，数不胜数。 在感叹的同时，也不禁惊心，学习曲线这么陡，可要怎么学！？
为了不把深入理解Hugo系列写成从入门到放弃系列，让我们先静下心来，发挥一下跬步千里的精神。 陡坡再陡，一天走一步，也总有到头的时候。
通过观察，我们发现无论Hugo如何组织这些文件系统，目标实际上只有一个，那就是在使用的时候，简单直接，将复杂的需求封装在内部。 那说一千，道一万，还是个文件系统。
所以首先我们要弄清楚什么是文件系统，以及Hugo是怎么使用文件系统的。 这么多文件系统之间又是个什么样的关系？
从最开始准备的Path，我们看到除了一些常见的信息，如基础Fs，配置信息Cfg，主题目录，工作目录还有发布目录外，还包含了所有模块的信息AllModules。 模块和文件系统又是什么样的关系？ 接着我们发现在真正构建文件系统的时候，sourceFilesystemBuilder首先做的事情就是创建OverlayFs，为什么这里用到了OverlayFs，要帮助Hugo解决什么样的问题？ 在创建OverlayFs的过程中，还用到了Radix Tree基数树数据结构，基数树是什么，又为什么要用？
通过以上这些疑问，我们可以把这个陡坡分拆成一个个的小坡：
什么是文件系统，Hugo是怎么理解的？ 多个文件系统之间是如何关联的？ Modules和文件系统之间，又存在什么样的关系？ 什么是OverlayFs，为什么要用？ 什么是radix tree? 先弄清楚这些问题，再让我们回过头来查看源码。
出发吧，伟大的软件工程师啊！
什么是文件系统，Hugo是怎么理解的？ # 管理人力的，我们叫人力系统；管理招聘的，我们叫招聘系统；那管理文件的，我们就叫文件系统。
在基础架构 文件系统的组织中，我们有提到Hugo的文件系统是基于Afero库来构建的。
那我们先来看看Afero是怎么定义文件系统的： 通过Hugo对文件系统的实际应用，我们可以发现主要用到了Afero中的两个接口，一个是Fs，另一个是Lstater。 前面一个就是文件系统了，包含打开文件，查询状态等文件相关的操作。 后面的状态机Lstater则在查询状态的后面加上了如果可能的字样，增强了适用性。
那Afero在PathSpec中是怎么得到应用的呢？ 我们知道在创建依赖Deps之初，有将文件信息传入依赖配置项depsCfg中，这里是最原始的文件信息，虽然叫Fs，但并没有提供文件系统的功能。 真正开始组织和构建文件系统的是中间的BaseFs，不仅关联上初始的信息，还包含了文件系统收集完成后的SourceFilesystems。 里面的源文件系统SourceFilesystem都完整的实现了Afero中的Fs和Lstater接口。
这里举一个实际的应用场景，来帮助理解： readAndProcessContent就是用来读取和处理站点内容的函数，将会在下一个章节渲染中进行介绍。 在这里，我们将用这个具体的场景，来帮助我们理解上面的文件系统BaseFs究竟是在为什么做准备。
从上图可以看到，如果我们要开始处理站点内容了。 我们可以通过站点site实例，很容易的得到站点内容的文件系统。 而这个真实的文件系统，正是来自于BaseFs中的Content.Fs。
拿到内容文件系统后，就可以创建好Walkway实例，并对其中的文件进行遍历Walk了。
site又是怎么持有BaseFs的？ 这个不是在PathSpec中吗？
这里就要提到Golang的组合机制了，可以用组合的方式，对结构体进行拓展： 可以清晰地看到他们之间的关系就是Site -&amp;gt; Deps -&amp;gt; PathSpec -&amp;gt; BaseFs，就是有点长，容易迷失方向。
在Walk的过程中，主要用到的就是Lstater中的LstatIfPossible方法。
多个文件系统之间是如何关联的？ # 我们通过一个实际应用场景，了解到为什么要这样组织文件系统。
从 基础架构的文件系统章节了解到了Hugo中复杂的文件系统： 虽然这张图能够从基础架构的角度出发，帮我们了解到文件系统是如何组织在一起的。 看起来有些复杂，但仍没能展示所有的文件系统之间的关联。 比如说，在BaseSpec中的SourceFilesystems里面，SourceFilesystem中的Fs究竟指的是哪些文件系统，和OverlayFs又有什么关联呢？</description></item></channel></rss>