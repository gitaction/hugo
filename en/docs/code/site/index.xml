<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Deep Understanding of Hugo</title><link>https://hugo.notes.sunwei.xyz/en/docs/code/site/</link><description>Recent content on Deep Understanding of Hugo</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hugo.notes.sunwei.xyz/en/docs/code/site/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://hugo.notes.sunwei.xyz/en/docs/code/site/create/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/en/docs/code/site/create/</guid><description>onCreated # Deps新建后，我们就可以应用Deps了。 在新建HugoSites的流程中，可以看到应用Deps的操作发生在onCreated中。
了然于胸 - onCreate时序图 # 从左下角可以看出，onCreate主要分为三部分，分别是：
NewDestinationPublisher: 为站点创建publisher initializeSiteInfo：初始化站点信息，将站点所依赖的信息都汇集到一块 newPageCollection：创建页面集合，因为最终渲染是以页面为单位，所以在HugoSites中为每个站点都配备了一个聚集器 NewDestinationPublisher # pub, err := publisher.NewDestinationPublisher( d.ResourceSpec, s.outputFormatsConfig, s.mediaTypesConfig, ) ... s.publisher = pub ResourceSpec来自于Deps，其中包含了全面文件系统信息的PathSpec，和outputFormats, mediaTypesConfig，在我们的例子里，都是默认配置。 而在publisher中，我们不拥有当前site拥有的配置信息 - outputFormatsConfig, mediaTypesConfig。 同时拥有默认信息和定制化信息，这样我们就可以针对当前site进行定制化处理了。
initializeSiteInfo # func (s *Site) initializeSiteInfo() error { // Assemble dependencies to be used in hugo.Deps. s.Info = &amp;amp;SiteInfo{ title: &amp;#34;title&amp;#34;, relativeURLs: s.Cfg.GetBool(&amp;#34;relativeURLs&amp;#34;), owner: s.h, s: s, } return nil } 在我们的例子中对基本信息做了简化，可以看到，这里会对站点所需要的基本信息，像标题等等进行汇总。
newPageCollection # ... pm := &amp;amp;pageMap{ contentMap: newContentMap(), s: s, } s.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/en/docs/code/site/markdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/en/docs/code/site/markdown/</guid><description>Markdown文件是如何被翻译成HTML的 # Markdown是一种文件格式，也是一种约定的语言。 之所以大受欢迎，是因为Markdown其简洁的语法。 不仅让作者在写作的过程中专注在内容创作上，让读者流畅的进行阅读。 还可以将内容直接发布到互联网上，方便传阅，让作品可以轻松的接触到更多的读者。
如果只是为了写作，传统的文本编辑器提供了更强大的样式支持，哪怕是高要求的印刷出版物，一样可以百分百支持。 随着互联网的发展，将文章放到网上已然成了一项基本需求。
而传统的文本编辑器上网的能力似乎不能满足现在的普遍需求。 一是这些强大的编辑器通常出自某一家大公司，并不是行业标准。 种类繁多不说，各家标准也不同，还没有全部公开，这些都让浏览器团队有心无力。
如果说只是要将内容放到网上，那传统的HTML不行吗？ 这就是浏览器钦定的格式啊。 确实如此，HTML是方便了浏览器解析、渲染和展示，但对于写作者来说，并不友好，光标签种类就几十种，更不要提各种不同标签的属性了。
在这种左右两难的背景下，Markdown站了出来。 用简洁的语法替代了相对复杂的HTML，让创作者能更专注在内容创作上。 将标准开放，让大家参与其中，可遵循标准，也可以自定义标准，慢慢的也出现的统一的标准。
Hugo支持的就是Markdown语法，那Hugo是如何将Markdown语法文章翻译成HTML文本的呢？
通过查看最新的Hugo源码，我们发现Hugo将默认的Markdown解析器设置成了Goldmark。
那我们的疑问就变成了：Goldmark是如何将Markdown转换成HTML的呢？
Goldmark工作原理 # 根据 Goldmark的介绍。 Goldmark遵循了 CommonMark 0.30规范。 用AST(Abstract Syntax Tree)结构对内容进行了解析。
要想知道Goldmark的工作原理，得先弄清楚CommonMark和AST这两个知识点。
CommonMark 0.30 # 说到CommonMark规范，大家可能不了解。 但说到GitHub Flavored Markdown，相信大家都有过使用经验，其实GitHub Flavored Markdown就是基于CommonMark规范演化而来的。
细节在 CommonMark Spec 0.30中都有很清楚的描述。 下面我们从领域知识的角度，来进行解读。
让我们从一个例子开始：
A paragraph with two lines. indented code &amp;gt; A block quote. 上面是一段用Markdown语法编写的文本信息，在解析阶段，会被解析成AST，如下图所示：
Goldmark先将文本信息读取到内存，如上图左所示。 那Goldmark是怎么解读这段文本的呢？
对于字符流的处理，有的是按字符一个个进行处理的，如JSON解析。 有的则是按行进行处理的，如配置文件。
通过Commonmark Spec中的 解析策略可以看出，是按行处理的。
那我们上面的文本就会按下面的顺序，以行为单位进行处理：
结合我们的MD写作习惯，让我们回想一下，是不是很多格式需要用换行来辅助说明。 比如段落，我们可以以每个句号为一行，可以换行，只要没有空行，就认为这些句子都是一个段落。 如果想要另起一个段落，直接用空行分隔就行。</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/en/docs/code/site/resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/en/docs/code/site/resources/</guid><description>LoadResources # 创建HugoSites的最后一步就是LoadResources，没错，不知不觉中，我们已经走到了这一步。
// LoadResources loads translations and templates. func (d *Deps) LoadResources() error { if err := d.templateProvider.Update(d); err != nil { return fmt.Errorf(&amp;#34;loading templates: %w&amp;#34;, err) } return nil } LoadResources也就做了一件事，就是专注在通知templateProvider，可以开始更新了。
我们的templateProvider就是默认的tplimpl.DefaultTemplateProvider。
// Update updates the Hugo Template System in the provided Deps // with all the additional features, templates &amp;amp; functions. func (*TemplateProvider) Update(d *deps.Deps) error { tmpl, err := newTemplateExec(d) if err != nil { return err } return tmpl.</description></item></channel></rss>