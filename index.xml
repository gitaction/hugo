<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>大纲 on Deep Dive into Hugo: Becoming an Expert in the Static Site Generator Domain</title><link>https://hugo.notes.sunwei.xyz/</link><description>Recent content in 大纲 on Deep Dive into Hugo: Becoming an Expert in the Static Site Generator Domain</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hugo.notes.sunwei.xyz/index.xml" rel="self" type="application/rss+xml"/><item><title>为什么要读Hugo源码</title><link>https://hugo.notes.sunwei.xyz/posts/creating-a-new-theme/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/posts/creating-a-new-theme/</guid><description>Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>https://hugo.notes.sunwei.xyz/posts/migrate-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/posts/migrate-from-jekyll/</guid><description>Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title>(Hu)go Template Primer</title><link>https://hugo.notes.sunwei.xyz/posts/goisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/posts/goisforlovers/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>https://hugo.notes.sunwei.xyz/posts/hugoisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/posts/hugoisforlovers/</guid><description>Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/what/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/what/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/</guid><description>个人站点样例: https://sunwei.xyz # Hugo能很方便的帮助我们构建站点，接下来我们来重放一下我的个人站点是如何构建出来的。
需求 # 将原有的纯HTML站点切换成Hugo站点。
原站点一览：
功能也不复杂，让我们切换到原始版本。 通过git history可以查到提交记录如下： ➜ xyz git:(master) git checkout ef51befc96f398dcfac1b5c04eb4dc7101633012 得到源码如下：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1, shrink-to-fit=no&amp;#34;&amp;gt; &amp;lt;title&amp;gt;sunwei.xyz&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;width: 400px; margin: 20px auto;&amp;#34;&amp;gt; &amp;lt;a href=&amp;#34;/&amp;#34;&amp;gt;中文&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;/en.html&amp;#34;&amp;gt;English&amp;lt;/a&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;孙伟&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;专注企业级端到端解决方案&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;h5&amp;gt; &amp;lt;span&amp;gt;读书笔记&amp;lt;/span&amp;gt; &amp;lt;/h5&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://ent.sunwei.xyz&amp;#34; target=&amp;#34;_blank&amp;#34;&amp;gt; 企业级应用 &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://buildkit.notes.sunwei.xyz/&amp;#34; target=&amp;#34;_blank&amp;#34;&amp;gt; Moby Buildkit 源码读书笔记 &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;h5&amp;gt;&amp;lt;span&amp;gt;工具&amp;lt;/span&amp;gt;&amp;lt;/h5&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://jsoneditoronline.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/what/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/what/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98/</guid><description>自定义Hugo主题 # Hugo可以创建站点，还可以创建自己的主题。 以站点 sunwe.xyz为例。 让我们将站点中的内容和主题分离，让我们专注在内容创作上。 同时还可以让更多和我们有共同诉求的人，重用我们的主题。
需求分析 # 我们的目标是分离出站点的主题，也就是将content和layouts，及static分离开，并作为主题引入。
所需要的步骤如下：
创建主题仓库 将模板样式从原有站点分离出来 引入主题 实施细节 # 接下来我们一步步的实现以上需求。
创建主题仓库 # 因为站点定位个人品牌，需求并不复杂，以简洁为主。 我们给主题取名zero，寓意起点。
首先创建好空的zero Github仓库，再用Hugo命令生成主题默认目录结构：
➜ zero git:(main) ✗ hugo new theme . Creating theme at /Users/sunwei/github/sunwei/zero/themes ➜ zero git:(main) ✗ ls LICENSE README.md public resources themes 可以看出，Hugo认为我们是在站点里，正在给站点创建主题。 实际上我们需要的是themes里面的内容。 在我们的实例中，其实就theme.toml这一个主题配置文件。 拷贝到我们的仓库根目录下后，更新其中说明内容如下：
name = &amp;#34;Zero&amp;#34; license = &amp;#34;MIT&amp;#34; licenselink = &amp;#34;https://github.com/sunwei/zero/blob/master/LICENSE&amp;#34; description = &amp;#34;Hugo Theme for sunewi.xyz&amp;#34; homepage = &amp;#34;https://sunwei.xyz/&amp;#34; demosite = &amp;#34;https://sunwei.</description></item><item><title>1.1 静态站点</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/ssg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/ssg/</guid><description>1.1 静态站点的背景和重要性 # 静态站点生成（Static Site Generation，简称SSG）是一种构建网站的方法，其核心思想是在网站发布之前提前生成网页，而不是在每次用户请求页面时动态生成。 这与传统的动态网站生成方法相比有一些显著的区别。
在静态站点生成中，网站的内容在构建时被预先处理并生成静态文件，通常是HTML、CSS、JavaScript等。 这些文件可以直接由服务器提供给用户，而不需要在服务器端进行实时的数据库查询或页面渲染。 这就有了一些优势：
性能优势： 由于页面在构建时就已经生成，用户请求时可以直接提供静态文件，无需服务器实时生成页面内容，因此响应更迅速。
安全性： 由于没有动态生成的过程，一些潜在的安全漏洞和攻击面减少，使得网站更安全。
简化部署： 静态站点可以轻松部署到各种托管服务或内容分发网络（CDN）上，而不需要特定的服务器环境或数据库。
成本效益： 由于无需服务器端的动态处理，网站可以更轻松地扩展，并且通常需要更少的服务器资源。
易于维护： 静态站点生成工具通常提供了易于管理和维护的工作流程，可以更方便地管理网站内容。
一些流行的静态站点生成工具包括 Jekyll、Hugo、Gatsby 等。 这些工具通常支持使用模板语言、标记语言（如Markdown）和数据源来定义网站的结构和内容。
静态站点增长趋势 # 随着JAMstack - JavaScript、APIs（应用程序接口）和标记（Markup），架构的兴起和静态站点生成工具的发展，静态站点的使用逐渐增加。 许多开发者和企业认识到静态站点的性能和安全性优势，并选择采用这种架构。
随着免费的GitHub Pages、Netlify等服务越来越丰富，再加上静态站点生成工具的普及，这些服务和工具使得静态站点的部署变得更加简单。 一些流行的静态站点生成工具，如Jekyll、Hugo、Gatsby等，得到了广泛的应用，使得静态站点的生态也越来越健康。
不要以为都是一些小打小闹，事实证明，越来越多的企业也采用了静态站点。 因为静态站点特别是适用于内容不经常变化的官方网站、文档站点等。 企业知识管理一直是刚需，特别是在大数据时代，你拥有什么样的数据，就代表着你可以提供什么样的服务，能为用户创造什么样的价值。
GitLab直接用静态站点来管理他们的 GitLab Strategy战略。 这样公开战略的好处是能吸引来其它那些有相同目标的公司，增加合作的机会。 还可以让战略方便可查，这样在员工的日常工作中，就可以依据战略快速做出正确的决策，提高了效率，也保证了战略的执行和落地。 真可谓是一举多得。
静态站点在数字化大舞台上的身影 # 在数字化时代，静态站点具有广泛的应用，其优势使得它们在多个场景中成为合适的选择。 比如：
企业官方网站： 许多企业选择使用静态站点作为官方网站，以展示公司信息、产品和服务。静态站点提供了简单而高效的方式，使企业能够在数字化时代中建立在线存在感。
博客和个人网站： 静态站点生成工具（如Jekyll、Hugo、Gatsby等）使得个人博客和网站的创建变得更加容易。这些工具允许用户使用标记语言（如Markdown）编写内容，然后生成静态页面。
文档和知识库： 静态站点非常适合构建文档和知识库。通过使用Markdown等标记语言，可以轻松地创建、更新和维护文档内容，并通过静态站点的方式进行部署。
产品和服务宣传页面： 静态站点可以用于构建产品和服务的宣传页面，向用户展示产品功能、优势和案例。
事件页面： 用于宣传和管理各种活动、会议和活动的静态站点可以提供信息传递、注册和参与的平台。
电子书和在线教育： 静态站点可用于构建电子书和在线教育平台。通过生成静态页面，可以为用户提供稳定、快速的学习体验。
展示性网站和投影： 静态站点常用于展示性的网站，例如艺术家的在线作品集、摄影集或投影。这些站点不需要复杂的动态交互，更适合使用静态生成。
快速原型和临时页面： 在数字化时代，业务和开发人员可能需要快速创建原型或临时页面以测试新概念或提供临时性的信息，静态站点生成工具能够快速满足这些需求。
在数字化时代，静态站点是一种强大、灵活且高效的选择，适用于多种不同的应用场景。 其性能优势、安全性和易于部署的特点使得静态站点在数字化时代的需求十分强劲。
静态站点在Web3.0时代的机遇 # 在Web3.0时代，静态站点可能会迎来一些机会和变革，与传统的Web2.0相比，这一时代强调去中心化、加密、智能合约等新的概念。
Web3.0强调去中心化的概念，而静态站点适合在去中心化存储系统中进行部署。 静态站点可以通过智能合约与区块链网络进行集成。 这使得站点能够更紧密地与区块链互动，从而实现更多的功能，例如验证身份、实现支付。 静态站点可以用于展示、管理和交互数字资产。 通过结合加密技术和区块链，静态站点可以提供更安全的数字体验，例如展示数字艺术品、管理数字身份。 Web3.</description></item><item><title>1.2 Hugo简介</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/hugo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/hugo/</guid><description>1.2 Hugo简介 # Hugo，这款用Go语言编写的静态站点生成工具，有着简洁而富有创新性的发展历史。 由Steve Francia于2013年创建，Hugo的目标是提供一种快速、灵活且容易使用的解决方案，以满足不同用户对于静态站点生成的需求。
Hugo的初衷源于对现有静态站点生成工具的不满，因此Steve Francia决定开发一款更为高效和直观的工具。 在其创始人的引领下，Hugo迅速发展成为一款备受欢迎的静态网站生成器，以其出色的性能和简单易用的特性受到用户和开发者的广泛赞誉。
在Hugo的发展历程中，开源社区的贡献也起到了重要作用。 Hugo的源代码开放并托管在GitHub上，这促使了开发者社区的积极参与，为Hugo的持续改进和功能丰富的插件系统的形成做出了重要贡献。
通过不断演进和改进，Hugo不仅在性能上有所突破，还在用户友好性、灵活性和部署便捷性方面取得了显著进展。 这些特性让Hugo成为了静态站点生成领域的领军工具，为用户提供了一种高效、可靠的建站解决方案。
Hugo是用Go语言编写的一个静态站点生成工具，号称史上最快 # Hugo是一款使用Go语言编写的静态站点生成工具，以其卓越的性能和出色的速度而著称，被誉为&amp;quot;史上最快&amp;quot;。 这一特性得益于Go语言本身的高效性能，使Hugo能够在生成静态站点时迅速完成任务。
作为一个静态站点生成工具，Hugo注重简单易用，为用户提供了快速上手的体验，无需复杂的配置和学习曲线。 其设计理念强调灵活性，用户可以使用自己喜欢的标记语言（如Markdown）和选择喜欢的主题，通过简单的命令轻松构建站点。
Hugo的速度优势使得用户能够在短时间内完成站点的构建，这对那些注重快速迭代和发布的用户来说尤为重要。 此外，Hugo支持多种部署方式，包括各种云服务、托管平台以及自定义服务器，为用户提供了广泛的选择和便捷的部署流程。
在Hugo的生态系统中，丰富的主题库为用户提供了多样化的选择，可以根据需求随时更改站点的外观和风格。 这使得Hugo成为从个人博客到企业官方网站等各种项目的理想选择。
Hugo作为一款强大而高效的静态站点生成工具，不仅充分利用了Go语言的性能优势，而且通过其简单易用、灵活性和快速构建的特点，在数字化时代的静态站点开发中取得了显著的成功。
Hugo的快速构建和简单易用 # Hugo之所以被称为“史上最快”的静态站点生成工具之一，这得益于它独特的快速构建和简单易用的设计理念。 这一特性使得Hugo在用户中广受欢迎，特别是那些追求效率和简便性的开发者。以下是关于Hugo快速构建和简单易用的详细说明：
快速构建：
Go语言的效能： Hugo是用Go语言编写的，而Go以其卓越的性能而著称。 这使得Hugo在静态站点的生成过程中表现出色，具有非常快的构建速度。 Go的并发特性也为Hugo提供了额外的性能优势，使其能够高效地处理大量的内容和页面。
即时重载（LiveReload）： Hugo支持即时重载，也就是在修改内容后，本地服务器能够自动刷新，让开发者能够实时查看他们所做的更改。 这为开发过程带来了实时的预览，提高了开发效率。
简单易用：
低学习曲线： Hugo的设计理念之一是降低用户的学习曲线。 其简洁而直观的命令行接口和目录结构，使得用户能够迅速上手，无需繁琐的配置即可开始构建站点。
标记语言的灵活性： Hugo支持多种标记语言，其中最常用的是Markdown。 这种简单而直观的语法使得用户能够轻松地书写内容，同时在生成的静态页面中保持良好的格式。
丰富的文档和社区支持： Hugo拥有清晰且详尽的官方文档，以及活跃的社区支持。 这些资源为用户提供了解和解决问题的途径，帮助他们更好地利用Hugo构建自己的静态站点。
Hugo的快速构建和简单易用的特性，使得用户能够在短时间内高效地构建和部署静态站点，同时降低了使用门槛，让更多的开发者能够享受到构建高性能站点的乐趣。</description></item><item><title>1.3 安装Hugo</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/install/</guid><description>1.3 安装Hugo # 在Mac上安装Hugo非常简单，你可以按照以下步骤进行：
使用 Homebrew 安装（推荐） # 打开终端： 打开你的终端应用程序。
安装 Homebrew（如果未安装）： 如果你还没有安装Homebrew，可以在终端中运行以下命令进行安装：
/bin/bash -c &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&amp;#34; 上述命令会下载并运行Homebrew的安装脚本。
使用 Homebrew 安装 Hugo： 在终端中运行以下命令安装Hugo：
brew install hugo 验证安装： 安装完成后，可以验证Hugo是否成功安装，运行以下命令检查版本：
hugo version 使用官方二进制文件安装 # 访问 Hugo GitHub Release 页面： 打开 Hugo GitHub Release页面，找到最新版本的Hugo。
下载二进制文件： 在Assets栏下找到适用于macOS的二进制文件（通常以.tar.gz为扩展名），点击下载。
解压缩文件： 下载完成后，使用终端进入下载目录，解压缩文件，例如：
tar -xzvf hugo_extended_0.XX.X_macOS-64bit.tar.gz 请将上述命令中的0.XX.X替换为下载的Hugo版本号。
移动二进制文件： 将解压后的hugo二进制文件移动到一个你喜欢的目录，例如 /usr/local/bin/：
mv hugo /usr/local/bin/ 验证安装： 在终端中运行以下命令验证Hugo是否成功安装：
hugo version 升级Hugo到最新版本 # 打开终端： 打开你的终端应用程序。
更新 Homebrew： 在终端中运行以下命令，确保你的 Homebrew 是最新的：</description></item><item><title>1.4 创建Hugo站点</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/site/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/site/</guid><description>1.4 创建第一个Hugo站 # 确保 Hugo 已经安装在你的系统上。 开始创建站点：
步骤 1：创建新站点 # 在终端中，使用以下命令创建一个新的 Hugo 站点：
hugo new site myfirstsite 这将在当前目录下创建一个名为 myfirstsite 的新 Hugo 站点。
步骤 2：添加内容 # 进入新创建的站点目录：
cd myfirstsite 然后，添加一篇文章：
hugo new posts/my-first-post.md 这将在 content/posts/ 目录下创建一个名为 my-first-post.md 的 Markdown 文件。
步骤 3：编辑内容 # 使用你喜欢的文本编辑器打开 content/posts/my-first-post.md 文件，并编辑文章内容。你可以使用 Markdown 格式书写文章。
--- title: &amp;#34;我的第一篇文章&amp;#34; date: 2023-11-13T10:00:00+00:00 draft: false --- # 欢迎来到我的第一篇文章 这是我使用 Hugo 创建的第一篇文章。希望你喜欢！ 步骤 4：运行本地服务器 # 在站点根目录下运行以下命令，启动 Hugo 的本地服务器：
hugo server -D 这将启动一个本地服务器，允许你在浏览器中查看你的站点。访问 http://localhost:1313/ 即可查看。</description></item><item><title>1.5 自定义主题</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/theme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/theme/</guid><description>1.5 自定义主题 # Hugo 主题是用于定义和控制静态站点外观和样式的集合。 主题包含了站点的布局、样式表、脚本等，让用户能够轻松地改变站点的外观，而不必重新创建整个站点。 以下是有关 Hugo 主题的概念以及如何使用现有主题的详细介绍：
Hugo 主题的概念： # 布局和结构： 主题定义了站点的整体布局和结构。这包括首页、文章页面、标签页面等。通过主题，用户可以规定站点的整体框架，使其符合特定的设计风格。
样式和设计元素： 主题包含了站点的样式表（CSS）和设计元素。这涉及字体、颜色、按钮样式等，为站点提供了一致的外观。
部件和小组件： 主题可以包含一些小组件，如页脚、导航栏、社交媒体图标等。这些部件可以轻松添加到站点，提供额外的功能和导航。
定制功能： 一些主题提供了特定的定制功能，例如滑动图片展示、标签云、评论系统等。这使得用户可以轻松添加这些功能而无需手动编写代码。
如何使用现有主题： # 查找主题： 首先，在 Hugo Themes等主题库中查找和选择一个符合你需求的主题。选择一个主题时，可以预览其外观和功能，以确保它符合你的期望。
下载主题： 从主题库或作者的 GitHub 页面下载主题。通常，主题以压缩文件（通常是.zip或.tar.gz）的形式提供。
解压主题文件： 将下载的主题压缩文件解压到你的 Hugo 站点目录的 themes/ 目录下。你应该得到一个名为主题名称的文件夹。
配置站点使用主题： 打开站点的配置文件（一般是 config.toml 或 config.yaml），并在其中添加或修改 theme 字段，将其设置为主题的名称。
theme = &amp;#34;主题名称&amp;#34; 如果配置文件中没有 theme 字段，可以在文件顶部添加。
启动本地服务器： 在终端中运行以下命令启动 Hugo 的本地服务器，并查看应用了新主题的站点：
hugo server -D 访问 http://localhost:1313/ 查看站点预览。
自定义配置： 大多数主题提供了配置文件，你可以根据自己的需求调整主题配置。这包括修改颜色、更改字体、启用/禁用特定功能等。
添加内容： 继续使用 Hugo 的命令添加内容，如文章、页面等。主题将根据其结构和样式来呈现这些内容。
通过以上步骤，你就成功地使用了一个现有的 Hugo 主题，并为站点应用了新的外观。根据你的需求，你可以随时更换主题或调整主题的配置，以满足不同的设计和功能要求。
实例展示 # 好的，让我们以之前创建的名为 myfirstsite 的站点为例，演示如何自定义使用一个主题。</description></item><item><title>1.7 常见问题和资源</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/qa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/qa/</guid><description>1.7 常见问题和资源 # 1. 初学者常见问题及解决方案： # 问题 1：如何创建新的 Hugo 站点？ # 解决方案： 使用命令 hugo new site &amp;lt;site-name&amp;gt; 在终端中创建新站点。详细文档： Create a new site 问题 2：如何添加新的文章？ # 解决方案： 运行 hugo new posts/my-post.md 命令创建新文章。编辑 content/posts/my-post.md 文件添加内容。详细文档： Content Management 问题 3：如何更改站点主题？ # 解决方案： 下载喜欢的主题，将其放入站点的 themes/ 目录，然后在配置文件中设置 theme 字段。详细文档： Themes 问题 4：如何自定义 Hugo 主题？ # 解决方案： 可以根据主题的文档自定义配置文件，修改样式表，添加自定义部件等。详细文档： Customizing a Theme 问题 5：如何在本地预览站点？ # 解决方案： 运行 hugo server -D 启动本地服务器，然后在浏览器中访问 http://localhost:1313/。详细文档： Localhost:1313 问题 6：如何部署 Hugo 站点到 GitHub Pages？ # 解决方案： 将生成的静态文件推送到 GitHub 仓库，然后在 GitHub 设置中启用 GitHub Pages。详细文档： Deploying Hugo on GitHub Pages 2.</description></item><item><title>2.1 DDD简介</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/02/ddd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/02/ddd/</guid><description>DDD简介 # 领域驱动设计（DDD）的历史可以追溯到上世纪90年代，主要由埃里克·埃文斯（Eric Evans）在他的著作《领域驱动设计》（Domain-Driven Design）中首次提出。 在这本书中，埃里克·埃文斯总结了他在开发复杂软件系统时的实践经验，提出了一系列关于建模、设计和实现的概念。
主要历程 # 早期实践： 在软件开发的早期阶段，开发者主要关注技术实现而忽略了对业务领域的深入理解。这导致了一些项目在处理复杂业务问题时的混乱和失败。
埃里克·埃文斯的贡献： 在《领域驱动设计》一书中，埃里克·埃文斯提出了一套方法，强调通过深入理解业务领域来指导软件设计。他引入了许多概念，如聚合、实体、值对象等，以及对领域模型的重要性。
模型驱动设计： DDD 的理念逐渐被广泛接受，许多开发者开始意识到在软件开发中建立和使用良好的领域模型是至关重要的。
领域驱动设计的演进： 随着时间的推移，DDD 不断演变和发展，逐渐形成了一整套完整的方法论，包括战术设计和战略设计等方面。
为什么现在这么火 # 复杂业务需求： 当今的软件系统面临着越来越复杂的业务需求，传统的技术驱动方法在处理这些复杂性方面显得力不从心。DDD 提供了一种更贴近实际业务需求的设计方法。
微服务架构的兴起： 随着微服务架构的兴起，领域驱动设计成为设计微服务的理想选择。微服务的核心是按照业务功能划分服务，而这正是 DDD 所强调的。
开源社区的支持： 开源社区中涌现出许多与领域驱动设计相关的工具和框架，例如 Axon Framework、DDD Community 等，这进一步推动了 DDD 的普及。
敏捷和迭代开发： DDD 支持敏捷和迭代开发的理念，使团队能够更加灵活地应对业务变化，以及更好地应对不断变化的市场需求。
DDD之所以现在变得如此受欢迎，是因为它提供了一种更加有效和实用的方法，能够更好地应对当今复杂、敏捷和快速变化的软件开发环境。
基本概念 # 领域驱动设计，简称DDD，是一种面向复杂软件系统开发的方法论。 它强调将软件系统建模与业务领域的实际问题相结合，以确保开发人员和业务团队之间的共同理解。 DDD 提倡通过深入理解业务领域来构建系统，将业务专业知识融入软件设计和实现的过程中。
在领域驱动设计中，有几个核心概念：
领域模型： 领域模型是对业务领域的抽象，是一种形式化的表示，用于描述系统中涉及的业务概念、规则和流程。领域模型不仅仅是一份文档，还可以在代码中直接体现。
聚合和实体： DDD 强调聚合的概念，即一组相关的对象被看作一个单一的单元。实体是领域模型的核心，通常对应于业务领域中具有唯一标识的事物。
值对象： 值对象是没有唯一标识的对象，它们的相等性基于它们的属性而不是标识。在领域模型中，值对象通常用于表示某些重要概念的属性。
仓储： 仓储是用于访问领域模型的持久化机制，负责将领域对象存储到数据库中并从中检索。
限界上下文： DDD 强调在不同的上下文中使用不同的模型来解决问题。每个上下文都有其自己的限界，即它关注的领域范围。
领域事件： 领域事件是对领域内发生的重要事实的表示。它们可以被用于在不同的上下文之间传递信息。
领域设计 # 在领域驱动设计（DDD）中，还有战略设计和战术设计两个关键的概念，用于指导不同层次的设计决策。
战略设计（Strategic Design） # 定义： 战略设计关注的是在整个系统层面上的设计决策，包括组织领域模型、划分限界上下文（Bounded Context）等。 它涉及的是在宏观层面上的系统架构和整体设计。</description></item><item><title>2.2 DDD应用</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/02/dddplayer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/02/dddplayer/</guid><description>DDD在本书中的应用 # 我们会使用领域驱动设计（DDD）思想贯穿整个源码的解析。 从源码分析开始，借助辅助工具 dddplayer 对Hugo源码进行深入分析。 这会给我们提供代码结构和信息流的详细信息，以确保我们对源码结构有清晰地认识。
再将源码拆解为一个个的功能点，每个功能点代表着系统中的一个特定任务或操作。 这样可以帮助我们了解各个功能点之间的关系和依赖，并动手练习，掌握每一个功能点。 通过动手实现这些功能点，将有助于我们更好地理解源码中的交互和业务逻辑。
接下来，让我们把这些功能点关联起来，一起动手实现一个小巧的静态站点生成服务。 我们将运用领域驱动设计的思维方式，将这些功能点按DDD概念有机的融合在一起，形成一个完整的服务 - Hugoverse（书中例子的名字）。
在这个过程中，我们会使用战略图和战术图来一步步可视化我们实现的系统。 战略图用于指导整个系统的组织结构和限界，而战术图则更关注限界内部的微观设计决策。
我们会应用六边型项目结构，确保项目组织符合DDD的原则。 这包括清晰的限界上下文、领域模型的定义、实体和值对象的划分、以及聚合的设计等。 通过这一步步的构建，我们致力于打造一个能够更好地反映业务需求和更易于维护的系统。
这个过程将源码解析、功能点拆解、DDD思维、战略图和战术图等结合在一起。 以确保我们在开发过程中更加注重业务需求，建立起一个有机、清晰且符合DDD原则的软件系统。 这种方法有助于我们对系统的整体理解，同时确保代码的可维护性和灵活性。
辅助工具DDDPlayer简介 # DDDPlayer是一款战略和战术治理工具，通过源码分析实时生成战略图和战术图，帮助团队保持业务和代码的一致性。
分析源码组成结构 # 可以用来分析Golang源码，帮助我们深入理解源码组成和结构。
比如我们想了解github.com/gohugoio/hugo/config/allconfig模块下结构体之间的关联关系： DDDPlayer可以帮我们生成如结构图： 可 线上查看细节。
分析源码组信息流 # 还可以分析模块间的调用关系。
如果我们想了解allconfig模块是怎么被外部调用的，我们还可以用DDDPlayer帮助我们生成信息流图： 可 线上查看细节
生成DDD战略图 # Clean Markdown是用DDD实现的一个样例项目。
我们可以用DDDPlayer帮助我们生成战略图： 生成DDD战术图 # 还可以帮我们生成战术图： 有了DDDPlayer后，将大大方便我们理解源码，以及用DDD的方式实现我们的领域服务。</description></item><item><title>3.1 源码阅读步骤</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/read/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/read/</guid><description> 源码阅读步骤介绍 # 工欲善其事，必先利其器。
为了更好地享受源码阅读的过程，我们需要做一些准备工作。
在开始阅读源码前，先了解一下Hugo的架构设计，这样会提供给我们一个全局视野。 这会在我们的脑海里创建一个完整的模块拼图，为接下来的深入了解模块做好引导准备。
了解完基础架构和针对每个模块细节练习后，我们就可以在DDD的帮助下，梳理出领域知识，为我们创造自己的领域服务做好准备了。
下面是源码阅读具体步骤：
搭建好Hugo项目本地开发环境 安装辅助工具DDDPlayer（如果想要亲自己试一试，强烈推荐） 理解Hugo架构设计，方便后继深入理解主流程上的每一个关键组件 对关键组件的逐个击破，并动手实践每个模块后的小练习（有附样例源码） 应用DDD，我们自己动手，应用上面练习过程中的知识，从头开始实现一个精简版的Hugo，我们把这个项目先取名为Hugoverse。</description></item><item><title>3.2 Hugo环境搭建</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/prerequisite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/prerequisite/</guid><description>Hugo本地环境搭建 # 搭建 Hugo 源码的阅读环境步骤：
1. 安装 Git # 首先，确保你的机器上安装了 Git。 你可以从 Git 官方网站下载并安装。
2. 安装 Go # Hugo 是使用 Go 语言编写的，因此你需要安装 Go。 你可以从 Go 官方网站下载并安装。
示例：
➜ go version go version go1.21.1 darwin/amd64 3. 获取 Hugo 源码 # 在终端中运行以下命令，获取 Hugo 的源代码：
git clone git@github.com:gohugoio/hugo.git 4. 进入 Hugo 源码目录 # cd path/to/gohugoio/hugo 5. 构建 Hugo # 在源码目录中运行以下命令，构建 Hugo：
go install 6. 验证环境 # go build -o hugo ./hugo version 如果一切正常，你应该看到 Hugo 的版本信息。</description></item><item><title>3.3 安装DDDPlayer</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/dddplayer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/dddplayer/</guid><description> 安装DDDPlayer # 从源码安装：
go install github.com/dddplayer/dp@latest 示例：
➜ ~/go/bin/dp version dddplayer v0.4.0 darwin/amd64 BuildDate=unknown</description></item><item><title>3.4 Hugo的架构设计</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/arch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/arch/</guid><description>Hugo的架构设计 # 本节的目标就是打开藏宝图来了解Hugo的基础架构，主要从以下两个方向展开：
对架构思路做一个概要说明，对基础架构有一个全貌的理解 从模块代码入手，讨论配置和语言的关系、Hugo的模块、文件系统的组织、站点内容的收集方案、模板的生命周期，以及发布的流程。 通过阅读本章内容，我们将会对Hugo这个站点构建工具有一个全面的认识，并对各阶段之间的关系有一个清晰地认识，为接下来详细源码实现讲解章节打好基础。
出发吧，伟大的工程师啊！
架构设计图 # Hugo的主营业务就是构建静态站点。 那从代码架构层面，是如何体现出来Hugo的构建思路的呢？
站点构建就是将写好的内容，转化成Web服务器能理解的网站资源。 比如我们写作的时候用的是Markdown格式，生成的网站资源通常是HTML格式。
Golang Template 工作原理 # 从主流程可以看出，Hugo的渲染思路并不复杂，就是用模板(Layouts)，将不同的内容(Content)渲染成网站静态资源(Site)。
而实现这一设计的核心技术就是Golang Template。
通过Markdown解析器将post.md解析成结构体Post 通过GoLang Template包根据index.html创建模板实例 执行并生成渲染后的最终结果 记住这个根本原理，这将帮助我们探索Hugo架构的奥秘。
从 Hugo本地环境搭建的样例项目中，我们可以看到Hugo是根据配置文件信息进行构建的，那我们可以先了解一下Hugo源码里的配置模块。
了解 config 模块信息 # ➜ hugo git:(master) ✗ tree -L 1 -d . ├── bufferpool ├── cache ├── codegen ├── commands ├── common ├── compare ├── config ├── create ├── dddplayer ├── deploy ├── deps ├── docs ├── docshelper ├── helpers ├── htesting ├── hugofs ├── hugolib ├── identity ├── langs ├── lazy ├── livereload ├── main ├── markup ├── media ├── metrics ├── minifiers ├── modules ├── navigation ├── output ├── parser ├── public ├── publisher ├── related ├── releaser ├── resources ├── scripts ├── snap ├── source ├── testscripts ├── tpl ├── transform └── watcher 43 directories 通过tree命令，很方便我们查找目录结构，很快就定位到了config目录。</description></item><item><title>3.5.2.1 PathSpec</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/deps/pathSpec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/deps/pathSpec/</guid><description>PathSpec # 我们一个个来看，先看PathSpec。 通过Hugo架构设计中介绍的 文件系统的组织我们了解到，PathSepc正是文件系统的关键所在。
NewPathSpec时序图 # 从上图可以看出，Hugo为自己量身打造的文件系统，庞大且复杂。 光文件系统就有很多种，仅上面提到的就有BasePathFs，BaseFs，baseFileDecoratorFs，OverlayFs，RootMappingFs，SliceFs, LanguageFs。 可以说琳琅满目，数不胜数。 在感叹的同时，也不禁惊心，学习曲线这么陡，可要怎么学！？
为了不把深入理解Hugo系列写成从入门到放弃系列，让我们先静下心来，发挥一下跬步千里的精神。 陡坡再陡，一天走一步，也总有到头的时候。
通过观察，我们发现无论Hugo如何组织这些文件系统，目标实际上只有一个，那就是在使用的时候，简单直接，将复杂的需求封装在内部。 那说一千，道一万，还是个文件系统。
所以首先我们要弄清楚什么是文件系统，以及Hugo是怎么使用文件系统的。 这么多文件系统之间又是个什么样的关系？
从最开始准备的Path，我们看到除了一些常见的信息，如基础Fs，配置信息Cfg，主题目录，工作目录还有发布目录外，还包含了所有模块的信息AllModules。 模块和文件系统又是什么样的关系？ 接着我们发现在真正构建文件系统的时候，sourceFilesystemBuilder首先做的事情就是创建OverlayFs，为什么这里用到了OverlayFs，要帮助Hugo解决什么样的问题？ 在创建OverlayFs的过程中，还用到了Radix Tree基数树数据结构，基数树是什么，又为什么要用？
通过以上这些疑问，我们可以把这个陡坡分拆成一个个的小坡：
什么是文件系统，Hugo是怎么理解的？ 多个文件系统之间是如何关联的？ Modules和文件系统之间，又存在什么样的关系？ 什么是OverlayFs，为什么要用？ 什么是radix tree? 先弄清楚这些问题，再让我们回过头来查看源码。
出发吧，伟大的软件工程师啊！
什么是文件系统，Hugo是怎么理解的？ # 管理人力的，我们叫人力系统；管理招聘的，我们叫招聘系统；那管理文件的，我们就叫文件系统。
在Hugo架构设计 文件系统的组织中，我们有提到Hugo的文件系统是基于Afero库来构建的。
那我们先来看看Afero是怎么定义文件系统的： 通过Hugo对文件系统的实际应用，我们可以发现主要用到了Afero中的两个接口，一个是Fs，另一个是Lstater。 前面一个就是文件系统了，包含打开文件，查询状态等文件相关的操作。 后面的状态机Lstater则在查询状态的后面加上了如果可能的字样，增强了适用性。
那Afero在PathSpec中是怎么得到应用的呢？ 我们知道在创建依赖Deps之初，有将文件信息传入依赖配置项depsCfg中，这里是最原始的文件信息，虽然叫Fs，但并没有提供文件系统的功能。 真正开始组织和构建文件系统的是中间的BaseFs，不仅关联上初始的信息，还包含了文件系统收集完成后的SourceFilesystems。 里面的源文件系统SourceFilesystem都完整的实现了Afero中的Fs和Lstater接口。
这里举一个实际的应用场景，来帮助理解： readAndProcessContent就是用来读取和处理站点内容的函数，将会在下一个章节渲染中进行介绍。 在这里，我们将用这个具体的场景，来帮助我们理解上面的文件系统BaseFs究竟是在为什么做准备。
从上图可以看到，如果我们要开始处理站点内容了。 我们可以通过站点site实例，很容易的得到站点内容的文件系统。 而这个真实的文件系统，正是来自于BaseFs中的Content.Fs。
拿到内容文件系统后，就可以创建好Walkway实例，并对其中的文件进行遍历Walk了。
site又是怎么持有BaseFs的？ 这个不是在PathSpec中吗？
这里就要提到Golang的组合机制了，可以用组合的方式，对结构体进行拓展： 可以清晰地看到他们之间的关系就是Site -&amp;gt; Deps -&amp;gt; PathSpec -&amp;gt; BaseFs，就是有点长，容易迷失方向。
在Walk的过程中，主要用到的就是Lstater中的LstatIfPossible方法。
多个文件系统之间是如何关联的？ # 我们通过一个实际应用场景，了解到为什么要这样组织文件系统。
从Hugo架构设计 文件系统的文件系统章节了解到了Hugo中复杂的文件系统：
虽然这张图能够从基础架构的角度出发，帮我们了解到文件系统是如何组织在一起的。 看起来有些复杂，但仍没能展示所有的文件系统之间的关联。 比如说，在BaseSpec中的SourceFilesystems里面，SourceFilesystem中的Fs究竟指的是哪些文件系统，和OverlayFs又有什么关联呢？</description></item><item><title>3.5.2.2 ContentSpec</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/deps/contentSpec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/deps/contentSpec/</guid><description>ContentSpec # 从基础架构中提到的Template vs Layouts章节，我们了解到Layouts是Template的重要组成部分。 Template将站点样式和内容分离，我们只需要提供内容就可以。
这里就会出现一个疑问：在写作的时候，我们用的明明是Markdown语法，并不是HTML超文本，而Template接收的内容格式是HTML。 那是在什么时候，由谁将Markdown转换成HTML的呢？
这就要聊到咱们Deps中的另一个依赖ContentSpec了。
ContentSpec时序图 # 先通过新建时序图，来看看ContentSpec是如何进行组织和构建的。
我们先看创建和返回，新建ContentSpec的时候，首先调用的是markup.NewConverterProvider，由此返回的也是converterRegistry。 由此可见，ContentSpec实际上是ConverterProvider - 转换器提供方，实例就是converterRegistry - 转换器注册处。 也就是说，Hugo采用的是注册制，可能会有多个转换器注册在注册处，可根据请求的类型，返回相应的转换器，正是让专业的人干专业的事。
那我们接着来看看Hugo是如何设计这个转换器注册处的。
通过中间栏可以看到，Hugo先解析相关的配置项，可以了解到用户的定制化需求和默认的配置信息，如这么多markdown的开源工具，我们默认用哪一个。 再创建一些通用的工具，如高亮组件，可以用来满足用户的高亮需求。 做好了上述的准备工作后，注册处就可以开始营业了，提供的服务当然就是注册Markdown提供方了，在我这注册后，有活的时候，就可以分派给你了。 上图示例中的提供方就是goldmark.Provider，goldmark下是现在Hugo采用的默认markdown解析器。
在注册处里，并没有直接提供goldmark实例，而是提供了标准的converter.Provider，在这里面，包含了由goldmark.New提供的goldmark实例。 就像注册到滴滴平台的网约车，要求能够提供符合滴滴标准的车辆服务。
注册处为了方便查找服务提供方，还给这些提供方取了别名，给goldmark取的别名就是default。 如果没有特殊要求，注册处派出的服务提供方都是goldmark。 在网约车中，相当于滴滴的官方推荐。
注册处，是一个服务提供方。 我在打车的时候，才会打开滴滴的应用。 那在Hugo里，什么时候，会用到转换器注册处呢？
我们接着再来看看具体地使用场景。 如上述时序图所示，正是站点在渲染内容时使用到转换器的实际场景。
这个场景是由render渲染阶段触发的，正是Hugo在构建站点过程中对转换器使用的主要场景。 在上图最右边，我们可以看到，将需要渲染的内容renderContent交给converter进行转换，最终返回转换过后的结果convert.Result。 正是在这里，我们将用户所书写的markdown内容，转换成了我们所需要的HTML内容。
顺带看一下Hugo的渲染思路。 通过时序图的左侧可以看到，这是发生在render的准备阶段，Hugo为所有的Pages精心打扮一番，为渲染做好准备。
从基础架构中介绍的 OutputFormats我们了解到，每个Page页面可以有多个OutputFormats输出格式。 在渲染的过程中，会明确具体要渲染的格式RenderFormats，RenderFormats是对OutputFormats去重后，处理生成的。
为了满足render时的要求，在准备阶段，Hugo为所有的Page，根据OutputFormat，都生成了相应的PageContentOutput。 如上图中间部分所示。
这样，我们的content就为render做好了准备。 合并后的RenderFormats也拥有了符合格式要求的内容信息，再配合Template，就可以生成最终的站点页面了。
这样一来，我们了解了Hugo是如何对注册处进行管理的。 以及转换器提供方要到什么地方，是如何完成注册操作的。 还了解到Hugo是在何时用到转换器的。 这样，从使用场景，到服务提供方，我们对全流程有了清晰的认识。 但还是感觉好像缺了什么似的，没错，那就是这些提供发究竟是如何将Markdown一步步转换成HTML的？
带着这个问题，拿Hugo Markdown默认转换器goldmark为例，我们来一探究竟。 详情请查看Markdown文件是如何被翻译成HTML的章节。
输入Markdown格式内容，输出HTML格式渲染结果 # 想要将Markdown格式的内容，渲染成最终的HTML，需要先从注册处获取转换器，新建实例后，用实例来进行最终渲染。
工欲善其事，必先利其器 - 获取转换器：
在转换器注册处，注册了不同的提供方。 为了方便查找，用名字作为索引。 这样调用方就能通过名字方便地获取能满足诉求的转换器提供方。 需要正式使用的时候，只需要调用New新建方法，就可以得到拥有实际转换功能的转换器。
进入转换环节后。 面对Markdown语法结构的字符流，解析器选择的数据结构是AST语法抽象树，这种结构的优点是树状结可以帮助表达内容Block之间的依赖关系。 不仅如此，树状结构很容易对树结点进行走查。 这样等进入到渲染阶段时，我们就可以专注在具体地渲染事项上，再不用关心结点之间的关联和依赖了。 这样，在调用相应的渲染方法，只需专注在具体地渲染细节上了。 比如在渲染heading的时候只需要关注标题的级别，选用对应的HTML标签就可以了。</description></item><item><title>3.5.3.1 创建</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/site/create/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/site/create/</guid><description>创建站点 - onCreated # Deps新建后，我们就可以应用Deps了。 在新建HugoSites的流程中，可以看到应用Deps的操作发生在onCreated中。
onCreate时序图 # 从左下角可以看出，onCreate主要分为三部分，分别是：
NewDestinationPublisher: 为站点创建publisher initializeSiteInfo：初始化站点信息，将站点所依赖的信息都汇集到一块 newPageCollection：创建页面集合，因为最终渲染是以页面为单位，所以在HugoSites中为每个站点都配备了一个聚集器 NewDestinationPublisher # pub, err := publisher.NewDestinationPublisher( d.ResourceSpec, s.outputFormatsConfig, s.mediaTypesConfig, ) ... s.publisher = pub ResourceSpec来自于Deps，其中包含了全面文件系统信息的PathSpec，和outputFormats, mediaTypesConfig，在我们的例子里，都是默认配置。 而在publisher中，我们不拥有当前site拥有的配置信息 - outputFormatsConfig, mediaTypesConfig。 同时拥有默认信息和定制化信息，这样我们就可以针对当前site进行定制化处理了。
initializeSiteInfo # func (s *Site) initializeSiteInfo() error { // Assemble dependencies to be used in hugo.Deps. s.Info = &amp;amp;SiteInfo{ title: &amp;#34;title&amp;#34;, relativeURLs: s.Cfg.GetBool(&amp;#34;relativeURLs&amp;#34;), owner: s.h, s: s, } return nil } 在我们的例子中对基本信息做了简化，可以看到，这里会对站点所需要的基本信息，像标题等等进行汇总。
newPageCollection # ... pm := &amp;amp;pageMap{ contentMap: newContentMap(), s: s, } s.</description></item><item><title>3.5.3.2 加载资源</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/site/load/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/site/load/</guid><description>LoadResources # 创建HugoSites的最后一步就是LoadResources，没错，不知不觉中，我们已经走到了这一步。
// LoadResources loads translations and templates. func (d *Deps) LoadResources() error { if err := d.templateProvider.Update(d); err != nil { return fmt.Errorf(&amp;#34;loading templates: %w&amp;#34;, err) } return nil } LoadResources也就做了一件事，就是专注在通知templateProvider，可以开始更新了。
我们的templateProvider就是默认的tplimpl.DefaultTemplateProvider。
// Update updates the Hugo Template System in the provided Deps // with all the additional features, templates &amp;amp; functions. func (*TemplateProvider) Update(d *deps.Deps) error { tmpl, err := newTemplateExec(d) if err != nil { return err } return tmpl.</description></item><item><title>3.5.3.3 Markdown</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/site/markdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/site/markdown/</guid><description>Markdown文件是如何被翻译成HTML的 # Markdown是一种文件格式，也是一种约定的语言。 之所以大受欢迎，是因为Markdown其简洁的语法。 不仅让作者在写作的过程中专注在内容创作上，让读者流畅的进行阅读。 还可以将内容直接发布到互联网上，方便传阅，让作品可以轻松的接触到更多的读者。
如果只是为了写作，传统的文本编辑器提供了更强大的样式支持，哪怕是高要求的印刷出版物，一样可以百分百支持。 随着互联网的发展，将文章放到网上已然成了一项基本需求。
而传统的文本编辑器上网的能力似乎不能满足现在的普遍需求。 一是这些强大的编辑器通常出自某一家大公司，并不是行业标准。 种类繁多不说，各家标准也不同，还没有全部公开，这些都让浏览器团队有心无力。
如果说只是要将内容放到网上，那传统的HTML不行吗？ 这就是浏览器钦定的格式啊。 确实如此，HTML是方便了浏览器解析、渲染和展示，但对于写作者来说，并不友好，光标签种类就几十种，更不要提各种不同标签的属性了。
在这种左右两难的背景下，Markdown站了出来。 用简洁的语法替代了相对复杂的HTML，让创作者能更专注在内容创作上。 将标准开放，让大家参与其中，可遵循标准，也可以自定义标准，慢慢的也出现的统一的标准。
Hugo支持的就是Markdown语法，那Hugo是如何将Markdown语法文章翻译成HTML文本的呢？
通过查看最新的Hugo源码，我们发现Hugo将默认的Markdown解析器设置成了Goldmark。
那我们的疑问就变成了：Goldmark是如何将Markdown转换成HTML的呢？
Goldmark工作原理 # 根据 Goldmark的介绍。 Goldmark遵循了 CommonMark 0.30规范。 用AST(Abstract Syntax Tree)结构对内容进行了解析。
要想知道Goldmark的工作原理，得先弄清楚CommonMark和AST这两个知识点。
CommonMark 0.30 # 说到CommonMark规范，大家可能不了解。 但说到GitHub Flavored Markdown，相信大家都有过使用经验，其实GitHub Flavored Markdown就是基于CommonMark规范演化而来的。
细节在 CommonMark Spec 0.30中都有很清楚的描述。 下面我们从领域知识的角度，来进行解读。
让我们从一个例子开始：
A paragraph with two lines. indented code &amp;gt; A block quote. 上面是一段用Markdown语法编写的文本信息，在解析阶段，会被解析成AST，如下图所示：
Goldmark先将文本信息读取到内存，如上图左所示。 那Goldmark是怎么解读这段文本的呢？
对于字符流的处理，有的是按字符一个个进行处理的，如JSON解析。 有的则是按行进行处理的，如配置文件。
通过Commonmark Spec中的 解析策略可以看出，是按行处理的。
那我们上面的文本就会按下面的顺序，以行为单位进行处理：
结合我们的MD写作习惯，让我们回想一下，是不是很多格式需要用换行来辅助说明。 比如段落，我们可以以每个句号为一行，可以换行，只要没有空行，就认为这些句子都是一个段落。 如果想要另起一个段落，直接用空行分隔就行。</description></item><item><title>3.5.4.1 模板</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/build/template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/build/template/</guid><description>Template executor # Deps在准备好NewPathSpec，NewSpec，NewContentSpec，NewSourceSpec后，调用onCreate正式创建HugoSites，并在最后一步，加载模板执行器。
模板执行器只是提前将模板信息转换成了模板执行器，如何使用并没有涉及到。
为了让我们对模板生命周期有更全面的了解，让我们以robots.txt为例，来看看是如何通过模板执行器生成最终文件的。
newTemplateExec时序图 # 从时序图中，可以了解到创建执行器，主要分两步。
先创建包含了各种功能函数的executor。 其中的功能函数由两部分组成，一部分来自hugo，像htmlEscape等。 另一部分来自于golang的内置函数，如fmt.Sprint等等。 正是因为有这些功能函数的支持，才得以让模板的action块 - &amp;lsquo;{{}}&amp;lsquo;功能如此强大。
执行器创建好后，接下来就要创建模板的handler了。 处理器提供了模板加载、查询等相关的服务，以方便使用。 因为查询服务依赖于加载服务，所以在处理器实例后，紧接着就是加载模板了。 而模板又分两部分，一部分是由hugo提供的默认模板，像robot.txt等。 另一部分就是由用户所提供的layouts文件，有来于主题的，也有来于用户自定义的layout。
加载的是磁盘文件，得到的是解析过后的模板实例。
templ, err := prototype.New(info.name).Parse(info.template) 源码里用的是prototype，而不是直接用的html。 这是因为我们的模板有两种后缀，一种是txt，另一种是html，需要找到相应的原型来对模板进行解析。
不管是什么模板，都是文本，HTML也不例外，也是文本。 HTML模板的源码也应证了这一点 - 直接调用文本模板的方法。 那这种关系是如何用代码实现的呢？
拿到模板字节信息后，用词法分析器对模板字节流进行解析，得到分析好的词义结构。 对于HTML模板而言，为了安全，需要对词义结构进行检查和必要地修改。 因为我们可以从不同渠道，获得不同的主题，这些主题中又包含了很多模板，并且主题中可以嵌套主题，为了保证安全，避免执行恶意代码。 最后就是执行解析好的模板。
为了方便理解，我们来举个例子 - robot.txt模板使用流程：
查找：通过名字查找，调用templateExec中的handler查询方法LookupLayout进行查询。 执行：准备执行模板所需要的信息，调用templateExec中的executor执行方法ExecuteWithContext开始执行。 这里的执行方法实际上也是由text template提供的，前面咱们也提到了，不管是什么类型的模板，都是以text为基础的。 知道了工作流程后，让我们从源码层面，更深入的对Template进行理解。
我们先来看第一步： 模板解析。
词法解析 - parse # 创建Deps的最后一步是loadResources，其中主要指的是Template资源。 在创建templateExec实例的过程中，就需要加载hugo默认和用户创建的模板。 加载模板后，获取了模板的字节信息，要想为我们所有，首先要读懂这些字节，这时，我们就用到了解析Parse，而且是由text模板提供的。 Parse为什么可以读懂这些字符信息呢，她依靠的是内部了词法分析器lex - lexer，分析器需要对action block的语义有充分的理解。 读懂后转换为方便后续操作的数据结构tree，在hugo中实际载体是listNode类型。
我们拿一段模板举个例子：
从上例中，我们可以看到，左上方是输入的信息。 包含一篇博客 - post.md，和一个模板 - single.html。 通过转换会得到最右边的输出网页内容。 其中，包含在模板中第一行的信息，剩下的是由博客提供的信息，其中的特殊字符，还被进行了转义。
在左下方第一步中，创建templateExec过程中，读取到了模板single.html。 通过解析，利用词法分析器，会得到如下状态：</description></item><item><title>4.1 Hugoverse</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/04/hugoverse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/04/hugoverse/</guid><description>Hugoverse # Hugoverse是一个静态站点生成领域的开源项目，是为本书所创建。
当我尝试理解Hugo源码时，我不希望了解到的知识都是碎片状的，我更希望以有机的方式将他们全部都结合起来。 因为想完整的掌握静态站点生成这个领域，DDD就成了一个不错的方法。 我也是采用了领域驱动设计（DDD）的方式，来构建了一个被称为&amp;quot;Hugoverse&amp;quot;的项目。 这样一来，理论结合了实际，通过阅读源码，动手实战的方法，将帮助我们迈出成为领域专家过程中至关重要的一步。
对我而言，“show me the code”不仅仅是获取理论知识，更重要的是通过实际编码和动手实践来理解和应用这些概念。 更是软件工程师追崇实干精神的一种具体体现。
Hugoverse不仅是一个概念上的模型，更是一个通过实际代码来呈现和演示Hugo源码核心原理的实体。 通过实践，我将领域驱动设计的理念贯穿到源码中，以一种更贴近实际应用的方式来解释和展示Hugo的工作原理。 这种方式不仅使我们更深入地理解了源码，也使我们能够将这些理念和实践方便地分享给他人，帮助大家更好地理解和运用Hugo源码和静态站点领域技能。
本地安装 Hugoverse # 先根据 Hugoverse Readme在本地准备好环境。
准备好开发环境 # 下载源码
git clone git@github.com:dddplayer/hugoverse.git 安装依赖
go install 构建可执行文件hugov
go build -o hugov 查看命令
➜ hugoverse git:(main) ✗ ./hugov Usage: hugov [command] Commands: build: generate static site for Hugo project server: start the headless CMS server demo: create demo Hugo project version: show hugoverse command version Example: hugov build -p path/to/your/hugo/project 这样，我们就准备好了Hugoverse项目。</description></item><item><title>4.2 样例工程</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/04/demo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/04/demo/</guid><description>Hugo 样例工程 # 在源码精读的 Hugo本地环境搭建环节，我们有搭建一个简单的样例博客。
让我们继续使用这个样例，来打造我们的Hugoverse。
创建Hugo样例项目Demo # 使用我们在上一节准备好的hugoverse命令行工具hugov，来帮助我们创建这个样例项目。
➜ hugoverse git:(main) ✗ ./hugov demo demo dir: /var/folders/rt/bg5xpyj51f98w79j6s80wcr40000gn/T/hugoverse-temp-dir782641825 查看Demo项目结构:
创建成功后，我们会得到一个临时项目路径，让我们用tree命令帮助查看一下文件结构。
➜ hugoverse git:(main) ✗ cd /var/folders/rt/bg5xpyj51f98w79j6s80wcr40000gn/T/hugoverse-temp-dir782641825 ➜ hugoverse-temp-dir782641825 tree . ├── config.toml ├── layouts │ ├── _default │ │ └── single.html │ └── index.html ├── mycontent │ └── blog │ └── post.md ├── myproject.txt └── themes └── mytheme └── mytheme.txt 7 directories, 6 files 可以看到包含了:
配置文件config.toml # ➜ hugoverse-temp-dir782641825 cat config.</description></item><item><title>4.3 DDD配置信息</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/04/config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/04/config/</guid><description>DDD Hugo 配置信息 # 在用DDD来驱动Hugo配置信息开发之前，让我们先来回顾一下 Hugo源码精读 配置中所描述到的主要实现思路。
将配置文件config.toml转换成map:
再将默认配置信息加入其中
收集模块配置信息
通过这些处理后，我们就能准备好完整的配置信息了。
但在静态站点生成领域里，又需要怎么样去组织这些对象，才能让大家协同并高效合作呢？
Hugoverse 加载配置信息源码运行 # 运行以下命令：
➜ hugoverse git:(main) ✗ ./hugov build -p /var/folders/rt/bg5xpyj51f98w79j6s80wcr40000gn/T/hugoverse-temp-dir782641825 --- start to create `mytheme` module --- theme: mytheme === modules: [%!s(*valueobject.moduleAdapter=&amp;amp;{true &amp;lt;nil&amp;gt; [{mycontent content en} {data data } {layouts layouts } {i18n i18n } {archetypes archetypes } {assets assets } {static static }] {[] [{mytheme}]}}) %!s(*valueobject.moduleAdapter=&amp;amp;{false 0xc0000ae360 [] {[] []}})] 上面我们调用了Hugoverse的build命令，指定的Hugo项目就是我们前面生成的 样例项目。 输出的信息也就是样例项目中的配置信息。
从日志中可以看到，我们的样例项目配置的主题是: mytheme。</description></item><item><title>4.3 六边形架构</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/04/hexagon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/04/hexagon/</guid><description>六边形架构 # 六边形架构（Hexagonal Architecture）和领域驱动设计（DDD）是两种软件设计理念，它们可以结合使用以创建可维护、灵活且高效的系统。
六边形架构着重于将系统的关注点分离开来，使得核心业务逻辑与外部环境（例如数据库、UI、外部服务等）解耦。 它将系统划分为内部和外部两个区域，内部区域包含核心业务逻辑，外部区域是与外界交互的接口。这种设计使得系统更易于测试、扩展和维护。
领域驱动设计（DDD）则聚焦于解决复杂业务领域的建模问题。它强调理解和建模业务领域，并将业务需求映射到软件设计中。 DDD提倡通过领域模型来表达业务概念，将软件设计与业务领域紧密结合，从而更好地理解和解决业务问题。
这两种理念可以协同工作。 六边形架构可以作为一种架构风格，帮助将系统按照内部和外部进行划分，而DDD则提供了一种方法来深入理解业务领域，并在系统中建立相应的领域模型。 通过将六边形架构和DDD相结合，可以在系统中建立清晰的业务边界，使得系统更易于扩展、维护和理解，并且更好地满足业务需求。
Hugoverse的目录结构 # ➜ hugoverse git:(main) ✗ tree -L 3 -d . ├── cmd ├── dddplayer ├── internal │ ├── application │ ├── domain │ │ ├── config │ │ ├── deps │ │ ├── fs │ │ ├── hugosites │ │ ├── language │ │ ├── pathspec │ │ ├── site │ │ └── template │ └── interfaces │ ├── api │ └── cmd └── pkg ├── hreflect ├── htime ├── lazy ├── log ├── overlayfs ├── paths ├── radixtree └── types └── hstring 27 directories 结合下图进行理解：</description></item><item><title>4.4 DDD PathSpec</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/04/pathspec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/04/pathspec/</guid><description>DDD PathSpec # 在用DDD来驱动Hugo依赖的PathSpec之前，让我们还是先来回顾一下 Hugo源码精读 PathSpec中所描述到的主要实现思路。
输入初始文件系统，以及模块信息，输出统一文件系统。
这样做的好处是让使用者不用去面对复杂的文件系统组织关系，而是直接使用按Hugo文件系统结构组织好的统一文件系统。
比如layouts：
用户可能会自定义layout，所以在Project模块下有可能有layouts目录。 用户还可能会引用主题，主题里也会有layouts目录。复杂的情况是这个主题可能还会引用其它主题，那我们就还得处理好其它的主题layouts目录。 如果不把这些目录结构都统一设置好，那我们在用layouts里的模板时，就得自己处理这些模板的依赖关系，及覆盖关系。 这些复杂度就会分散在不同的代码里，显然不符合高内聚，低耦合的要求。
所以，Hugo的做法是提前把这些信息都准备好，放在Hugo构建站点的依赖Deps里，以备后续使用之需。
Hugoverse PathSpec 源码运行展示 # Hugoverse PathSpec 信息流 # PathSpec DDD 战略图更新 # PathSpec 内部结构 # PathSpec DDD 战术图更新 # 源码运行结果
pathspec的功能，定位：9.10 采用总分总，从 ddd 战略图查看 pathspec 与 deps 之间的关系 ~/go/bin/dp strategic -m ./ -p github.com/dddplayer/hugoverse pathspec message flow 用来帮助理解源码里的调用逻辑: ~/go/bin/dp normal -m ./ -p github.com/dddplayer/hugoverse/internal/domain/pathspec -mf https://dddplayer.com/?path=https://assets.dddplayer.com/resource/hugov/github.com.dddplayer.hugoverse.internal.domain.pathspec.messageflow.dot pathspec 对象组成 ~/go/bin/dp normal -m ./ -p github.com/dddplayer/hugoverse/internal/domain/pathspec -c https://dddplayer.</description></item><item><title>Config源码分析</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/03/code/config/</guid><description>Config源码解析 # 在 基础架构中，从基础架构的视角出发。 有提到配置模块，以及 配置和语言的关系。
下面我们从源码实现的角度，详细的来看看Hugo是如何设计和实现配置模块的。
Config模块源码 # 从上一节的 allconfig信息流信息流中，我们了解到LoadConfig是配置模块入口:
进一步查看LoadConfig函数，我们发现主要做了三件事：
loadConfig，加载用户项目中的配置文件，如config.toml。 applyConfigDefaults，如果说上面是用户的自定义信息，那这里就是Hugo用到的默认信息。 collectModules，加载完自定义信息和默认信息后，根据得到的模块信息，准备模块，并将解析过后的模块信息，也放入配置信息中。 在本章我们重点看第1步loadConfig，在后续的章节里会有第2步applyConfigDefaults，和第3步collectModules的介绍。
loadConfig时序图 # 从时序图中，我们可以清晰的看到loadConfig被调用的环境。 由主函数发起调用，在hugolib/config.go中先是构建好configLoader，调用loadConfig函数，将config.toml文件转换成Map类型数据。
在loadConfig中，通过函数名可以观察到Hugo的实现思路。 这也说明好的命名是多么的重要。
（温馨提示，在阅读下述流程函数时，可打开 配置源码对照查看。）
FromFileToMap，将目标文件config.toml转换成Map类型的数据。 loadConfigFromFile，为了达到上面的目的，首先要从硬盘加载这个文件。 UnmarshalFileToMap，加载后，需要将字符弃，解组成Map类型的数据。 UnmarshalToMap，解组对应的输出格式要求，可能不一样，这里是要求解组成Map类型，还有可能是其它类型。 FormatFromString，从文件名获取文件格式toml。 UnmarshaTo，通过获取的文件格式信息，以及文件数据信息，和对应的输出格式Map信息，解组总函数，知道该让谁具体负责了。 toml.Unmarshal，所有信息被传送到具体操作员toml，可以外聘，也可以自己实现。Hugo选择了外聘github.com/pelletier/go-toml/v2。 输入配置文件，输出Map格式数据 # 首先了解用户的需求，是将config.toml文件作为输入，要求输出Map类型的数据。 Hugo先是收集信息，包括文件数据data，文件格式toml，和输出类型map[string]any，找到专业的人go-toml，进行处理。 最终得到符合要求的Map信息。
loadConfig动手实践 # 在知道loadConfig的实现原理后，我们再来动动小手，用代码来总结代码，巩固一下知识。
可以这里线上尝试， Show Me the Code, try it yourself
代码里有注解说明，代码样例：
package main import ( &amp;#34;bytes&amp;#34; &amp;#34;fmt&amp;#34; toml &amp;#34;github.com/pelletier/go-toml/v2&amp;#34; &amp;#34;golang.org/x/tools/txtar&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;strings&amp;#34; ) // 文件结构 // 文件名: config.toml // 文件内容：theme = &amp;#39;mytheme&amp;#39; var files = &amp;#34;-- config.</description></item><item><title>GitHub Pages sunwei.xyz</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/sunweixyz/deploy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/sunweixyz/deploy/</guid><description>将站点部署到GitHub Pages # 将 Hugo 站点部署到 GitHub Pages 非常简单，以下是详细的步骤：
步骤 1：创建 GitHub 仓库 # 在 GitHub 上创建一个新的仓库，仓库名为 &amp;lt;你的用户名&amp;gt;.github.io。请确保使用你的 GitHub 用户名替换 &amp;lt;你的用户名&amp;gt;。
在终端中，进入你的 Hugo 站点目录。
初始化 Git 仓库并将其关联到你的 GitHub 仓库：
git init git remote add origin https://github.com/&amp;lt;你的用户名&amp;gt;/&amp;lt;你的用户名&amp;gt;.github.io.git 步骤 2：配置 Hugo # 打开站点的配置文件 config.toml（或 config.yaml 或 config.json，取决于你使用的配置格式）。
添加以下配置，指定基准路径（baseURL）：
baseURL = &amp;#34;https://&amp;lt;你的用户名&amp;gt;.github.io/&amp;#34; 请确保使用你的 GitHub 用户名替换 &amp;lt;你的用户名&amp;gt;。
步骤 3：生成静态站点 # 在终端中运行以下命令，生成静态站点文件：
hugo 这将在站点目录下生成一个 public/ 文件夹，其中包含静态站点的所有文件。
步骤 4：提交代码到 GitHub # 将生成的 public/ 文件夹下的内容提交到 GitHub 仓库：</description></item><item><title>Hugo site sunwei.xyz</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/sunweixyz/site/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/sunweixyz/site/</guid><description>个人站点样例: https://sunwei.xyz # Hugo能很方便的帮助我们构建站点，接下来我们来重放一下我的个人站点是如何构建出来的。
需求 # 将原有的纯HTML站点切换成Hugo站点。
原站点一览：
功能也不复杂，让我们切换到原始版本。 通过git history可以查到提交记录如下： ➜ xyz git:(master) git checkout ef51befc96f398dcfac1b5c04eb4dc7101633012 得到源码如下：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1, shrink-to-fit=no&amp;#34;&amp;gt; &amp;lt;title&amp;gt;sunwei.xyz&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;width: 400px; margin: 20px auto;&amp;#34;&amp;gt; &amp;lt;a href=&amp;#34;/&amp;#34;&amp;gt;中文&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;/en.html&amp;#34;&amp;gt;English&amp;lt;/a&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;孙伟&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;专注企业级端到端解决方案&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;h5&amp;gt; &amp;lt;span&amp;gt;读书笔记&amp;lt;/span&amp;gt; &amp;lt;/h5&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://ent.sunwei.xyz&amp;#34; target=&amp;#34;_blank&amp;#34;&amp;gt; 企业级应用 &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://buildkit.notes.sunwei.xyz/&amp;#34; target=&amp;#34;_blank&amp;#34;&amp;gt; Moby Buildkit 源码读书笔记 &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;h5&amp;gt;&amp;lt;span&amp;gt;工具&amp;lt;/span&amp;gt;&amp;lt;/h5&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://jsoneditoronline.</description></item><item><title>Hugo theme sunwei.xyz</title><link>https://hugo.notes.sunwei.xyz/docs/chapter/01/sunweixyz/theme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/chapter/01/sunweixyz/theme/</guid><description>新建Hugo主题 # Hugo可以创建站点，还可以创建自己的主题。 以站点 sunwe.xyz为例。 让我们将站点中的内容和主题分离，让我们专注在内容创作上。 同时还可以让更多和我们有共同诉求的人，重用我们的主题。
需求分析 # 我们的目标是分离出站点的主题，也就是将content和layouts，及static分离开，并作为主题引入。
所需要的步骤如下：
创建主题仓库 将模板样式从原有站点分离出来 引入主题 实施细节 # 接下来我们一步步的实现以上需求。
创建主题仓库 # 因为站点定位个人品牌，需求并不复杂，以简洁为主。 我们给主题取名zero，寓意起点。
首先创建好空的zero Github仓库，再用Hugo命令生成主题默认目录结构：
➜ zero git:(main) ✗ hugo new theme . Creating theme at /Users/sunwei/github/sunwei/zero/themes ➜ zero git:(main) ✗ ls LICENSE README.md public resources themes 可以看出，Hugo认为我们是在站点里，正在给站点创建主题。 实际上我们需要的是themes里面的内容。 在我们的实例中，其实就theme.toml这一个主题配置文件。 拷贝到我们的仓库根目录下后，更新其中说明内容如下：
name = &amp;#34;Zero&amp;#34; license = &amp;#34;MIT&amp;#34; licenselink = &amp;#34;https://github.com/sunwei/zero/blob/master/LICENSE&amp;#34; description = &amp;#34;Hugo Theme for sunewi.xyz&amp;#34; homepage = &amp;#34;https://sunwei.xyz/&amp;#34; demosite = &amp;#34;https://sunwei.</description></item><item><title>引言</title><link>https://hugo.notes.sunwei.xyz/docs/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/introduction/</guid><description>引言 # 背景和目标 # 欢迎来到《深入Hugo：成为静态站点生成领域专家》。
这本书将带领你深入探索静态站点生成技术，应用领域驱动设计（DDD）原则，从0到1示例如何打造自己的静态站点生成服务。 让你不仅成为一个熟练的开发者，还能有能力创建该领域中的代表作，从而脱颖而出。
本书的写作背景和目标是引导你进入静态站点生成领域，迈出成为领域专家坚实的一步。 阅读Hugo开源项目源码，应用DDD方法，深刻理解和掌握该领域的核心知识，从而能够动手创建该领域的工具或服务。 不仅要探索静态站点生成的内部工作原理，也要关注如何将这些技术应用于不同的业务场景，才能满足不同的市场需求。 融合技术和市场，为客户创造更大的价值。
这本书适合谁 # 本书适用于那些对静态站点生成技术感兴趣的技术从业者和创业者，以及那些希望深入了解如何将技术应用于不同领域的业务场景的读者。 无论你是程序员、技术管理者，还是创业者，或是学生及自学者，本书都将为你提供有价值的知识和见解。
本书适合各种不同背景和经验水平的读者，包括但不限于：
开发者和工程师：如果你是一名开发者，希望深入了解静态站点生成技术以及如何应用DDD原则，这本书将为你提供宝贵的知识和实践机会。 软件架构师：如果你是一名软件架构师，希望提高自己的架构和设计能力，以应用于静态站点生成项目，本书可作为相关的指导和案例研究。 技术管理者：如果你是技术管理者，希望更深入地了解技术和如何将其应用于不同领域的业务，本书将为你提供管理和领导团队的有力工具。 想要进一步提升职业竞争力的人：如果你希望通过学习新的技术和领域知识来提高职业竞争力，这本书将为你提供成为领域专家的机会。 自由职业者：如果你是自由职业者，本书将帮助你扩展你的技能和服务，让更多的客户看到你的专业性，从而增强你的市场竞争力。 创业者：如果你是创业者，希望创建基于静态站点生成技术和DDD原则的创新业务，本书将为你提供创业灵感和实施方法。 学生和自学者：无论你是计算机科学专业的学生还是自学的技术爱好者，这本书将帮助你建立坚实的技术基础，探索新领域，为未来的职业做好准备。 增强个人能力，提高业务成就 # 阅读本书后，新增的业务模式：
咨询服务：提供专业咨询服务，帮助客户解决与你的领域相关的问题和挑战。这可以包括架构设计、技术选型、领域建模等方面的咨询。 培训和教育：开设培训课程或研讨会，分享你的知识和经验，帮助其他人学习并提高他们的技能。 参与开源项目：贡献你的时间和技能到开源项目，将大大丰富你的简历，以提高竞争力。 创业和创新：基于你的领域专业知识，创办新的技术创业公司，开发新的产品或服务。 Hugo定制化开发：为企业创建专业站点，增强网络获客，达成更多交易。创建个人品牌，持续积累自己的影响力，为新的方向做好准备。 不同学习渠道 # 本课程提供多种学习渠道，以满足不同学习需求：
Udemy课程：课程将发布在 Udemy 平台上，供学生在线学习。在 Udemy 上，你将获得视频课程、练习题、课程证书等学习资源。 Leanpub电子书：本课程的电子书将在 Leanpub 上提供，以便你离线阅读和学习。电子书将包含本课程的全部内容，以便你随时翻阅。 Youtube频道：TODO 不同学习渠道将帮助你更灵活地选择适合你的学习方式。无论你是喜欢在线视频课程还是喜欢离线阅读电子书，都可以从本课程中获得所需的知识和技能。</description></item></channel></rss>