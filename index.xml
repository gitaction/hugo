<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首页介绍 on Deep Understanding of Hugo</title><link>https://hugo.notes.sunwei.xyz/</link><description>Recent content in 首页介绍 on Deep Understanding of Hugo</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hugo.notes.sunwei.xyz/index.xml" rel="self" type="application/rss+xml"/><item><title>为什么要读Hugo源码</title><link>https://hugo.notes.sunwei.xyz/posts/creating-a-new-theme/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/posts/creating-a-new-theme/</guid><description>Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>https://hugo.notes.sunwei.xyz/posts/migrate-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/posts/migrate-from-jekyll/</guid><description>Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title>(Hu)go Template Primer</title><link>https://hugo.notes.sunwei.xyz/posts/goisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/posts/goisforlovers/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>https://hugo.notes.sunwei.xyz/posts/hugoisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/posts/hugoisforlovers/</guid><description>Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E5%86%85%E5%AE%B9%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E5%86%85%E5%AE%B9%E8%A7%84%E8%8C%83/</guid><description>ContentSpec # 从基础架构中提到的Template vs Layouts章节，我们了解到Layouts是Template的重要组成部分。 Template将站点样式和内容分离，我们只需要提供内容就可以。
这里就会出现一个疑问：在写作的时候，我们用的明明是Markdown语法，并不是HTML超文本，而Template接收的内容格式是HTML。 那是在什么时候，由谁将Markdown转换成HTML的呢？
这就要聊到咱们Deps中的另一个依赖ContentSpec了。
了然于胸 - ContentSpec时序图 # 先通过新建时序图，来看看ContentSpec是如何进行组织和构建的。
我们先看创建和返回，新建ContentSpec的时候，首先调用的是markup.NewConverterProvider，由此返回的也是converterRegistry。 由此可见，ContentSpec实际上是ConverterProvider - 转换器提供方，实例就是converterRegistry - 转换器注册处。 也就是说，Hugo采用的是注册制，可能会有多个转换器注册在注册处，可根据请求的类型，返回相应的转换器，正是让专业的人干专业的事。
那我们接着来看看Hugo是如何设计这个转换器注册处的。
通过中间栏可以看到，Hugo先解析相关的配置项，可以了解到用户的定制化需求和默认的配置信息，如这么多markdown的开源工具，我们默认用哪一个。 再创建一些通用的工具，如高亮组件，可以用来满足用户的高亮需求。 做好了上述的准备工作后，注册处就可以开始营业了，提供的服务当然就是注册Markdown提供方了，在我这注册后，有活的时候，就可以分派给你了。 上图示例中的提供方就是goldmark.Provider，goldmark下是现在Hugo采用的默认markdown解析器。
在注册处里，并没有直接提供goldmark实例，而是提供了标准的converter.Provider，在这里面，包含了由goldmark.New提供的goldmark实例。 就像注册到滴滴平台的网约车，要求能够提供符合滴滴标准的车辆服务。
注册处为了方便查找服务提供方，还给这些提供方取了别名，给goldmark取的别名就是default。 如果没有特殊要求，注册处派出的服务提供方都是goldmark。 在网约车中，相当于滴滴的官方推荐。
注册处，是一个服务提供方。 我在打车的时候，才会打开滴滴的应用。 那在Hugo里，什么时候，会用到转换器注册处呢？
我们接着再来看看具体地使用场景。 如上述时序图所示，正是站点在渲染内容时使用到转换器的实际场景。
这个场景是由render渲染阶段触发的，正是Hugo在构建站点过程中对转换器使用的主要场景。 在上图最右边，我们可以看到，将需要渲染的内容renderContent交给converter进行转换，最终返回转换过后的结果convert.Result。 正是在这里，我们将用户所书写的markdown内容，转换成了我们所需要的HTML内容。
顺带看一下Hugo的渲染思路。 通过时序图的左侧可以看到，这是发生在render的准备阶段，Hugo为所有的Pages精心打扮一番，为渲染做好准备。
从基础架构中介绍的 OutputFormats我们了解到，每个Page页面可以有多个OutputFormats输出格式。 在渲染的过程中，会明确具体要渲染的格式RenderFormats，RenderFormats是对OutputFormats去重后，处理生成的。
为了满足render时的要求，在准备阶段，Hugo为所有的Page，根据OutputFormat，都生成了相应的PageContentOutput。 如上图中间部分所示。
这样，我们的content就为render做好了准备。 合并后的RenderFormats也拥有了符合格式要求的内容信息，再配合Template，就可以生成最终的站点页面了。
这样一来，我们了解了Hugo是如何对注册处进行管理的。 以及转换器提供方要到什么地方，是如何完成注册操作的。 还了解到Hugo是在何时用到转换器的。 这样，从使用场景，到服务提供方，我们对全流程有了清晰的认识。 但还是感觉好像缺了什么似的，没错，那就是这些提供发究竟是如何将Markdown一步步转换成HTML的？
带着这个问题，拿Hugo Markdown默认转换器goldmark为例，我们来一探究竟。 详情请查看Markdown文件是如何被翻译成HTML的章节。
抽象总结 - 输入Markdown格式内容，输出HTML格式渲染结果 # 想要将Markdown格式的内容，渲染成最终的HTML，需要先从注册处获取转换器，新建实例后，用实例来进行最终渲染。
工欲善其事，必先利其器 - 获取转换器：
在转换器注册处，注册了不同的提供方。 为了方便查找，用名字作为索引。 这样调用方就能通过名字方便地获取能满足诉求的转换器提供方。 需要正式使用的时候，只需要调用New新建方法，就可以得到拥有实际转换功能的转换器。
进入转换环节后。 面对Markdown语法结构的字符流，解析器选择的数据结构是AST语法抽象树，这种结构的优点是树状结可以帮助表达内容Block之间的依赖关系。 不仅如此，树状结构很容易对树结点进行走查。 这样等进入到渲染阶段时，我们就可以专注在具体地渲染事项上，再不用关心结点之间的关联和依赖了。 这样，在调用相应的渲染方法，只需专注在具体地渲染细节上了。 比如在渲染heading的时候只需要关注标题的级别，选用对应的HTML标签就可以了。</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E8%B7%AF%E5%BE%84%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E8%B7%AF%E5%BE%84%E8%A7%84%E8%8C%83/</guid><description>PathSpec # 我们一个个来看，先看PathSpec。 通过基础架构中介绍的 文件系统的组织我们了解到，PathSepc正是文件系统的关键所在。
了然于胸 - NewPathSpec时序图 # 从上图可以看出，Hugo为自己量身打造的文件系统，庞大且复杂。 光文件系统就有很多种，仅上面提到的就有BasePathFs，BaseFs，baseFileDecoratorFs，OverlayFs，RootMappingFs，SliceFs, LanguageFs。 可以说琳琅满目，数不胜数。 在感叹的同时，也不禁惊心，学习曲线这么陡，可要怎么学！？
为了不把深入理解Hugo系列写成从入门到放弃系列，让我们先静下心来，发挥一下跬步千里的精神。 陡坡再陡，一天走一步，也总有到头的时候。
通过观察，我们发现无论Hugo如何组织这些文件系统，目标实际上只有一个，那就是在使用的时候，简单直接，将复杂的需求封装在内部。 那说一千，道一万，还是个文件系统。
所以首先我们要弄清楚什么是文件系统，以及Hugo是怎么使用文件系统的。 这么多文件系统之间又是个什么样的关系？
从最开始准备的Path，我们看到除了一些常见的信息，如基础Fs，配置信息Cfg，主题目录，工作目录还有发布目录外，还包含了所有模块的信息AllModules。 模块和文件系统又是什么样的关系？ 接着我们发现在真正构建文件系统的时候，sourceFilesystemBuilder首先做的事情就是创建OverlayFs，为什么这里用到了OverlayFs，要帮助Hugo解决什么样的问题？ 在创建OverlayFs的过程中，还用到了Radix Tree基数树数据结构，基数树是什么，又为什么要用？
通过以上这些疑问，我们可以把这个陡坡分拆成一个个的小坡：
什么是文件系统，Hugo是怎么理解的？ 多个文件系统之间是如何关联的？ Modules和文件系统之间，又存在什么样的关系？ 什么是OverlayFs，为什么要用？ 什么是radix tree? 先弄清楚这些问题，再让我们回过头来查看源码。
出发吧，伟大的软件工程师啊！
什么是文件系统，Hugo是怎么理解的？ # 管理人力的，我们叫人力系统；管理招聘的，我们叫招聘系统；那管理文件的，我们就叫文件系统。
在基础架构 文件系统的组织中，我们有提到Hugo的文件系统是基于Afero库来构建的。
那我们先来看看Afero是怎么定义文件系统的： 通过Hugo对文件系统的实际应用，我们可以发现主要用到了Afero中的两个接口，一个是Fs，另一个是Lstater。 前面一个就是文件系统了，包含打开文件，查询状态等文件相关的操作。 后面的状态机Lstater则在查询状态的后面加上了如果可能的字样，增强了适用性。
那Afero在PathSpec中是怎么得到应用的呢？ 我们知道在创建依赖Deps之初，有将文件信息传入依赖配置项depsCfg中，这里是最原始的文件信息，虽然叫Fs，但并没有提供文件系统的功能。 真正开始组织和构建文件系统的是中间的BaseFs，不仅关联上初始的信息，还包含了文件系统收集完成后的SourceFilesystems。 里面的源文件系统SourceFilesystem都完整的实现了Afero中的Fs和Lstater接口。
这里举一个实际的应用场景，来帮助理解： readAndProcessContent就是用来读取和处理站点内容的函数，将会在下一个章节渲染中进行介绍。 在这里，我们将用这个具体的场景，来帮助我们理解上面的文件系统BaseFs究竟是在为什么做准备。
从上图可以看到，如果我们要开始处理站点内容了。 我们可以通过站点site实例，很容易的得到站点内容的文件系统。 而这个真实的文件系统，正是来自于BaseFs中的Content.Fs。
拿到内容文件系统后，就可以创建好Walkway实例，并对其中的文件进行遍历Walk了。
site又是怎么持有BaseFs的？ 这个不是在PathSpec中吗？
这里就要提到Golang的组合机制了，可以用组合的方式，对结构体进行拓展： 可以清晰地看到他们之间的关系就是Site -&amp;gt; Deps -&amp;gt; PathSpec -&amp;gt; BaseFs，就是有点长，容易迷失方向。
在Walk的过程中，主要用到的就是Lstater中的LstatIfPossible方法。
多个文件系统之间是如何关联的？ # 我们通过一个实际应用场景，了解到为什么要这样组织文件系统。
从 基础架构的文件系统章节了解到了Hugo中复杂的文件系统： 虽然这张图能够从基础架构的角度出发，帮我们了解到文件系统是如何组织在一起的。 看起来有些复杂，但仍没能展示所有的文件系统之间的关联。 比如说，在BaseSpec中的SourceFilesystems里面，SourceFilesystem中的Fs究竟指的是哪些文件系统，和OverlayFs又有什么关联呢？</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/code/%E6%9E%84%E5%BB%BA/%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/code/%E6%9E%84%E5%BB%BA/%E6%A8%A1%E6%9D%BF/</guid><description>Template executor # Deps在准备好NewPathSpec，NewSpec，NewContentSpec，NewSourceSpec后，调用onCreate正式创建HugoSites，并在最后一步，加载模板执行器。
模板执行器只是提前将模板信息转换成了模板执行器，如何使用并没有涉及到。
为了让我们对模板生命周期有更全面的了解，让我们以robots.txt为例，来看看是如何通过模板执行器生成最终文件的。
了然于胸 - newTemplateExec时序图 # 从时序图中，可以了解到创建执行器，主要分两步。
先创建包含了各种功能函数的executor。 其中的功能函数由两部分组成，一部分来自hugo，像htmlEscape等。 另一部分来自于golang的内置函数，如fmt.Sprint等等。 正是因为有这些功能函数的支持，才得以让模板的action块 - &amp;lsquo;{{}}&amp;lsquo;功能如此强大。
执行器创建好后，接下来就要创建模板的handler了。 处理器提供了模板加载、查询等相关的服务，以方便使用。 因为查询服务依赖于加载服务，所以在处理器实例后，紧接着就是加载模板了。 而模板又分两部分，一部分是由hugo提供的默认模板，像robot.txt等。 另一部分就是由用户所提供的layouts文件，有来于主题的，也有来于用户自定义的layout。
加载的是磁盘文件，得到的是解析过后的模板实例。
templ, err := prototype.New(info.name).Parse(info.template) 源码里用的是prototype，而不是直接用的html。 这是因为我们的模板有两种后缀，一种是txt，另一种是html，需要找到相应的原型来对模板进行解析。
不管是什么模板，都是文本，HTML也不例外，也是文本。 HTML模板的源码也应证了这一点 - 直接调用文本模板的方法。 那这种关系是如何用代码实现的呢？
拿到模板字节信息后，用词法分析器对模板字节流进行解析，得到分析好的词义结构。 对于HTML模板而言，为了安全，需要对词义结构进行检查和必要地修改。 因为我们可以从不同渠道，获得不同的主题，这些主题中又包含了很多模板，并且主题中可以嵌套主题，为了保证安全，避免执行恶意代码。 最后就是执行解析好的模板。
为了方便理解，我们来举个例子 - robot.txt模板使用流程：
查找：通过名字查找，调用templateExec中的handler查询方法LookupLayout进行查询。 执行：准备执行模板所需要的信息，调用templateExec中的executor执行方法ExecuteWithContext开始执行。 这里的执行方法实际上也是由text template提供的，前面咱们也提到了，不管是什么类型的模板，都是以text为基础的。 知道了工作流程后，让我们从源码层面，更深入的对Template进行理解。
我们先来看第一步： 模板解析。
词法解析 - parse # 创建Deps的最后一步是loadResources，其中主要指的是Template资源。 在创建templateExec实例的过程中，就需要加载hugo默认和用户创建的模板。 加载模板后，获取了模板的字节信息，要想为我们所有，首先要读懂这些字节，这时，我们就用到了解析Parse，而且是由text模板提供的。 Parse为什么可以读懂这些字符信息呢，她依靠的是内部了词法分析器lex - lexer，分析器需要对action block的语义有充分的理解。 读懂后转换为方便后续操作的数据结构tree，在hugo中实际载体是listNode类型。
我们拿一段模板举个例子：
从上例中，我们可以看到，左上方是输入的信息。 包含一篇博客 - post.md，和一个模板 - single.html。 通过转换会得到最右边的输出网页内容。 其中，包含在模板中第一行的信息，剩下的是由博客提供的信息，其中的特殊字符，还被进行了转义。</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/code/%E7%AB%99%E7%82%B9/markdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/code/%E7%AB%99%E7%82%B9/markdown/</guid><description>Markdown文件是如何被翻译成HTML的 # Markdown是一种文件格式，也是一种约定的语言。 之所以大受欢迎，是因为Markdown其简洁的语法。 不仅让作者在写作的过程中专注在内容创作上，让读者流畅的进行阅读。 还可以将内容直接发布到互联网上，方便传阅，让作品可以轻松的接触到更多的读者。
如果只是为了写作，传统的文本编辑器提供了更强大的样式支持，哪怕是高要求的印刷出版物，一样可以百分百支持。 随着互联网的发展，将文章放到网上已然成了一项基本需求。
而传统的文本编辑器上网的能力似乎不能满足现在的普遍需求。 一是这些强大的编辑器通常出自某一家大公司，并不是行业标准。 种类繁多不说，各家标准也不同，还没有全部公开，这些都让浏览器团队有心无力。
如果说只是要将内容放到网上，那传统的HTML不行吗？ 这就是浏览器钦定的格式啊。 确实如此，HTML是方便了浏览器解析、渲染和展示，但对于写作者来说，并不友好，光标签种类就几十种，更不要提各种不同标签的属性了。
在这种左右两难的背景下，Markdown站了出来。 用简洁的语法替代了相对复杂的HTML，让创作者能更专注在内容创作上。 将标准开放，让大家参与其中，可遵循标准，也可以自定义标准，慢慢的也出现的统一的标准。
Hugo支持的就是Markdown语法，那Hugo是如何将Markdown语法文章翻译成HTML文本的呢？
通过查看最新的Hugo源码，我们发现Hugo将默认的Markdown解析器设置成了Goldmark。
那我们的疑问就变成了：Goldmark是如何将Markdown转换成HTML的呢？
Goldmark工作原理 # 根据 Goldmark的介绍。 Goldmark遵循了 CommonMark 0.30规范。 用AST(Abstract Syntax Tree)结构对内容进行了解析。
要想知道Goldmark的工作原理，得先弄清楚CommonMark和AST这两个知识点。
CommonMark 0.30 # 说到CommonMark规范，大家可能不了解。 但说到GitHub Flavored Markdown，相信大家都有过使用经验，其实GitHub Flavored Markdown就是基于CommonMark规范演化而来的。
细节在 CommonMark Spec 0.30中都有很清楚的描述。 下面我们从领域知识的角度，来进行解读。
让我们从一个例子开始：
A paragraph with two lines. indented code &amp;gt; A block quote. 上面是一段用Markdown语法编写的文本信息，在解析阶段，会被解析成AST，如下图所示：
Goldmark先将文本信息读取到内存，如上图左所示。 那Goldmark是怎么解读这段文本的呢？
对于字符流的处理，有的是按字符一个个进行处理的，如JSON解析。 有的则是按行进行处理的，如配置文件。
通过Commonmark Spec中的 解析策略可以看出，是按行处理的。
那我们上面的文本就会按下面的顺序，以行为单位进行处理：
结合我们的MD写作习惯，让我们回想一下，是不是很多格式需要用换行来辅助说明。 比如段落，我们可以以每个句号为一行，可以换行，只要没有空行，就认为这些句子都是一个段落。 如果想要另起一个段落，直接用空行分隔就行。</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/code/%E7%AB%99%E7%82%B9/%E5%88%9B%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/code/%E7%AB%99%E7%82%B9/%E5%88%9B%E5%BB%BA/</guid><description>onCreated # Deps新建后，我们就可以应用Deps了。 在新建HugoSites的流程中，可以看到应用Deps的操作发生在onCreated中。
了然于胸 - onCreate时序图 # 从左下角可以看出，onCreate主要分为三部分，分别是：
NewDestinationPublisher: 为站点创建publisher initializeSiteInfo：初始化站点信息，将站点所依赖的信息都汇集到一块 newPageCollection：创建页面集合，因为最终渲染是以页面为单位，所以在HugoSites中为每个站点都配备了一个聚集器 NewDestinationPublisher # pub, err := publisher.NewDestinationPublisher( d.ResourceSpec, s.outputFormatsConfig, s.mediaTypesConfig, ) ... s.publisher = pub ResourceSpec来自于Deps，其中包含了全面文件系统信息的PathSpec，和outputFormats, mediaTypesConfig，在我们的例子里，都是默认配置。 而在publisher中，我们不拥有当前site拥有的配置信息 - outputFormatsConfig, mediaTypesConfig。 同时拥有默认信息和定制化信息，这样我们就可以针对当前site进行定制化处理了。
initializeSiteInfo # func (s *Site) initializeSiteInfo() error { // Assemble dependencies to be used in hugo.Deps. s.Info = &amp;amp;SiteInfo{ title: &amp;#34;title&amp;#34;, relativeURLs: s.Cfg.GetBool(&amp;#34;relativeURLs&amp;#34;), owner: s.h, s: s, } return nil } 在我们的例子中对基本信息做了简化，可以看到，这里会对站点所需要的基本信息，像标题等等进行汇总。
newPageCollection # ... pm := &amp;amp;pageMap{ contentMap: newContentMap(), s: s, } s.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/code/%E7%AB%99%E7%82%B9/%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/code/%E7%AB%99%E7%82%B9/%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/</guid><description>LoadResources # 创建HugoSites的最后一步就是LoadResources，没错，不知不觉中，我们已经走到了这一步。
// LoadResources loads translations and templates. func (d *Deps) LoadResources() error { if err := d.templateProvider.Update(d); err != nil { return fmt.Errorf(&amp;#34;loading templates: %w&amp;#34;, err) } return nil } LoadResources也就做了一件事，就是专注在通知templateProvider，可以开始更新了。
我们的templateProvider就是默认的tplimpl.DefaultTemplateProvider。
// Update updates the Hugo Template System in the provided Deps // with all the additional features, templates &amp;amp; functions. func (*TemplateProvider) Update(d *deps.Deps) error { tmpl, err := newTemplateExec(d) if err != nil { return err } return tmpl.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/code/%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/code/%E9%85%8D%E7%BD%AE/</guid><description>Config源码分析 # 在 基础架构中，从基础架构的视角出发。 有提到配置模块，以及 配置和语言的关系。
下面我们从源码实现的角度，详细的来看看Hugo是如何设计和实现配置模块的。
跬步千里 - Config模块源码 # 将 游乐场源码， 切换到 01-config分支：
➜ hugo-playground git:(main) git checkout 01-config Switched to branch &amp;#39;01-config&amp;#39; Your branch is up to date with &amp;#39;origin/01-config&amp;#39;. ➜ hugo-playground git:(01-config) 通过将源码按配置模块进行裁剪，Config模块在我们面前也变得清晰，让我们在Hugo源码学习的道路上迈出了自信的一步。 通过命令行，我们可以看看具体的目录结构：
➜ hugo-playground git:(01-config) tree . ├── LICENSE ├── README.md ├── command.sh ├── common │ ├── maps │ │ ├── maps.go │ │ └── params.go │ └── paths │ └── path.go ├── config │ ├── commonConfig.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/how/%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/how/%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4/</guid><description>Hugo 事件风暴 # Hugo的功能很全面，拥有强大的自定义函数库，可以用来制作模板、短代码等。 这在站点的构建过程中，可以帮助提供各种数据，如获取目录结构，主动加载文件。 以及页面信息汇总，方便展示分页列表或者搜索。 还可以帮助分类，提供标签服务。
支持多语言，创建国际化站点一样简单。
主题库更是能满足各种不同的个性化需求，更贴近专业使用场景，你还可以零成本切换。
Hugo是如何一步步将博客变成站点的？ 下面我们还是通过 游乐场实例，来一探究竟。
邀你一起来动手。 用我们最喜欢的IDE，打开我们的 游乐场项目源码。 通过直接输出日志的方式，来看一看hugo的完整构建流程。
$ cd /go/to/hugo-playground $ go run . 先来看一看主流程。 通过搜索以字符串&amp;quot;==&amp;gt; Process main:&amp;ldquo;开头的日志条目，我们可以了清楚的看到主函数的处理流程如下所示：
==&amp;gt; Process main: prepare example project file systems ==&amp;gt; Process main: load configurations from config.toml and themes ==&amp;gt; Process main: setup hugo file systems based on machine file system and configurations ==&amp;gt; Process main: create hugo sites based on deps ==&amp;gt; Process main: hugo building.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/how/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/how/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</guid><description>Hugo基础架构 # 通过 个人站点和 自定义主题实例，我们可以了解到如何使用Hugo创建自己的站点以及主题。 使用起来很简单，很快就能上手。
同时Hugo还是基于Apache 2.0协议的开源项目，这意味着你完全可以大胆地发挥自己的创造力。
比如针对源码领域的站点，像 深入理解Hugo，将源码和注解分离，并可以在 Golang Play上执行。 让源码的学习体验更加立体，不仅有解释，还能参与其中，修改样例，进一步帮助理解。
目前Hugo还无法支持构建这样的站点，主要有两个原因。 一是 内容格式，Hugo目前主要支持的内容格式是Markdown，而上面的内容格式是.go源码文件。 其次是 功能函数，Hugo并没有处理代码的函数可以直接使用，要想解析源码及注解。 虽然可以组合字符串函数进行处理，但使用起来繁琐，拓展起来困难，维护起来更是让人连连摇头。
不过，源码都给我们了，还能要求更多吗？ 毕竟我们可是有追求的软件工程师啊！
无论是从实用的角度，还是通过学习优秀源码，来进行交流学习的角度，我们都有充分的理由来对这一宝藏进行发掘。
本章的目标就是打开藏宝图来了解Hugo的基础架构，主要从以下两个方向展开：
对架构思路做一个概要说明，对基础架构有一个全貌的理解 从模块代码入手，讨论配置和语言的关系、Hugo的模块、文件系统的组织、站点内容的收集方案、模板的生命周期，以及发布的流程。 通过阅读本章内容，我们将会对Hugo这个站点构建工具有一个全面的认识，并对各阶段之间的关系有一个清晰的认识，为接下来详细源码实现讲解章节打好基础。
出发吧，伟大的工程师啊！
Hugo的架构设计 # 结合Hugo站点构建领域 事件，和 Hugo游乐场源码，Hugo的架构设计会变得很清晰：
Hugo的架构思路很容易理解，主要分三大块，分别是配置模块，站点模块和依赖模块。
配置模块
Hugo最先解析的，就是用户项目的配置文件config.toml。 由configLoader发起，从硬盘读取配置文件，解析后存储为键值对对象。 configLoader主要需完成三件事，加载用户项目配置文件是第一件，用来理解用户的自定义需求。 第二件是补全默认配置Defaults Config，这样才能保其它模块正常运作。 第三件是生成模块配置信息，从用户项目开始，将用户项目作为第一个模块 - project module，在我们的实例中还有第二个模块，那就是主题模块mytheme。 模块之间有依赖关系，并且只有一个所有者Owner。 项目模块project module比较特殊，因为是初始模块，所以不属于任何其它模块。
type Module interface { ... // Owner In the dependency tree, this is the first // module that defines this module as a dependency.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/how/%E6%B8%B8%E4%B9%90%E5%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/how/%E6%B8%B8%E4%B9%90%E5%9C%BA/</guid><description>Hugo 游乐场 # 使用Hugo构建站点的体验很棒。 首先是构建速度快，其次是使用起来简单，一个hugo命令，我们的站点就已经就绪。
在构建过程中，Hugo提供了丰富的内置功能函数，可以在构建过程中向你提供所需要的几乎任何站点相关的信息。 通过可重用模板，让主题来帮助处理所有展示和布局相关的问题。 让作者更专注在内容的创作上。
游乐场 # 站点构建的就将写好的内容，转化成Web服务器能理解的网站资源。 比如我们写作的时候用的是Markdown格式，生成的网站资源通常是HTML格式。
下面是一个简单的初始化博客内容：
-- config.toml -- theme = &amp;#34;mytheme&amp;#34; contentDir = &amp;#34;mycontent&amp;#34; -- myproject.txt -- Hello project! -- themes/mytheme/mytheme.txt -- Hello theme! -- mycontent/blog/post.md -- --- title: &amp;#34;Post Title&amp;#34; --- ### first blog Hello Blog -- layouts/index.html -- {{ $entries := (readDir &amp;#34;.&amp;#34;) }} START:|{{ range $entry := $entries }}{{ if not $entry.IsDir }}{{ $entry.Name }}|{{ end }}{{ end }}:END: -- layouts/_default/single.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/what/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/what/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/</guid><description>个人站点样例: https://sunwei.xyz # Hugo能很方便的帮助我们构建站点，接下来我们来重放一下我的个人站点是如何构建出来的。
需求 # 将原有的纯HTML站点切换成Hugo站点。
原站点一览：
功能也不复杂，让我们切换到原始版本。 通过git history可以查到提交记录如下： ➜ xyz git:(master) git checkout ef51befc96f398dcfac1b5c04eb4dc7101633012 得到源码如下：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1, shrink-to-fit=no&amp;#34;&amp;gt; &amp;lt;title&amp;gt;sunwei.xyz&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;width: 400px; margin: 20px auto;&amp;#34;&amp;gt; &amp;lt;a href=&amp;#34;/&amp;#34;&amp;gt;中文&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;/en.html&amp;#34;&amp;gt;English&amp;lt;/a&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;孙伟&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;专注企业级端到端解决方案&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;h5&amp;gt; &amp;lt;span&amp;gt;读书笔记&amp;lt;/span&amp;gt; &amp;lt;/h5&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://ent.sunwei.xyz&amp;#34; target=&amp;#34;_blank&amp;#34;&amp;gt; 企业级应用 &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://buildkit.notes.sunwei.xyz/&amp;#34; target=&amp;#34;_blank&amp;#34;&amp;gt; Moby Buildkit 源码读书笔记 &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;h5&amp;gt;&amp;lt;span&amp;gt;工具&amp;lt;/span&amp;gt;&amp;lt;/h5&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;https://jsoneditoronline.</description></item><item><title/><link>https://hugo.notes.sunwei.xyz/docs/what/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hugo.notes.sunwei.xyz/docs/what/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98/</guid><description>自定义Hugo主题 # Hugo可以创建站点，还可以创建自己的主题。 以站点 sunwe.xyz为例。 让我们将站点中的内容和主题分离，让我们专注在内容创作上。 同时还可以让更多和我们有共同诉求的人，重用我们的主题。
需求分析 # 我们的目标是分离出站点的主题，也就是将content和layouts，及static分离开，并作为主题引入。
所需要的步骤如下：
创建主题仓库 将模板样式从原有站点分离出来 引入主题 实施细节 # 接下来我们一步步的实现以上需求。
创建主题仓库 # 因为站点定位个人品牌，需求并不复杂，以简洁为主。 我们给主题取名zero，寓意起点。
首先创建好空的zero Github仓库，再用Hugo命令生成主题默认目录结构：
➜ zero git:(main) ✗ hugo new theme . Creating theme at /Users/sunwei/github/sunwei/zero/themes ➜ zero git:(main) ✗ ls LICENSE README.md public resources themes 可以看出，Hugo认为我们是在站点里，正在给站点创建主题。 实际上我们需要的是themes里面的内容。 在我们的实例中，其实就theme.toml这一个主题配置文件。 拷贝到我们的仓库根目录下后，更新其中说明内容如下：
name = &amp;#34;Zero&amp;#34; license = &amp;#34;MIT&amp;#34; licenselink = &amp;#34;https://github.com/sunwei/zero/blob/master/LICENSE&amp;#34; description = &amp;#34;Hugo Theme for sunewi.xyz&amp;#34; homepage = &amp;#34;https://sunwei.xyz/&amp;#34; demosite = &amp;#34;https://sunwei.</description></item></channel></rss>