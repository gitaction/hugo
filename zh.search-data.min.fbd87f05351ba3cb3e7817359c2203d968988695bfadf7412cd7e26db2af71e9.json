[{"id":0,"href":"/docs/code/","title":"源码实现","section":"Docs","content":" 源码实现 - 多读书，读好书 # 学习也有不同的阶段 - 了解，知道，会。 通过别人的讲解，我听明白了，就可以说了解了。 不仅听懂了，还能复述出来，这就是知道。 不仅知道，我还能动手实践，并且结果还不错，那就是会了。\n拿写作举例。 通过看介绍写作的文章，能了解到，原来写作就是将自己的想法记录下来，这就了解了写作是怎么一回事。 经过思考总结，能够将刚才的文章复述出来，并且可以给别人解释写作是怎么一回事了，也就是知道了。 按照理解，开始动手实践了，还完整的表达了自己的想法，也就可以说会写作了。\n源码学习也是一样。 希望自己能够通过读源码的方式，了解优秀开源项目是怎么工作的，知道其中的原理，并且将吸取的知识转换成实际动手的能力。\n所有人都知道要多读书，尤其是好书。 优秀源码就像好书，那么多优秀的开源项目就躺在那，触手可及，可为什么读的人却不多呢？\n我觉得主要原因有以下两点：\n代码量巨大，不知从何下手。好的开源项目通常都很庞大，没有人领进门，全靠自己，难度不小。 编程语言设计的初衷是用来写的，并不是用来读的。 人类自然语言主要是用来交流，用在人和人之间。 而编程语言则是用在人和机器之间，工程师将自己的想法按计算机能懂的代码表达出来，让机器完成我们下达的指令。 探索步骤\n为了让自己能更好掌握站点领域中Hugo的知识，我准备采用以下步骤对Hugo源码进行学习，以达到会的目的：\n跬步千里。以可运行源码为基础，分块学习，专注在当前模块，减少知识负载，并可以通过源码实时验证自己的猜想。 了然于胸。用时序图将源码一层层展开，理解实现流程和设计细节。 抽象总结。用祖师爷冯诺依曼架构 - Input -\u0026gt; [?] -\u0026gt; Output，来对实现思路想进行总结，进一步帮助理解和总结。 动手实践。图示关键设计点，掌握精髓。用源码解释源码，对基础知识进行阐述，夯实基础。 "},{"id":1,"href":"/posts/creating-a-new-theme/","title":"为什么要读Hugo源码","section":"Blog","content":" Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n## this is a comment $ echo this is a command this is a command ## edit the file $ vi foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug :wq ## show it $ cat foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug $ Some Definitions # There are a few concepts that you need to understand before creating a theme.\nSkins # Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page # The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\nSite Configuration File # When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\nContent # Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\nFront Matter # The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\nMarkdown # Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\nTemplate Files # Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it\u0026rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\nSingle Template # A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\nList Template # A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\nPartial Template # A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.\nCreate a New Site # Let\u0026rsquo;s use Hugo to create a new web site. I\u0026rsquo;m a Mac user, so I\u0026rsquo;ll create mine in my home directory, in the Sites folder. If you\u0026rsquo;re using Linux, you might have to create the folder first.\nThe \u0026ldquo;new site\u0026rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n$ hugo new site ~/Sites/zafta $ cd ~/Sites/zafta $ ls -l total 8 drwxr-xr-x 7 quoha staff 238 Sep 29 16:49 . drwxr-xr-x 3 quoha staff 102 Sep 29 16:49 .. drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $ Take a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That\u0026rsquo;s a topic for a different tutorial, so please ignore them for now.\nGenerate the HTML For the New Site # Running the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that\u0026rsquo;s everything that\u0026rsquo;s not content). Since we have an empty site, it won\u0026rsquo;t do much, but it will do it very quickly.\n$ hugo --verbose INFO: 2014/09/29 Using config file: config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ The \u0026ldquo;--verbose\u0026rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with \u0026ldquo;INFO:\u0026rdquo; or \u0026ldquo;WARN:\u0026rdquo; is present because we used that flag. The lines that start with \u0026ldquo;WARN:\u0026rdquo; are warning messages. We\u0026rsquo;ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n$ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $ See that new public/ directory? Hugo placed all generated content there. When you\u0026rsquo;re ready to publish your web site, that\u0026rsquo;s the place to start. For now, though, let\u0026rsquo;s just confirm that we have what we\u0026rsquo;d expect from a site with no content.\n$ ls -l public total 16 -rw-r--r-- 1 quoha staff 416 Sep 29 17:02 index.xml -rw-r--r-- 1 quoha staff 262 Sep 29 17:02 sitemap.xml $ Hugo created two XML files, which is standard, but there are no HTML files.\nTest the New Site # Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the \u0026ldquo;server\u0026rdquo; command. If it is successful, you will see output similar to the following:\n$ hugo server --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop Connect to the listed URL (it\u0026rsquo;s on the line that starts with \u0026ldquo;Web Server\u0026rdquo;). If everything is working correctly, you should get a page that shows the following:\nindex.xml sitemap.xml That\u0026rsquo;s a listing of your public/ directory. Hugo didn\u0026rsquo;t create a home page because our site has no content. When there\u0026rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] That second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it\u0026rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we\u0026rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn\u0026rsquo;t find a template for the home page and it told you so.\nAt this point, you\u0026rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.\nCreate a New Theme # Hugo doesn\u0026rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe\u0026rsquo;re going to create a new theme called \u0026ldquo;zafta.\u0026rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses \u0026ldquo;post\u0026rdquo; over \u0026ldquo;blog\u0026rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\nCreate a Skeleton # Use the hugo \u0026ldquo;new\u0026rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n$ hugo new theme zafta $ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes $ find themes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 1081 Sep 29 17:31 themes/zafta/LICENSE.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html -rw-r--r-- 1 quoha staff 93 Sep 29 17:31 themes/zafta/theme.toml $ The skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They\u0026rsquo;re optional, but if you\u0026rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It\u0026rsquo;s also nice to declare the license so that people will know how they can use the theme.\n$ vi themes/zafta/theme.toml author = \u0026#34;michael d henderson\u0026#34; description = \u0026#34;a minimal working template\u0026#34; license = \u0026#34;MIT\u0026#34; name = \u0026#34;zafta\u0026#34; source_repo = \u0026#34;\u0026#34; tags = [\u0026#34;tags\u0026#34;, \u0026#34;categories\u0026#34;] :wq ## also edit themes/zafta/LICENSE.md and change ## the bit that says \u0026#34;YOUR_NAME_HERE\u0026#34; Note that the the skeleton\u0026rsquo;s template files are empty. Don\u0026rsquo;t worry, we\u0026rsquo;ll be changing that shortly.\n$ find themes/zafta -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html $ Update the Configuration File to Use the Theme # Now that we\u0026rsquo;ve got a theme to work with, it\u0026rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add \u0026ldquo;-t zafta\u0026rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don\u0026rsquo;t put it in the configuration file or specify it on the command line, you won\u0026rsquo;t use the template that you\u0026rsquo;re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n$ vi config.toml theme = \u0026#34;zafta\u0026#34; baseurl = \u0026#34;\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;zafta - totally refreshing\u0026#34; MetaDataFormat = \u0026#34;toml\u0026#34; :wq $ Generate the Site # Now that we have an empty theme, let\u0026rsquo;s generate the site again.\n$ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ Did you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme\u0026rsquo;s directory.\nLet\u0026rsquo;s check the public/ directory to see what Hugo\u0026rsquo;s created.\n$ ls -l public total 16 drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 css -rw-r--r-- 1 quoha staff 0 Sep 29 17:56 index.html -rw-r--r-- 1 quoha staff 407 Sep 29 17:56 index.xml drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 js -rw-r--r-- 1 quoha staff 243 Sep 29 17:56 sitemap.xml $ Notice four things:\nHugo created a home page. This is the file public/index.html. Hugo created a css/ directory. Hugo created a js/ directory. Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn\u0026rsquo;t create any pages. That\u0026rsquo;s because it considers a \u0026ldquo;page\u0026rdquo; to be a file created directly from a content file. It doesn\u0026rsquo;t count things like the index.html files that it creates automatically. The Home Page # Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo\u0026rsquo;s warning message shows that it looks for three different templates:\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] If it can\u0026rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n$ find . -name index.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 20:21 ./public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 ./themes/zafta/layouts/index.html $ The Magic of Static # Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo\u0026rsquo;s opinion is that you\u0026rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don\u0026rsquo;t like that, you can change the directory names in your theme directory or even delete them completely. Hugo\u0026rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.\n$ find themes/zafta -type d | xargs ls -ld drwxr-xr-x 7 quoha staff 238 Sep 29 17:38 themes/zafta drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes/zafta/archetypes drwxr-xr-x 5 quoha staff 170 Sep 29 17:31 themes/zafta/layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/_default drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/partials drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/static drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/css drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/js $ The Theme Development Cycle # When you\u0026rsquo;re working on a theme, you will make changes in the theme\u0026rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\nPurge the public/ directory. Run the built in web server in watch mode. Open your site in a browser. Update the theme. Glance at your browser window to see changes. Return to step 4. I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\nPurge the public/ Directory # When generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you\u0026rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.\nHugo\u0026rsquo;s Watch Option # Hugo\u0026rsquo;s \u0026ldquo;--watch\u0026rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\nLive Reload # Hugo\u0026rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, \u0026ldquo;Wow, that\u0026rsquo;s totally amazing.\u0026rdquo;\nDevelopment Commands # Use the following commands as the basis for your workflow.\n## purge old files. hugo will recreate the public directory. ## $ rm -rf public ## ## run hugo in watch mode ## $ hugo server --watch --verbose Here\u0026rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I\u0026rsquo;ve said this before, it\u0026rsquo;s amazing.\n$ rm -rf public $ hugo server --watch --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Watching for changes in /Users/quoha/Sites/zafta/content Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop INFO: 2014/09/29 File System Event: [\u0026#34;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\u0026#34;: MODIFY|ATTRIB] Change detected, rebuilding site WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 1 ms Update the Home Page Template # The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme\u0026rsquo;s layout/ directory:\nindex.html _default/list.html _default/single.html We could update one of the default templates, but a good design decision is to update the most specific template available. That\u0026rsquo;s not a hard and fast rule (in fact, we\u0026rsquo;ll break it a few times in this tutorial), but it is a good generalization.\nMake a Static Home Page # Right now, that page is empty because we don\u0026rsquo;t have any content and we don\u0026rsquo;t have any logic in the template. Let\u0026rsquo;s change that by adding some text to the template.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Build the web site and then verify the results.\n$ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 21:26 public/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt; Live Reload # Note: If you\u0026rsquo;re running the server with the --watch option, you\u0026rsquo;ll see different content in the file:\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;script src=\u0026#34;http://\u0026#39; + (location.host || \u0026#39;localhost\u0026#39;).split(\u0026#39;:\u0026#39;)[0] + \u0026#39;:1313/livereload.js?mindelay=10\u0026#34;\u0026gt;\u0026lt;/\u0026#39; + \u0026#39;script\u0026gt;\u0026#39;)\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; When you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\nBuild a \u0026ldquo;Dynamic\u0026rdquo; Home Page # \u0026ldquo;Dynamic home page?\u0026rdquo; Hugo\u0026rsquo;s a static web site generator, so this seems an odd thing to say. I mean let\u0026rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We\u0026rsquo;ll use iteration in the template to do that.\nCreate New Posts # Now that we have the home page generating static content, let\u0026rsquo;s add some content to the site. We\u0026rsquo;ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n$ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md ERROR: 2014/09/29 Unable to Cast \u0026lt;nil\u0026gt; to map[string]interface{} $ That wasn\u0026rsquo;t very nice, was it?\nThe \u0026ldquo;new\u0026rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there\u0026rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n$ vi themes/zafta/archetypes/post.md +++ Description = \u0026#34;\u0026#34; Tags = [] Categories = [] +++ :wq $ find themes/zafta/archetypes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 21:53 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 51 Sep 29 21:54 themes/zafta/archetypes/post.md $ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md /Users/quoha/Sites/zafta/content/post/first.md created $ hugo --verbose new post/second.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/second.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md /Users/quoha/Sites/zafta/content/post/second.md created $ ls -l content/post total 16 -rw-r--r-- 1 quoha staff 104 Sep 29 21:54 first.md -rw-r--r-- 1 quoha staff 105 Sep 29 21:57 second.md $ cat content/post/first.md +++ Categories = [] Description = \u0026#34;\u0026#34; Tags = [] date = \u0026#34;2014-09-29T21:54:53-05:00\u0026#34; title = \u0026#34;first\u0026#34; +++ my first post $ cat content/post/second.md +++ Categories = [] Description = \u0026#34;\u0026#34; Tags = [] date = \u0026#34;2014-09-29T21:57:09-05:00\u0026#34; title = \u0026#34;second\u0026#34; +++ my second post $ Build the web site and then verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ The output says that it created 2 pages. Those are our new posts:\n$ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 22:13 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/second/index.html $ The new files are empty because because the templates used to generate the content are empty. The homepage doesn\u0026rsquo;t show the new content, either. We have to update the templates to add the posts.\nList and Single Templates # In Hugo, we have three major kinds of templates. There\u0026rsquo;s the home page template that we updated previously. It is used only by the home page. We also have \u0026ldquo;single\u0026rdquo; templates which are used to generate output for a single content file. We also have \u0026ldquo;list\u0026rdquo; templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named \u0026ldquo;list.html\u0026rdquo; and single templates are named \u0026ldquo;single.html.\u0026rdquo;\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\nAdd Content to the Homepage # The home page will contain a list of posts. Let\u0026rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Hugo uses the Go template engine. That engine scans the template files for commands which are enclosed between \u0026ldquo;{{\u0026rdquo; and \u0026ldquo;}}\u0026rdquo;. In our template, the commands are:\nrange .Title end The \u0026ldquo;range\u0026rdquo; command is an iterator. We\u0026rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe \u0026ldquo;.Title\u0026rdquo; command prints the value of the \u0026ldquo;title\u0026rdquo; variable. Hugo pulls it from the front matter in the Markdown file.\nThe \u0026ldquo;end\u0026rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds \u0026ldquo;end.\u0026rdquo; Everything between the \u0026ldquo;range\u0026rdquo; and \u0026ldquo;end\u0026rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt\u0026rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:23 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Congratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let\u0026rsquo;s take a moment to appreciate what we\u0026rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you\u0026rsquo;ve learned everything you need to know to build a theme. All that\u0026rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don\u0026rsquo;t worry, though, that\u0026rsquo;s all to come.\nAdd Content to the Posts # We\u0026rsquo;re working with posts, which are in the content/post/ directory. That means that their section is \u0026ldquo;post\u0026rdquo; (and if we don\u0026rsquo;t do something weird, their type is also \u0026ldquo;post\u0026rdquo;).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can\u0026rsquo;t find one, then it will look in the _default/ directory. There are some twists that we\u0026rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let\u0026rsquo;s see what we actually have available:\n$ find themes/zafta -name single.html | xargs ls -l -rw-r--r-- 1 quoha staff 132 Sep 29 17:31 themes/zafta/layouts/_default/single.html We could create a new template, post/single.html, or change the default. Since we don\u0026rsquo;t know of any other content types, let\u0026rsquo;s start with updating the default.\nRemember, any content that we haven\u0026rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we\u0026rsquo;re going to be adding different types of content and we\u0026rsquo;re going to end up undoing some of the changes we\u0026rsquo;ve made. It\u0026rsquo;s good because we\u0026rsquo;ll be able to see immediate results. It\u0026rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we\u0026rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we\u0026rsquo;ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you\u0026rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That\u0026rsquo;s a refreshing amount of joy right there.\nUpdate the Template File # $ vi themes/zafta/layouts/_default/single.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Build the web site and verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:40 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:40 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:40 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:40 public/post/second/index.html $ cat public/post/first/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my first post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ cat public/post/second/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;second\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my second post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Notice that the posts now have content. You can go to localhost:1313/post/first to verify.\nLinking to Content # The posts are on the home page. Let\u0026rsquo;s add a link from there to the post. Since this is the home page, we\u0026rsquo;ll update its template.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Build the web site and verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 149 Sep 29 22:44 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:44 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:44 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:44 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;/post/second/\u0026#34;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;/post/first/\u0026#34;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Create a Post Listing # We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let\u0026rsquo;s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let\u0026rsquo;s take a quick look and see which list templates are available.\n$ find themes/zafta -name list.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html As with the single post, we have to decide to update _default/list.html or create post/list.html. We still don\u0026rsquo;t have multiple content types, so let\u0026rsquo;s stay consistent and update the default list template.\nCreating Top Level Pages # Let\u0026rsquo;s add an \u0026ldquo;about\u0026rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let\u0026rsquo;s verify that by creating an \u0026ldquo;about\u0026rdquo; page at the top level:\n$ vi content/about.md +++ title = \u0026#34;about\u0026#34; description = \u0026#34;about this site\u0026#34; date = \u0026#34;2014-09-27\u0026#34; slug = \u0026#34;about time\u0026#34; +++ ## about us i\u0026#39;m speechless :wq Generate the web site and verify the results.\n$ find public -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:08 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 527 Sep 27 15:08 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:08 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:08 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:08 public/post/second-post/index.html Notice that the page wasn\u0026rsquo;t created at the top level. It was created in a sub-directory named \u0026lsquo;about-time/\u0026rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It\u0026rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/theme/\u0026#34;\u0026gt;creating a new theme\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/about-time/\u0026#34;\u0026gt;about\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/second-post/\u0026#34;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/first-post/\u0026#34;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;script src=\u0026#34;http://\u0026#39; + (location.host || \u0026#39;localhost\u0026#39;).split(\u0026#39;:\u0026#39;)[0] + \u0026#39;:1313/livereload.js?mindelay=10\u0026#34;\u0026gt;\u0026lt;/\u0026#39; + \u0026#39;script\u0026gt;\u0026#39;)\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Notice that the \u0026ldquo;about\u0026rdquo; link is listed with the posts? That\u0026rsquo;s not desirable, so let\u0026rsquo;s change that first.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026#34;post\u0026#34;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if eq .Type \u0026#34;page\u0026#34; }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq Generate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n$ find public -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:33 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 645 Sep 27 15:33 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:33 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:33 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:33 public/post/second-post/index.html Knowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let\u0026rsquo;s do it the hard way and change the permalink in the configuration file.\n$ vi config.toml [permalinks] page = \u0026#34;/:title/\u0026#34; about = \u0026#34;/:filename/\u0026#34; Generate the web site and verify that this didn\u0026rsquo;t work. Hugo lets \u0026ldquo;slug\u0026rdquo; or \u0026ldquo;URL\u0026rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.\nSharing Templates # If you\u0026rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn\u0026rsquo;t. That\u0026rsquo;s because we didn\u0026rsquo;t put the title in the home page\u0026rsquo;s template (layouts/index.html). That\u0026rsquo;s an easy thing to do, but let\u0026rsquo;s look at a different option.\nWe can put the common bits into a shared template that\u0026rsquo;s stored in the themes/zafta/layouts/partials/ directory.\nCreate the Header and Footer Partials # In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme\u0026rsquo;s presentation.\n$ vi themes/zafta/layouts/partials/header.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; :wq $ vi themes/zafta/layouts/partials/footer.html \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq Update the Home Page Template to Use the Partials # The most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \u0026#34;theme/partials/header.html\u0026#34; . }} versus\n{{ partial \u0026#34;header.html\u0026#34; . }} Both pass in the context.\nLet\u0026rsquo;s change the home page template to use these new partials.\n$ vi themes/zafta/layouts/index.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026#34;post\u0026#34;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if or (eq .Type \u0026#34;page\u0026#34;) (eq .Type \u0026#34;about\u0026#34;) }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The title on the home page is now \u0026ldquo;your title here\u0026rdquo;, which comes from the \u0026ldquo;title\u0026rdquo; variable in the config.toml file.\nUpdate the Default Single Template to Use the Partials # $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.\nAdd “Date Published” to Posts # It\u0026rsquo;s common to have posts display the date that they were written or published, so let\u0026rsquo;s add that. The front matter of our posts has a variable named \u0026ldquo;date.\u0026rdquo; It\u0026rsquo;s usually the date the content was created, but let\u0026rsquo;s pretend that\u0026rsquo;s the value we want to display.\nAdd “Date Published” to the Template # We\u0026rsquo;ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }} Posts use the default single template, so we\u0026rsquo;ll change that file.\n$ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The posts now have the date displayed in them. There\u0026rsquo;s a problem, though. The \u0026ldquo;about\u0026rdquo; page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an \u0026ldquo;if\u0026rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.\nThe \u0026ldquo;if\u0026rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of \u0026ldquo;code for today,\u0026rdquo; too.\nLet\u0026rsquo;s assume, though, that we\u0026rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we\u0026rsquo;re going to create a section template.\nLet\u0026rsquo;s restore the default single template before we forget.\n$ mkdir themes/zafta/layouts/post $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Now we\u0026rsquo;ll update the post\u0026rsquo;s version of the single template. If you remember Hugo\u0026rsquo;s rules, the template engine will use this version over the default.\n$ vi themes/zafta/layouts/post/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Note that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn\u0026rsquo;t.\nDon\u0026rsquo;t Repeat Yourself # DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you\u0026rsquo;re figuring that out, accept that you\u0026rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it\u0026rsquo;s okay to delay splitting up a template.\n"},{"id":2,"href":"/posts/migrate-from-jekyll/","title":"Migrate to Hugo from Jekyll","section":"Blog","content":" Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like\n▾ \u0026lt;root\u0026gt;/ ▾ images/ logo.png should become\n▾ \u0026lt;root\u0026gt;/ ▾ static/ ▾ images/ logo.png Additionally, you\u0026rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.\nCreate your Hugo configuration file # Hugo can read your configuration as JSON, YAML or TOML. Hugo supports parameters custom configuration too. Refer to the Hugo configuration documentation for details.\nSet your configuration publish folder to _site # The default is for Jekyll to publish to _site and for Hugo to publish to public. If, like me, you have _site mapped to a git submodule on the gh-pages branch, you\u0026rsquo;ll want to do one of two alternatives:\nChange your submodule to point to map gh-pages to public instead of _site (recommended).\ngit submodule deinit _site git rm _site git submodule add -b gh-pages git@github.com:your-username/your-repo.git public Or, change the Hugo configuration to use _site instead of public.\n{ .. \u0026quot;publishdir\u0026quot;: \u0026quot;_site\u0026quot;, .. } Convert Jekyll templates to Hugo templates # That\u0026rsquo;s the bulk of the work right here. The documentation is your friend. You should refer to Jekyll\u0026rsquo;s template documentation if you need to refresh your memory on how you built your blog and Hugo\u0026rsquo;s template to learn Hugo\u0026rsquo;s way.\nAs a single reference data point, converting my templates for heyitsalex.net took me no more than a few hours.\nConvert Jekyll plugins to Hugo shortcodes # Jekyll has plugins; Hugo has shortcodes. It\u0026rsquo;s fairly trivial to do a port.\nImplementation # As an example, I was using a custom image_tag plugin to generate figures with caption when running Jekyll. As I read about shortcodes, I found Hugo had a nice built-in shortcode that does exactly the same thing.\nJekyll\u0026rsquo;s plugin:\nmodule Jekyll class ImageTag \u0026lt; Liquid::Tag @url = nil @caption = nil @class = nil @link = nil // Patterns IMAGE_URL_WITH_CLASS_AND_CAPTION = IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;(\\s+)-\u0026gt;((https?:\\/\\/|\\/)(\\S+))(\\s*)/i IMAGE_URL_WITH_CAPTION = /((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;/i IMAGE_URL_WITH_CLASS = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))/i IMAGE_URL = /((https?:\\/\\/|\\/)(\\S+))/i def initialize(tag_name, markup, tokens) super if markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK @class = $1 @url = $3 @caption = $7 @link = $9 elsif markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION @class = $1 @url = $3 @caption = $7 elsif markup =~ IMAGE_URL_WITH_CAPTION @url = $1 @caption = $5 elsif markup =~ IMAGE_URL_WITH_CLASS @class = $1 @url = $3 elsif markup =~ IMAGE_URL @url = $1 end end def render(context) if @class source = \u0026quot;\u0026lt;figure class='#{@class}'\u0026gt;\u0026quot; else source = \u0026quot;\u0026lt;figure\u0026gt;\u0026quot; end if @link source += \u0026quot;\u0026lt;a href=\\\u0026quot;#{@link}\\\u0026quot;\u0026gt;\u0026quot; end source += \u0026quot;\u0026lt;img src=\\\u0026quot;#{@url}\\\u0026quot;\u0026gt;\u0026quot; if @link source += \u0026quot;\u0026lt;/a\u0026gt;\u0026quot; end source += \u0026quot;\u0026lt;figcaption\u0026gt;#{@caption}\u0026lt;/figcaption\u0026gt;\u0026quot; if @caption source += \u0026quot;\u0026lt;/figure\u0026gt;\u0026quot; source end end end Liquid::Template.register_tag('image', Jekyll::ImageTag) is written as this Hugo shortcode:\n\u0026lt;!-- image --\u0026gt; \u0026lt;figure {{ with .Get \u0026quot;class\u0026quot; }}class=\u0026quot;{{.}}\u0026quot;{{ end }}\u0026gt; {{ with .Get \u0026quot;link\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt;{{ end }} \u0026lt;img src=\u0026quot;{{ .Get \u0026quot;src\u0026quot; }}\u0026quot; {{ if or (.Get \u0026quot;alt\u0026quot;) (.Get \u0026quot;caption\u0026quot;) }}alt=\u0026quot;{{ with .Get \u0026quot;alt\u0026quot;}}{{.}}{{else}}{{ .Get \u0026quot;caption\u0026quot; }}{{ end }}\u0026quot;{{ end }} /\u0026gt; {{ if .Get \u0026quot;link\u0026quot;}}\u0026lt;/a\u0026gt;{{ end }} {{ if or (or (.Get \u0026quot;title\u0026quot;) (.Get \u0026quot;caption\u0026quot;)) (.Get \u0026quot;attr\u0026quot;)}} \u0026lt;figcaption\u0026gt;{{ if isset .Params \u0026quot;title\u0026quot; }} {{ .Get \u0026quot;title\u0026quot; }}{{ end }} {{ if or (.Get \u0026quot;caption\u0026quot;) (.Get \u0026quot;attr\u0026quot;)}}\u0026lt;p\u0026gt; {{ .Get \u0026quot;caption\u0026quot; }} {{ with .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt; {{ end }} {{ .Get \u0026quot;attr\u0026quot; }} {{ if .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/p\u0026gt; {{ end }} \u0026lt;/figcaption\u0026gt; {{ end }} \u0026lt;/figure\u0026gt; \u0026lt;!-- image --\u0026gt; Usage # I simply changed:\n{% image full http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg \u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were \u0026quot;having fun\u0026quot; and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; -\u0026gt;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/ %} to this (this example uses a slightly extended version named fig, different than the built-in figure):\n{{% fig class=\u0026quot;full\u0026quot; src=\u0026quot;http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg\u0026quot; title=\u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were having fun and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; link=\u0026quot;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/\u0026quot; %}} As a bonus, the shortcode named parameters are, arguably, more readable.\nFinishing touches # Fix content # Depending on the amount of customization that was done with each post with Jekyll, this step will require more or less effort. There are no hard and fast rules here except that hugo server --watch is your friend. Test your changes and fix errors as needed.\nClean up # You\u0026rsquo;ll want to remove the Jekyll configuration at this point. If you have anything else that isn\u0026rsquo;t used, delete it.\nA practical example in a diff # Hey, it\u0026rsquo;s Alex was migrated in less than a father-with-kids day from Jekyll to Hugo. You can see all the changes (and screw-ups) by looking at this diff.\n"},{"id":3,"href":"/posts/goisforlovers/","title":"(Hu)go Template Primer","section":"Blog","content":"Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.\nThis document is a brief primer on using Go templates. The Go docs provide more details.\nIntroduction to Go Templates # Go templates provide an extremely simple template language. It adheres to the belief that only the most basic of logic belongs in the template or view layer. One consequence of this simplicity is that Go templates parse very quickly.\nA unique characteristic of Go templates is they are content aware. Variables and content will be sanitized depending on the context of where they are used. More details can be found in the Go docs.\nBasic Syntax # Golang templates are HTML files with the addition of variables and functions.\nGo variables and functions are accessible within {{ }}\nAccessing a predefined variable \u0026ldquo;foo\u0026rdquo;:\n{{ foo }} Parameters are separated using spaces\nCalling the add function with input of 1, 2:\n{{ add 1 2 }} Methods and fields are accessed via dot notation\nAccessing the Page Parameter \u0026ldquo;bar\u0026rdquo;\n{{ .Params.bar }} Parentheses can be used to group items together\n{{ if or (isset .Params \u0026quot;alt\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;) }} Caption {{ end }} Variables # Each Go template has a struct (object) made available to it. In hugo each template is passed either a page or a node struct depending on which type of page you are rendering. More details are available on the variables page.\nA variable is accessed by referencing the variable name.\n\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; Variables can also be defined and referenced.\n{{ $address := \u0026quot;123 Main St.\u0026quot;}} {{ $address }} Functions # Go template ship with a few functions which provide basic functionality. The Go template system also provides a mechanism for applications to extend the available functions with their own. Hugo template functions provide some additional functionality we believe are useful for building websites. Functions are called by using their name followed by the required parameters separated by spaces. Template functions cannot be added without recompiling hugo.\nExample:\n{{ add 1 2 }} Includes # When including another template you will pass to it the data it will be able to access. To pass along the current context please remember to include a trailing dot. The templates location will always be starting at the /layout/ directory within Hugo.\nExample:\n{{ template \u0026quot;chrome/header.html\u0026quot; . }} Logic # Go templates provide the most basic iteration and conditional logic.\nIteration # Just like in Go, the Go templates make heavy use of range to iterate over a map, array or slice. The following are different examples of how to use range.\nExample 1: Using Context\n{{ range array }} {{ . }} {{ end }} Example 2: Declaring value variable name\n{{range $element := array}} {{ $element }} {{ end }} Example 2: Declaring key and value variable name\n{{range $index, $element := array}} {{ $index }} {{ $element }} {{ end }} Conditionals # If, else, with, or, \u0026amp; and provide the framework for handling conditional logic in Go Templates. Like range, each statement is closed with end.\nGo Templates treat the following values as false:\nfalse 0 any array, slice, map, or string of length zero Example 1: If\n{{ if isset .Params \u0026quot;title\u0026quot; }}\u0026lt;h4\u0026gt;{{ index .Params \u0026quot;title\u0026quot; }}\u0026lt;/h4\u0026gt;{{ end }} Example 2: If -\u0026gt; Else\n{{ if isset .Params \u0026quot;alt\u0026quot; }} {{ index .Params \u0026quot;alt\u0026quot; }} {{else}} {{ index .Params \u0026quot;caption\u0026quot; }} {{ end }} Example 3: And \u0026amp; Or\n{{ if and (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}} Example 4: With\nAn alternative way of writing \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent.\nThe first example above could be simplified as:\n{{ with .Params.title }}\u0026lt;h4\u0026gt;{{ . }}\u0026lt;/h4\u0026gt;{{ end }} Example 5: If -\u0026gt; Else If\n{{ if isset .Params \u0026quot;alt\u0026quot; }} {{ index .Params \u0026quot;alt\u0026quot; }} {{ else if isset .Params \u0026quot;caption\u0026quot; }} {{ index .Params \u0026quot;caption\u0026quot; }} {{ end }} Pipes # One of the most powerful components of Go templates is the ability to stack actions one after another. This is done by using pipes. Borrowed from unix pipes, the concept is simple, each pipeline\u0026rsquo;s output becomes the input of the following pipe.\nBecause of the very simple syntax of Go templates, the pipe is essential to being able to chain together function calls. One limitation of the pipes is that they only can work with a single value and that value becomes the last parameter of the next pipeline.\nA few simple examples should help convey how to use the pipe.\nExample 1 :\n{{ if eq 1 1 }} Same {{ end }} is the same as\n{{ eq 1 1 | if }} Same {{ end }} It does look odd to place the if at the end, but it does provide a good illustration of how to use the pipes.\nExample 2 :\n{{ index .Params \u0026quot;disqus_url\u0026quot; | html }} Access the page parameter called \u0026ldquo;disqus_url\u0026rdquo; and escape the HTML.\nExample 3 :\n{{ if or (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}} Stuff Here {{ end }} Could be rewritten as\n{{ isset .Params \u0026quot;caption\u0026quot; | or isset .Params \u0026quot;title\u0026quot; | or isset .Params \u0026quot;attr\u0026quot; | if }} Stuff Here {{ end }} Context (aka. the dot) # The most easily overlooked concept to understand about Go templates is that {{ . }} always refers to the current context. In the top level of your template this will be the data set made available to it. Inside of a iteration it will have the value of the current item. When inside of a loop the context has changed. . will no longer refer to the data available to the entire page. If you need to access this from within the loop you will likely want to set it to a variable instead of depending on the context.\nExample:\n{{ $title := .Site.Title }} {{ range .Params.tags }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026quot;{{ $baseurl }}/tags/{{ . | urlize }}\u0026quot;\u0026gt;{{ . }}\u0026lt;/a\u0026gt; - {{ $title }} \u0026lt;/li\u0026gt; {{ end }} Notice how once we have entered the loop the value of {{ . }} has changed. We have defined a variable outside of the loop so we have access to it from within the loop.\nHugo Parameters # Hugo provides the option of passing values to the template language through the site configuration (for sitewide values), or through the meta data of each specific piece of content. You can define any values of any type (supported by your front matter/config format) and use them however you want to inside of your templates.\nUsing Content (page) Parameters # In each piece of content you can provide variables to be used by the templates. This happens in the front matter.\nAn example of this is used in this documentation site. Most of the pages benefit from having the table of contents provided. Sometimes the TOC just doesn\u0026rsquo;t make a lot of sense. We\u0026rsquo;ve defined a variable in our front matter of some pages to turn off the TOC from being displayed.\nHere is the example front matter:\n--- title: \u0026#34;Permalinks\u0026#34; date: \u0026#34;2013-11-18\u0026#34; aliases: - \u0026#34;/doc/permalinks/\u0026#34; groups: [\u0026#34;extras\u0026#34;] groups_weight: 30 notoc: true --- Here is the corresponding code inside of the template:\n{{ if not .Params.notoc }} \u0026lt;div id=\u0026quot;toc\u0026quot; class=\u0026quot;well col-md-4 col-sm-6\u0026quot;\u0026gt; {{ .TableOfContents }} \u0026lt;/div\u0026gt; {{ end }} Using Site (config) Parameters # In your top-level configuration file (eg, config.yaml) you can define site parameters, which are values which will be available to you in chrome.\nFor instance, you might declare:\nparams: CopyrightHTML: \u0026#34;Copyright \u0026amp;#xA9; 2013 John Doe. All Rights Reserved.\u0026#34; TwitterUser: \u0026#34;spf13\u0026#34; SidebarRecentLimit: 5 Within a footer layout, you might then declare a \u0026lt;footer\u0026gt; which is only provided if the CopyrightHTML parameter is provided, and if it is given, you would declare it to be HTML-safe, so that the HTML entity is not escaped again. This would let you easily update just your top-level config file each January 1st, instead of hunting through your templates.\n{{if .Site.Params.CopyrightHTML}}\u0026lt;footer\u0026gt; \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt;{{.Site.Params.CopyrightHTML | safeHtml}}\u0026lt;/div\u0026gt; \u0026lt;/footer\u0026gt;{{end}} An alternative way of writing the \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent:\n{{with .Site.Params.TwitterUser}}\u0026lt;span class=\u0026#34;twitter\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://twitter.com/{{.}}\u0026#34; rel=\u0026#34;author\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/images/twitter.png\u0026#34; width=\u0026#34;48\u0026#34; height=\u0026#34;48\u0026#34; title=\u0026#34;Twitter: {{.}}\u0026#34; alt=\u0026#34;Twitter\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt;{{end}} Finally, if you want to pull \u0026ldquo;magic constants\u0026rdquo; out of your layouts, you can do so, such as in this example:\n\u0026lt;nav class=\u0026#34;recent\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Recent Posts\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt;{{range first .Site.Params.SidebarRecentLimit .Site.Recent}} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{.RelPermalink}}\u0026#34;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{end}}\u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; "},{"id":4,"href":"/posts/hugoisforlovers/","title":"Getting Started with Hugo","section":"Blog","content":" Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.\nSave it somewhere specific as we will be using it in the next step.\nMore complete instructions are available at Install Hugo\nStep 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.\nFollow the following steps:\nClone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313 Corresponding pseudo commands:\ngit clone https://github.com/spf13/hugo cd hugo /path/to/where/you/installed/hugo server --source=./docs \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 27 ms \u0026gt; Web Server is available at http://localhost:1313 \u0026gt; Press ctrl+c to stop Once you\u0026rsquo;ve gotten here, follow along the rest of this page on your local build.\nStep 3. Change the docs site # Stop the Hugo process by hitting Ctrl+C.\nNow we are going to run hugo again, but this time with hugo in watch mode.\n/path/to/hugo/from/step/1/hugo server --source=./docs --watch \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 27 ms \u0026gt; Web Server is available at http://localhost:1313 \u0026gt; Watching for changes in /Users/spf13/Code/hugo/docs/content \u0026gt; Press ctrl+c to stop Open your favorite editor and change one of the source content pages. How about changing this very file to fix the typo. How about changing this very file to fix the typo.\nContent files are found in docs/content/. Unless otherwise specified, files are located at the same relative location as the url, in our case docs/content/overview/quickstart.md.\nChange and save this file.. Notice what happened in your terminal.\n\u0026gt; Change detected, rebuilding site \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 26 ms Refresh the browser and observe that the typo is now fixed.\nNotice how quick that was. Try to refresh the site before it\u0026rsquo;s finished building. I double dare you. Having nearly instant feedback enables you to have your creativity flow without waiting for long builds.\nStep 4. Have fun # The best way to learn something is to play with it.\n"},{"id":5,"href":"/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/","title":"依赖管理","section":"源码实现","content":" Hugo的依赖管理 # 在HugoSites时序图中，通过配置信息创建好站点后，HugoSites实例会先准备好需要惰性初始化的信息，然后在配置信息中补全默认模板服务提供者。 紧接着就开始创建依赖。 其中惰性初始化在当前阶段只是注册信息，真正调用的地方在后面。 而默认模板服务提供者也是补全，实际开始处理模板的触发点则是在稍后的LoadResources中。 所以我们先把这两块放一放，等实际发挥作用的时候再做解释。 先来重点看一看依赖的创建。\n依赖的创建主要包含这四个规范，分别是：\nNewPathSpec NewSpec NewContentSpec NewSourceSpec 其中NewSpec是PathSpec和OutputFormats和MediaTypes的聚合，用来提供一些基础信息，这里直接略过先。\nNewSourceSpec是基于PathSpec组织好的Data目录，提供数据文件相关的服务的。 在Hugo中，用户项目根目录中的Data目录拥有最高优先级，这意味着，如果在主题目录里也有Data目录，并且有重名的数据文件，主题里的数据文件将被覆盖掉。 在调用像index一样的函数时，就可以获取数据文件的详细信息了 - {{ index .Site.Data \u0026quot;123\u0026quot; }}。 我们先专注在Hugo的主流程，这里的SourceSpec我们也略过。\n接下来的重点将放在文件系统集大成者PathSpec，和基础内容提供者ContentSpec。\n"},{"id":6,"href":"/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E5%86%85%E5%AE%B9%E8%A7%84%E8%8C%83/","title":"Index","section":"依赖管理","content":" ContentSpec # 从基础架构中提到的Template vs Layouts章节，我们了解到Layouts是Template的重要组成部分。 Template将站点样式和内容分离，我们只需要提供内容就可以。\n这里就会出现一个疑问：在写作的时候，我们用的明明是Markdown语法，并不是HTML超文本，而Template接收的内容格式是HTML。 那是在什么时候，由谁将Markdown转换成HTML的呢？\n这就要聊到咱们Deps中的另一个依赖ContentSpec了。\n了然于胸 - ContentSpec时序图 # 先通过新建时序图，来看看ContentSpec是如何进行组织和构建的。\n我们先看创建和返回，新建ContentSpec的时候，首先调用的是markup.NewConverterProvider，由此返回的也是converterRegistry。 由此可见，ContentSpec实际上是ConverterProvider - 转换器提供方，实例就是converterRegistry - 转换器注册处。 也就是说，Hugo采用的是注册制，可能会有多个转换器注册在注册处，可根据请求的类型，返回相应的转换器，正是让专业的人干专业的事。\n那我们接着来看看Hugo是如何设计这个转换器注册处的。\n通过中间栏可以看到，Hugo先解析相关的配置项，可以了解到用户的定制化需求和默认的配置信息，如这么多markdown的开源工具，我们默认用哪一个。 再创建一些通用的工具，如高亮组件，可以用来满足用户的高亮需求。 做好了上述的准备工作后，注册处就可以开始营业了，提供的服务当然就是注册Markdown提供方了，在我这注册后，有活的时候，就可以分派给你了。 上图示例中的提供方就是goldmark.Provider，goldmark下是现在Hugo采用的默认markdown解析器。\n在注册处里，并没有直接提供goldmark实例，而是提供了标准的converter.Provider，在这里面，包含了由goldmark.New提供的goldmark实例。 就像注册到滴滴平台的网约车，要求能够提供符合滴滴标准的车辆服务。\n注册处为了方便查找服务提供方，还给这些提供方取了别名，给goldmark取的别名就是default。 如果没有特殊要求，注册处派出的服务提供方都是goldmark。 在网约车中，相当于滴滴的官方推荐。\n注册处，是一个服务提供方。 我在打车的时候，才会打开滴滴的应用。 那在Hugo里，什么时候，会用到转换器注册处呢？\n我们接着再来看看具体地使用场景。 如上述时序图所示，正是站点在渲染内容时使用到转换器的实际场景。\n这个场景是由render渲染阶段触发的，正是Hugo在构建站点过程中对转换器使用的主要场景。 在上图最右边，我们可以看到，将需要渲染的内容renderContent交给converter进行转换，最终返回转换过后的结果convert.Result。 正是在这里，我们将用户所书写的markdown内容，转换成了我们所需要的HTML内容。\n顺带看一下Hugo的渲染思路。 通过时序图的左侧可以看到，这是发生在render的准备阶段，Hugo为所有的Pages精心打扮一番，为渲染做好准备。\n从基础架构中介绍的 OutputFormats我们了解到，每个Page页面可以有多个OutputFormats输出格式。 在渲染的过程中，会明确具体要渲染的格式RenderFormats，RenderFormats是对OutputFormats去重后，处理生成的。\n为了满足render时的要求，在准备阶段，Hugo为所有的Page，根据OutputFormat，都生成了相应的PageContentOutput。 如上图中间部分所示。\n这样，我们的content就为render做好了准备。 合并后的RenderFormats也拥有了符合格式要求的内容信息，再配合Template，就可以生成最终的站点页面了。\n这样一来，我们了解了Hugo是如何对注册处进行管理的。 以及转换器提供方要到什么地方，是如何完成注册操作的。 还了解到Hugo是在何时用到转换器的。 这样，从使用场景，到服务提供方，我们对全流程有了清晰的认识。 但还是感觉好像缺了什么似的，没错，那就是这些提供发究竟是如何将Markdown一步步转换成HTML的？\n带着这个问题，拿Hugo Markdown默认转换器goldmark为例，我们来一探究竟。 详情请查看Markdown文件是如何被翻译成HTML的章节。\n抽象总结 - 输入Markdown格式内容，输出HTML格式渲染结果 # 想要将Markdown格式的内容，渲染成最终的HTML，需要先从注册处获取转换器，新建实例后，用实例来进行最终渲染。\n工欲善其事，必先利其器 - 获取转换器：\n在转换器注册处，注册了不同的提供方。 为了方便查找，用名字作为索引。 这样调用方就能通过名字方便地获取能满足诉求的转换器提供方。 需要正式使用的时候，只需要调用New新建方法，就可以得到拥有实际转换功能的转换器。\n进入转换环节后。 面对Markdown语法结构的字符流，解析器选择的数据结构是AST语法抽象树，这种结构的优点是树状结可以帮助表达内容Block之间的依赖关系。 不仅如此，树状结构很容易对树结点进行走查。 这样等进入到渲染阶段时，我们就可以专注在具体地渲染事项上，再不用关心结点之间的关联和依赖了。 这样，在调用相应的渲染方法，只需专注在具体地渲染细节上了。 比如在渲染heading的时候只需要关注标题的级别，选用对应的HTML标签就可以了。\n动手实践 - Show Me the Code of ContentSpec # "},{"id":7,"href":"/docs/code/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/%E8%B7%AF%E5%BE%84%E8%A7%84%E8%8C%83/","title":"Index","section":"依赖管理","content":" PathSpec # 我们一个个来看，先看PathSpec。 通过基础架构中介绍的 文件系统的组织我们了解到，PathSepc正是文件系统的关键所在。\n了然于胸 - NewPathSpec时序图 # 从上图可以看出，Hugo为自己量身打造的文件系统，庞大且复杂。 光文件系统就有很多种，仅上面提到的就有BasePathFs，BaseFs，baseFileDecoratorFs，OverlayFs，RootMappingFs，SliceFs, LanguageFs。 可以说琳琅满目，数不胜数。 在感叹的同时，也不禁惊心，学习曲线这么陡，可要怎么学！？\n为了不把深入理解Hugo系列写成从入门到放弃系列，让我们先静下心来，发挥一下跬步千里的精神。 陡坡再陡，一天走一步，也总有到头的时候。\n通过观察，我们发现无论Hugo如何组织这些文件系统，目标实际上只有一个，那就是在使用的时候，简单直接，将复杂的需求封装在内部。 那说一千，道一万，还是个文件系统。\n所以首先我们要弄清楚什么是文件系统，以及Hugo是怎么使用文件系统的。 这么多文件系统之间又是个什么样的关系？\n从最开始准备的Path，我们看到除了一些常见的信息，如基础Fs，配置信息Cfg，主题目录，工作目录还有发布目录外，还包含了所有模块的信息AllModules。 模块和文件系统又是什么样的关系？ 接着我们发现在真正构建文件系统的时候，sourceFilesystemBuilder首先做的事情就是创建OverlayFs，为什么这里用到了OverlayFs，要帮助Hugo解决什么样的问题？ 在创建OverlayFs的过程中，还用到了Radix Tree基数树数据结构，基数树是什么，又为什么要用？\n通过以上这些疑问，我们可以把这个陡坡分拆成一个个的小坡：\n什么是文件系统，Hugo是怎么理解的？ 多个文件系统之间是如何关联的？ Modules和文件系统之间，又存在什么样的关系？ 什么是OverlayFs，为什么要用？ 什么是radix tree? 先弄清楚这些问题，再让我们回过头来查看源码。\n出发吧，伟大的软件工程师啊！\n什么是文件系统，Hugo是怎么理解的？ # 管理人力的，我们叫人力系统；管理招聘的，我们叫招聘系统；那管理文件的，我们就叫文件系统。\n在基础架构 文件系统的组织中，我们有提到Hugo的文件系统是基于Afero库来构建的。\n那我们先来看看Afero是怎么定义文件系统的： 通过Hugo对文件系统的实际应用，我们可以发现主要用到了Afero中的两个接口，一个是Fs，另一个是Lstater。 前面一个就是文件系统了，包含打开文件，查询状态等文件相关的操作。 后面的状态机Lstater则在查询状态的后面加上了如果可能的字样，增强了适用性。\n那Afero在PathSpec中是怎么得到应用的呢？ 我们知道在创建依赖Deps之初，有将文件信息传入依赖配置项depsCfg中，这里是最原始的文件信息，虽然叫Fs，但并没有提供文件系统的功能。 真正开始组织和构建文件系统的是中间的BaseFs，不仅关联上初始的信息，还包含了文件系统收集完成后的SourceFilesystems。 里面的源文件系统SourceFilesystem都完整的实现了Afero中的Fs和Lstater接口。\n这里举一个实际的应用场景，来帮助理解： readAndProcessContent就是用来读取和处理站点内容的函数，将会在下一个章节渲染中进行介绍。 在这里，我们将用这个具体的场景，来帮助我们理解上面的文件系统BaseFs究竟是在为什么做准备。\n从上图可以看到，如果我们要开始处理站点内容了。 我们可以通过站点site实例，很容易的得到站点内容的文件系统。 而这个真实的文件系统，正是来自于BaseFs中的Content.Fs。\n拿到内容文件系统后，就可以创建好Walkway实例，并对其中的文件进行遍历Walk了。\nsite又是怎么持有BaseFs的？ 这个不是在PathSpec中吗？\n这里就要提到Golang的组合机制了，可以用组合的方式，对结构体进行拓展： 可以清晰地看到他们之间的关系就是Site -\u0026gt; Deps -\u0026gt; PathSpec -\u0026gt; BaseFs，就是有点长，容易迷失方向。\n在Walk的过程中，主要用到的就是Lstater中的LstatIfPossible方法。\n多个文件系统之间是如何关联的？ # 我们通过一个实际应用场景，了解到为什么要这样组织文件系统。\n从 基础架构的文件系统章节了解到了Hugo中复杂的文件系统： 虽然这张图能够从基础架构的角度出发，帮我们了解到文件系统是如何组织在一起的。 看起来有些复杂，但仍没能展示所有的文件系统之间的关联。 比如说，在BaseSpec中的SourceFilesystems里面，SourceFilesystem中的Fs究竟指的是哪些文件系统，和OverlayFs又有什么关联呢？\n上图则帮助解答了我们的疑问。 SourceFilesystems包含了Hugo自定义的六大组件，包含Content, Data, I18n, Layouts, Archetypes, Assets。 为每一个组件都提供了一个文件系统实例，类型为SourceFilesystem。 区别就在于里面的Fs字段所指向的文件系统。\n可以看到，Layouts, Archetypes, Assets都一样，都直接指向了BasePathFs，这也是Afero提供的文件系统之一，颜色也标的和Afero一致。 BasePathFs中的Fs实际指向的就是OverlayFs，可以看到她里面的Fs是复数Fss，也就是说有多个文件系统。 具体工作原理，稍后会做介绍。\n再看Data和I18n，指向的都是SliceFs，里面包含的实际是Dirs，也就是多目录，类型则是FileMetaInfo。 拿Data举例，Hugo将所有的数据都集中到一起，这样可以方便统一供页面使用，这样数据之间就不存在从属关系，项目模块里的数据和主题模块里的数据相对独立。\n最后看一下上面的场景中使用到的Content，她在BasePathFs上又封闭了一层，从命名看出提供了Filter的功能，因为针对不同的语言可能需要过滤掉一些其它的文件。\nModules和文件系统之间，又存在什么样的关系？ # 上面已经看到SourceFilesystems为每一个模块都创建了一个文件系统，那Module和文件系统又是怎么关联的呢？\nHugo的最终目的是构建站点，而一个站点中可能要用到多个模块，为了方便组织构建，模块又定义了六大组件。 在对外提供服务，如上面的站点内容处理场景中，需要对外隐藏文件系统里面的复杂性。 保证文件系统在使用过程中，就是一个整体。\n为了让使用者使用起来足够简单，Hugo需要将多模块合并，并保证文件之间正确地依赖关系。\n例如，在Hugo主题中会提供很多不同的layout模板，但如果在项目中也有一个重名的模板，则优先使用项目中的模板，因为这是用户自定义的模板，应优先使用。\n而在主题中数据文件需要保持独立，所以需要将所有模块的数据文件收集到一起，集中管理。\n为了满足这些依赖管理的诉求，Hugo选择使用OverlayFs技术来管理有依赖的文件上，直接用集合来对独立的文件进行管理。\n最终将所有模块的文件系统按依赖关系进行合并，由SourceFilesystems提供统一服务：\n什么是OverlayFs，为什么要用？ # 在组织PathSpec中的BaseFs过程中，我们了解到底层文件系统用的是OverlayFs。 和其它文件系统不一样的地方是，她的文件系统是Fss，表明需要同时持有多个文件系统。\n将Fss展开，我们得到了上图。\n从右边我们可以看出OverlayFs的工作原理：将多个文件系统按一定规则进行合并，合并后生成统一的文件系统服务。\n拿上图来做进一步解释。 从上往下看，merge层就是合并后生成的统一文件系统，包含了upper层和lower层的所有文件。 之所以叫upper和lower，是因为文件系统之间有明确的先后顺序关系，OverlayFs会优先选择更上层的文件，来生成合并过后的merge层。 如果多层都有同样的文件，就会优先选择最上面一层的这个文件，比如在上图中，upper层和lower层都有文件a.md，那就会优先选择upper层中的a.md。 如果没有重复，同样的原理，按层级选择最先出现的文件，放入到merge层，像b.md和c.md。\n回到PathSpec中，如上图左边所示。 我们有Project模块和mytheme主题模块，他们都有content文件系统。 这时Project模块是最上层模块，因为这是用户直接提供的内容，也可以理解为用户所提供的自定义信息，对应的就是右边的upper层。 而mytheme主题模块，则对应的是lower层。 如果用户想要自定义站点主页，可以直接在项目中提供相应的layout文件，这样就会覆盖掉主题中对应的layout文件。 合并后的merge层也就是我们之前提到的Fss。\n通过OverlayFs技术，Hugo这样就可以将多模块按需合并了。 并对调用方提供良好的用户体验。\n结合上面的样例，提供源码实现做进一步参考。\nShow me the code:\nOverlayFs OverlayFs Afero 什么是radix tree? # 将多文件系统有效地组织起来后，容易理解，也方便使用。 但组织好的文件系统只是开始，Hugo还需要对文件系统内的文件进行高效操作。 比如查找某一个文件，或者遍历某一路径下的所有文件。\n针对上面的诉求，Hugo选择了Radix Tree - 基数树。\n下面是 Wikipedia Radix tree的示例图：\n通过这一数据结构存储单词，不仅存储内容没有重复，提升了空间利用率；路径还清晰，提高了查询效率。\nHugo当然也不会错过：\n以上面OverlapFs的使用场景作为样例。 当插入第一条信息\u0026quot;/content/a.md\u0026quot;时，因为是第一个结点，没有和其它的结点拥有共同前缀，可以直接插入。 当插入后续结点\u0026quot;/content/b.md, /content/c.md\u0026quot;时，因为都拥有相同前缀\u0026quot;/content/\u0026quot;，首先要对老的结点进行更新。 先提取通用结点\u0026quot;/content/\u0026quot;，并更新老结点为\u0026quot;a.md\u0026quot;。 同时创建后面新加入的结点\u0026quot;b.md, c.md\u0026quot;。 最终状态为步骤二所展示的状态。\n结合上面的样例，可参考以下源码实现，自己动手试一试。\nShow me the code:\nRadix Tree 再来一起快速回顾一下这些问题：\n什么是文件系统，Hugo是怎么理解的？\n文件系统就是将多个文件进行系统管理的方法，Hugo用Afero定义了基础文件系统，除了文件系统的基础操作处，还用到了状态机Lstater。\n多个文件系统之间是如何关联的？\n文件系统源于OverlayFs，终于SourceFilesystems，目标就是为Hugo的各大组件提供属于自己的文件系统服务。\nModules和文件系统之间，又存在什么样的关系？\n模块包含了Hugo的通用组件，Hugo需要将多模块按通用组件为单位进行合并，统一途径对外提供服务。\n什么是OverlayFs，为什么要用？\n是一种可以把多文件系统组合成一个文件系统的技术。\n什么是radix tree?\n可以快速检索信息，并保证存储信息不重复的数据结构。\n对以上问题进行了解答后。 当我们再来看上面的PathSpec全景时序图，我们会发现脉络一下子清晰了起来：\n创建Path，将所有基础信息都包含其中 创建BaseFs，并装饰其中的文件系统 准备文件系统构建器 开始创建OverlayFs，准备好文件系统收集器 根据组件类型，按目录进行整理 根据整理好的目录信息，为组件分别创建属于自己的文件系统，并保存在构建结果中 基础知识就绪，流程脉络也梳理清楚。 接下来将流程进一步展开，结合源码来进一步理解Hugo的实现细节。\n源码实现 # 创建Path，将所有基础信息都包含其中\n第一步就是创建Path，我们再将时序图细节还原：\n可以看到Path将所有基础信息都汇集到一起了。\n其中包括最原始的文件系统信息Fs：\n// Fs holds the core filesystems used by Hugo. type Fs struct { // Source is Hugo\u0026#39;s source file system. // Note that this will always be a \u0026#34;plain\u0026#34; Afero filesystem: // * afero.OsFs when running in production // * afero.MemMapFs for many of the tests. Source afero.Fs // PublishDir is where Hugo publishes its rendered content. // It\u0026#39;s mounted inside publishDir (default /public). PublishDir afero.Fs // WorkingDirReadOnly is a read-only file system // restricted to the project working dir. WorkingDirReadOnly afero.Fs } 还有包含了用户自定义信息和Hugo的默认信息的Config Provider - Cfg。 接着就是ThemesDir, WorkingDir, AbsPublishDir这三个关键目录。 最后就是组织好的所有模块信息AllModules。\n最终创建的Path将包含创建PathSpec所包含的全部信息：\np := \u0026amp;Paths{ Fs: fs, Cfg: cfg, ThemesDir: cfg.GetString(\u0026#34;themesDir\u0026#34;), WorkingDir: workingDir, AbsPublishDir: absPublishDir, ... } if cfg.IsSet(\u0026#34;allModules\u0026#34;) { p.AllModules = cfg.Get(\u0026#34;allModules\u0026#34;).(modules.Modules) } 创建BaseFs，并装饰其中的文件系统\n准备好Path后，正式进入到创建基础文件系统的环节：\n可以看到，分别为publishDir，以及由fs.Source和p.WorkingDir组成的PathFs进行了统一装饰。\n先看BasePathFs:\n// The BasePathFs restricts all operations to a given path within an Fs. // The given file name to the operations on this Fs will be prepended with // the base path before calling the base Fs. // Any file name (after filepath.Clean()) outside this base path will be // treated as non existing file. // // Note that it does not clean the error messages on return, so you may // reveal the real path on errors. type BasePathFs struct { source Fs path string } 在提供源文件系统source的基础上，进一步指明了路径。 也就是对外只开放源文件系统特定路径下的文件服务。\n再看BaseFileDecorator：\n// NewBaseFileDecorator decorates the given Fs to provide the real filename // and an Opener func. func NewBaseFileDecorator(fs afero.Fs) afero.Fs { ffs := \u0026amp;baseFileDecoratorFs{Fs: fs} decorator := func(fi os.FileInfo, filename string) (os.FileInfo, error) { // Store away the original in case it\u0026#39;s a symlink. meta := NewFileMeta() meta.Name = fi.Name() ... opener := func() (afero.File, error) { return ffs.open(filename) } fim := decorateFileInfo(fi, ffs, opener, filename, \u0026#34;\u0026#34;, meta) return fim, nil } ffs.decorate = decorator return ffs } baseFileDecoratorFs就是装饰过后的文件信息，实现了Afero的Fs和Lstater接口。 和其它文件系统不同的是，baseFileDecoratorFs提供了一个装饰函数，在查询文件状态的时候都会被调用。\nfunc (fs *baseFileDecoratorFs) Stat(name string) (os.FileInfo, error) { fi, err := fs.Fs.Stat(name) ... return fs.decorate(fi, name) } func (fs *baseFileDecoratorFs) LstatIfPossible(name string) (os.FileInfo, bool, error) { ... if lstater, isLstater := fs.Fs.(afero.Lstater); isLstater { fi, ok, err = lstater.LstatIfPossible(name) } else { fi, err = fs.Fs.Stat(name) } ... fi, err = fs.decorate(fi, name) return fi, ok, err } 这就像钩子函数一样，在原始信息准备好后，触发装饰器，在返回信息前，对信息进行统一处理。 这样提供了足够的灵活性，也方便标准化服务信息。\n准备文件系统构建器\n将原始文件系统进行装饰，并将处理后的系统放入BaseFs实例中。 有了文件系统构建所需要的信息后，Hugo就开始着手构建了。\n先创建构建器：\nfunc newSourceFilesystemsBuilder(p *paths.Paths, b *BaseFs) *sourceFilesystemsBuilder { sourceFs := hugofs.NewBaseFileDecorator(p.Fs.Source) return \u0026amp;sourceFilesystemsBuilder{p: p, sourceFs: sourceFs, theBigFs: b.theBigFs, result: \u0026amp;SourceFilesystems{}} } 在构建器中，用到了Path，装饰过后的源文件系统p.Fs.Source，这些之前都出现过，相对好理解一些。\n而theBigFs第一次出现，直译过来就是大文件系统，从这个泛指的名字很难看出是干什么用的。\nSourceFileSystems类型的result较为直观，应该就是构建后的结果，包含了所有Hugo组件的文件系统集合。\ntype sourceFilesystemsBuilder struct { p *paths.Paths sourceFs afero.Fs result *SourceFilesystems theBigFs *filesystemsCollector } 通过sourceFilesystemsBuilder结构体的申明可以帮助理解新出现的theBigFs，原来是filesystemsCollector收集器。\n开始创建OverlayFs，准备好文件系统收集器\n准备好站点构建器后，就正式开始构建了。\n首先就是检查theBigFs是否设置好，如果没有，需要通过创建Main OverlayFs来给theBigFs赋值：\n// hugo-playground/hugolib/filesystems/basefs.go // line 454 if b.theBigFs == nil { theBigFs, err := b.createMainOverlayFs(b.p) ... b.theBigFs = theBigFs } 进入createMainOverlayFs可以看到Hugo是如何设计filesystemsCollector的：\n// hugo-playground/hugolib/filesystems/basefs.go // line 518 func (b *sourceFilesystemsBuilder) createMainOverlayFs(p *paths.Paths) (*filesystemsCollector, error) { collector := \u0026amp;filesystemsCollector{ ... overlayDirs: make(map[string][]hugofs.FileMetaInfo), overlayMounts: overlayfs.New(overlayfs.Options{}), overlayMountsContent: overlayfs.New(overlayfs.Options{DirsMerger: hugofs.LanguageDirsMerger}), overlayMountsStatic: overlayfs.New(overlayfs.Options{DirsMerger: hugofs.LanguageDirsMerger}), overlayFull: overlayfs.New(overlayfs.Options{}), overlayResources: overlayfs.New(overlayfs.Options{FirstWritable: true}), } // Module has same folder structure // need to merge, like static files mods := p.AllModules mounts := make([]mountsDescriptor, len(mods)) for i := 0; i \u0026lt; len(mods); i++ { mod := mods[i] dir := mod.Dir() isMainProject := mod.Owner() == nil mounts[i] = mountsDescriptor{ Module: mod, dir: dir, isMainProject: isMainProject, ordinal: i, } } err := b.createOverlayFs(collector, mounts) return collector, err } filesystemsCollector的思路很清晰。 首先为不同的收集内容准备好各自的容器，像overlayDirs，用来存放Dir的FileMetaInfo，用来存储所有Content OverlayFs的overlayMountsContent，等等。 然后将所有的模块AllModules转换成mountsDescriptor，根据mounts创建各自的OverlayFs，并放在上一步准备好的容器里。\ncreateOverlayFs源码如下所示：\n// hugo-playground/hugolib/filesystems/basefs.go // line 562 func (b *sourceFilesystemsBuilder) createOverlayFs( collector *filesystemsCollector, mounts []mountsDescriptor) error { for _, md := range mounts { var ( fromTo []hugofs.RootMapping fromToContent []hugofs.RootMapping fromToStatic []hugofs.RootMapping ) ... for i, mount := range md.Mounts() { ... base, filename := absPathify(mount.Source) rm := hugofs.RootMapping{ From: mount.Target, // content To: filename, // mycontent ToBasedir: base, Module: md.Module.Path(), IsProject: md.isMainProject, Meta: ..., } isContentMount := b.isContentMount(mount) ... if isContentMount { fromToContent = append(fromToContent, rm) } else if b.isStaticMount(mount) { fromToStatic = append(fromToStatic, rm) } else { fromTo = append(fromTo, rm) } } modBase := collector.sourceProject // source fs, project module ... rmfs, err := hugofs.NewRootMappingFs(modBase, fromTo...) ... rmfsContent, err := hugofs.NewRootMappingFs(modBase, fromToContent...) ... rmfsStatic, err := hugofs.NewRootMappingFs(sourceStatic, fromToStatic...) ... // TODO // addDirs // overlayMounts } return nil } 可以看出createOverlayFs进行了两层循环。 外层对module进行了循环，内层对mount里的mounts进行了循环。 内层为每一个mount都准备了一个RootMapping，并根据类型，分别放到fromToContent， fromToStatic， fromTo的集合中。 紧接着为每一个集合创建了一个RootMappingFs。 然后用创建好的RootMappingFs信息，统一对Dir和overlayMount进行处理。 这里让我们暂时先专注在NewRootMappingFs，下一章节我们将对上面的TODO内容进行展开。\n从时序图中，可以观察到正是在这里，Hugo引入了Radix Tree，用来管理补充了信息的RootMapping，并用模块名做为索引key进行存储。 最终返回包含Radix Tree实例的RootMappingFs。\n// hugo-playground/hugofs/rootmapping_fs.go // line 30 // NewRootMappingFs creates a new RootMappingFs on top of the provided with // root mappings with some optional metadata about the root. // Note that From represents a virtual root that maps to the actual filename in To. func NewRootMappingFs(fs afero.Fs, rms ...RootMapping) (*RootMappingFs, error) { rootMapToReal := radix.New() var virtualRoots []RootMapping for _, rm := range rms { ... rm.Meta.SourceRoot = rm.To rm.Meta.BaseDir = rm.ToBasedir rm.Meta.MountRoot = rm.path rm.Meta.Module = rm.Module rm.Meta.IsProject = rm.IsProject meta := rm.Meta.Copy() ... rm.fi = NewFileMetaInfo(fi, meta) key := filepathSeparator + rm.From // only /layouts and /content var mappings []RootMapping v, found := rootMapToReal.Get(key) ... mappings = append(mappings, rm) rootMapToReal.Insert(key, mappings) virtualRoots = append(virtualRoots, rm) } rootMapToReal.Insert(filepathSeparator, virtualRoots) rfs := \u0026amp;RootMappingFs{ Fs: fs, rootMapToReal: rootMapToReal, } return rfs, nil } 源码中rootMapToReal就是包含了所有RootMapping信息的Radix Tree。 这样一来，利用Radix Tree的特性，我们将很方便按前缀对文件进行走查。\n根据组件类型，按目录进行整理\nHugo首先将组件都以Mount的形式存储在Module中。 在创建OverlayFs的过程中，先将Mount转换成RootMapping，再由上面的NewRootMappingFs方法，将RootMapping转换成RootMappingFs内部的Radix Tree结构。\n接下来就让我们回到createOverlayFs中，来看看RootMappingFs将如何被使用。\n让我们实例TODO部分的addDirs和overlayMounts操作：\n// hugo-playground/hugolib/filesystems/basefs.go // line 562 func (b *sourceFilesystemsBuilder) createOverlayFs( collector *filesystemsCollector, mounts []mountsDescriptor) error { ... rmfs, err := hugofs.NewRootMappingFs(modBase, fromTo...) ... rmfsContent, err := hugofs.NewRootMappingFs(modBase, fromToContent...) ... rmfsStatic, err := hugofs.NewRootMappingFs(sourceStatic, fromToStatic...)\t... // We need to keep the ordered list of directories for watching and // some special merge operations (data, i18n). collector.addDirs(rmfs) // add other folders collector.addDirs(rmfsContent) // only has /content, why need to go through all components? collector.addDirs(rmfsStatic) getResourcesDir := func() string { if md.isMainProject { return b.p.AbsResourcesDir } _, filename := absPathify(files.FolderResources) return filename } collector.overlayMounts = collector.overlayMounts.Append(rmfs) collector.overlayMountsContent = collector.overlayMountsContent.Append(rmfsContent) collector.overlayMountsStatic = collector.overlayMountsStatic.Append(rmfsStatic) collector.overlayFull = collector.overlayFull.Append(afero.NewBasePathFs(modBase, md.dir)) collector.overlayResources = collector.overlayResources.Append(afero.NewBasePathFs(modBase, getResourcesDir())) } return nil } 将上面新增部分的代码对应上我们的时序图：\n在拿到创建好的RootMappingFs后，先对其收集了一波Dir，然后将其加入到相应的overlayMounts中。\n先来看addDirs：\n// hugo-playground/hugolib/filesystems/basefs.go // line 712 func (c *filesystemsCollector) addDirs(rfs *hugofs.RootMappingFs) { for _, componentFolder := range files.ComponentFolders { c.addDir(rfs, componentFolder) } } func (c *filesystemsCollector) addDir(rfs *hugofs.RootMappingFs, componentFolder string) { dirs, err := rfs.Dirs(componentFolder) if err == nil { // event dirs is nil // merge all the same component folder from different rfs in the same array c.overlayDirs[componentFolder] = append(c.overlayDirs[componentFolder], dirs...) } } 对Hugo所有的组件进行轮询，从RootMappingFs中获取Dirs，并添加到overlayDirs中。 让我们展开rfs.Dirs：\n// hugo-playground/hugofs/rootmapping_fs.go // line 165 func (fs *RootMappingFs) Dirs(base string) ([]FileMetaInfo, error) { base = filepathSeparator + fs.cleanName(base) roots := fs.getRootsWithPrefix(base) ... fss := make([]FileMetaInfo, len(roots)) for i, r := range roots { bfs := afero.NewBasePathFs(fs.Fs, r.To) ... fs := bfs ... fi, err := fs.Stat(\u0026#34;\u0026#34;) ... fss[i] = fi.(FileMetaInfo) } return fss, nil } 先通过RootMappingFs.getRootsWithPrefix来获取RootMapping，再获取根目录的Stat，最终返回所有目录的FileMetaInfo。\n// hugo-playground/hugofs/rootmapping_fs.go // line 292 func (fs *RootMappingFs) getRootsWithPrefix(prefix string) []RootMapping { var roots []RootMapping fs.rootMapToReal.WalkPrefix(prefix, func(b string, v any) bool { roots = append(roots, v.([]RootMapping)...) return false }) return roots } 在这里，用上了Radix Tree类型的rootMapToReal，通过走查组件前缀，查询存储在树上的根节点RootMapping信息。\n经过上面的处理后，addDirs就将所有组件根目录的FileMetaInfo都成功存储在了collector.overlayDirs中。\n那collector中的其它Mounts呢？\n... collector.overlayMounts = collector.overlayMounts.Append(rmfs) collector.overlayMountsContent = collector.overlayMountsContent.Append(rmfsContent) collector.overlayMountsStatic = collector.overlayMountsStatic.Append(rmfsStatic) collector.overlayFull = collector.overlayFull.Append(afero.NewBasePathFs(modBase, md.dir)) collector.overlayResources = collector.overlayResources.Append(afero.NewBasePathFs(modBase, getResourcesDir())) 将得到的RootMappingFs直接添加到overlay的不同Mounts中。\n// Append creates a shallow copy of the filesystem and appends the given filesystems to it. func (ofs OverlayFs) Append(fss ...afero.Fs) *OverlayFs { ofs.fss = append(ofs.fss, fss...) return \u0026amp;ofs } 并按顺序在放在了fss中。\n到这里，thyBigFs也就是Collector已经准备妥当，按模块收到到了所有的RootMappingFs，并将她们都依次放入了OverlayMounts和OverlayDirs中。\n根据整理好的目录信息，为组件分别创建属于自己的文件系统，并保存在构建结果中\n拿到准备就绪地收集器后，是时候开始为每一个组件生成自己的SourceFilesystem了：\n从时序图中可以看出，拿到theBigFs后，就开始着手准备构建结果SourceFilesystems了。\n通过构建方式可以分为三类：\nData和I18N为一类\n// hugo-playground/hugolib/filesystems/basefs.go // line 479 // Data, i18n and content cannot use the overlay fs dataDirs := b.theBigFs.overlayDirs[files.ComponentFolderData] dataFs, err := hugofs.NewSliceFs(dataDirs...) if err != nil { return nil, err } b.result.Data = b.newSourceFilesystem(files.ComponentFolderData, dataFs, dataDirs) 直接从overlayDirs中通过组件键值获取相应的文件信息，并用SliceFs进行封装\nLayouts, Archetypes, Assets为一类\n// hugo-playground/hugolib/filesystems/basefs.go // line 464 createView := func(componentID string) *SourceFilesystem { if b.theBigFs == nil || b.theBigFs.overlayMounts == nil { return b.newSourceFilesystem(componentID, hugofs.NoOpFs, nil) } dirs := b.theBigFs.overlayDirs[componentID] return b.newSourceFilesystem(componentID, afero.NewBasePathFs(b.theBigFs.overlayMounts, componentID), dirs) } b.result.Layouts = createView(files.ComponentFolderLayouts) 从overlayDirs中获取目录信息，并用overlayMounts找到相应的OverlayFs，一起生成SourceFilesystem。\nContent为一类\n// hugo-playground/hugolib/filesystems/basefs.go // line 495 contentDirs := b.theBigFs.overlayDirs[files.ComponentFolderContent] contentBfs := afero.NewBasePathFs(b.theBigFs.overlayMountsContent, files.ComponentFolderContent) contentFs, err := hugofs.NewLanguageFs(b.p.LanguagesDefaultFirst.AsOrdinalSet(), contentBfs) if err != nil { return nil, fmt.Errorf(\u0026#34;create content filesystem: %w\u0026#34;, err) } b.result.Content = b.newSourceFilesystem(files.ComponentFolderContent, contentFs, contentDirs) 和上面相比，在BasePathFs前又多加了一层LanguageFs，并且直接用到了overlayMountsContent。\n这样，我们通过基础知识介绍，加上时序图局部拆解，就梳理完了PathSpec的完整创建流程。\n抽象总结 - 输入文件系统和所有模块信息，输出各组件统一文件系统 # 在创建Deps的过程中，第一个创建的就是PathSpec。 在这之前，我们已经准备好了配置信息，其中包含了所有的模块信息。 PathSpec正是要将所有模块的信息，统一管理，按Hugo对文件系统的要求，将所有的模块按组件组合起来，对外提供统一类型的服务。\nHugo的实现思路，正如上图中间部分所示。 先将前面准备好的基础信息，如原始Fs，和包含了所有模块信息的AllModules，都放在Path之中。 想要获得最终的结果，还需要一个构建器Builder。 Builder首先准备好承载构建中间状态的容器，如OverlayDirs，OverlayMounts。 然后用Collector也就是我们的theBigFs，将所有Module中的Mount转换成RootMapping，并转换成RootMappingFs做好准备。 因为在创建OverlayFs的时候，需要将不同横块相同组件的RootMappingFs按顺序放在Fss中。 当这些基础信息都准备好后，就可以为每个组件构建自己的SourceFilesystem了，最终组合成SourceFilesystems，也就是PathSpec中的BaseFs。 既标准统一的文件系统集合。\n动手实践 - Show Me the Code of PathSpec # 在理解PathSpec的实现原理后，通过抽象总结，我们将其进行简化。 照葫芦画瓢，动动小手，让我们用代码来总结代码，验证一下这个知识点。\n可以这里线上尝试， Show Me the Code, try it yourself\n代码里有注解说明，代码样例：\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/overlayfs\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/radixtree\u0026#34; \u0026#34;golang.org/x/tools/txtar\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { dir, _ := os.MkdirTemp(\u0026#34;\u0026#34;, \u0026#34;hugo\u0026#34;) defer os.RemoveAll(dir) myContentPath := filepath.Join(dir, \u0026#34;mycontent\u0026#34;) _ = os.Mkdir(myContentPath, os.ModePerm) myContent2Path := filepath.Join(dir, \u0026#34;mycontent2\u0026#34;) _ = os.Mkdir(myContent2Path, os.ModePerm) themePath := filepath.Join(dir, \u0026#34;mytheme\u0026#34;) _ = os.Mkdir(themePath, os.ModePerm) mcs := \u0026#34;-- a.md --\\n\u0026#34; + \u0026#34;mycontent: a\\n\u0026#34; + \u0026#34;-- c.md --\\n\u0026#34; + \u0026#34;mycontent: c\u0026#34; writeFiles(mcs, myContentPath) mc2s := \u0026#34;-- a.md --\\n\u0026#34; + \u0026#34;mycontent2: a\\n\u0026#34; + \u0026#34;-- d.md --\\n\u0026#34; + \u0026#34;mycontent2: d\u0026#34; writeFiles(mc2s, myContent2Path) ts := \u0026#34;-- a.md --\\n\u0026#34; + \u0026#34;mytheme: a\\n\u0026#34; + \u0026#34;-- b.md --\\n\u0026#34; + \u0026#34;mytheme: b\u0026#34; writeFiles(ts, themePath) p := \u0026amp;Paths{ WorkingDir: dir, AllModules: []Module{ { ProjectMod: true, Dir: dir, Mounts: []Mount{ {Source: \u0026#34;mycontent\u0026#34;, Target: \u0026#34;content\u0026#34;}, {Source: \u0026#34;mycontent2\u0026#34;, Target: \u0026#34;content\u0026#34;}, }, }, { ProjectMod: false, Dir: dir, Mounts: []Mount{ {Source: \u0026#34;mytheme\u0026#34;, Target: \u0026#34;content\u0026#34;}, }, }, }, } collector := \u0026amp;filesystemsCollector{ overlayMountsContent: overlayfs.New( []overlayfs.AbsStatFss{}), } createOverlayFs(collector, p) var f fs.File fis, _ := collector. overlayMountsContent.ReadDir(filepathSeparator) for _, fi := range fis { fmt.Println(fi.Name()) f, _ = collector. overlayMountsContent.Open(fi.Name()) b, _ := io.ReadAll(f) fmt.Println(string(b)) } defer f.Close() } func writeFiles(s string, dir string) { data := txtar.Parse([]byte(s)) for _, f := range data.Files { if err := os.WriteFile( filepath.Join(dir, f.Name), bytes.TrimSuffix(f.Data, []byte(\u0026#34;\\n\u0026#34;)), os.ModePerm); err != nil { panic(err) } } } var filepathSeparator = string(filepath.Separator) // RootMapping describes a virtual file or directory mount. type RootMapping struct { // The virtual mount. From string // The source directory or file. To string // The base of To. May be empty if an // absolute path was provided. ToBasedir string // Whether this is a mount in the main project. IsProject bool // The virtual mount point, e.g. \u0026#34;blog\u0026#34;. path string } type Mount struct { Source string Target string } type Module struct { ProjectMod bool Mounts []Mount Dir string } type Modules []Module type Paths struct { AllModules Modules WorkingDir string } // A RootMappingFs maps several roots into one. // Note that the root of this filesystem // is directories only, and they will be returned // in Readdir and Readdirnames // in the order given. type RootMappingFs struct { fs overlayfs.AbsStatFss rootMapToReal *radixtree.Tree } type filesystemsCollector struct { overlayMountsContent *overlayfs.OverlayFs } func createOverlayFs( collector *filesystemsCollector, path *Paths) { for _, md := range path.AllModules { var fromToContent []RootMapping for _, mount := range md.Mounts { rm := RootMapping{ From: mount.Target, // content To: mount.Source, // mycontent ToBasedir: md.Dir, IsProject: md.ProjectMod, } fromToContent = append(fromToContent, rm) } rmfsContent := newRootMappingFs(fromToContent...) collector.overlayMountsContent = collector. overlayMountsContent.Append(rmfsContent) } return } // NewRootMappingFs creates a new RootMappingFs // on top of the provided with root mappings with // some optional metadata about the root. // Note that From represents a virtual root // that maps to the actual filename in To. func newRootMappingFs( rms ...RootMapping) *RootMappingFs { t := radixtree.New() var virtualRoots []RootMapping for _, rm := range rms { key := filepathSeparator + rm.From mappings := getRms(t, key) mappings = append(mappings, rm) t.Insert(key, mappings) virtualRoots = append(virtualRoots, rm) } t.Insert(filepathSeparator, virtualRoots) return \u0026amp;RootMappingFs{ rootMapToReal: t, } } func (m *RootMappingFs) Abs(name string) []string { mappings := getRms(m.rootMapToReal, name) var paths []string for _, m := range mappings { paths = append(paths, path.Join( m.ToBasedir, m.To)) } return paths } func (m *RootMappingFs) Fss() []fs.StatFS { mappings := getRms( m.rootMapToReal, filepathSeparator) var fss []fs.StatFS for _, m := range mappings { fss = append(fss, os.DirFS( path.Join(m.ToBasedir, m.To)).(fs.StatFS)) } return fss } func getRms(t *radixtree.Tree, key string) []RootMapping { var mappings []RootMapping v, found := t.Get(key) if found { mappings = v.([]RootMapping) } return mappings } 输出样例：\na.md mycontent: a b.md mytheme: b c.md mycontent: c d.md mycontent2: d Program exited. "},{"id":8,"href":"/docs/code/%E6%9E%84%E5%BB%BA/","title":"构建","section":"源码实现","content":" Build源码分析 # 站点已经准备就绪，所有的依赖都已经各就各位。 从 事件风暴的主流程来看，接下来是时候进行最终构建了：\n跬步千里 - Build源码实现 # 在事件风暴中我们已经看到了构建的详细流程：\n接下来，让我们从源码实现的角度来进一步分析。\n了然于胸 - Build时序图 # 很清晰的三步：\nprocess：将文件系统的文件，有序地添加到内容图谱中。 assemble：将内容图谱转换成页面图谱，为每一个内容图谱中的结点创建页面，包括首页、章节等结构页面。 render：根据模板以及页面信息，进行最终站点渲染。 Process时序图 # 从中间可以看到，在开始处理之前，Site进行了初始化，以做好处理的准备。 开始处理内容时，先创建了资源规范NewSourceSpec，正是后续组件所要处理的内容。 紧接着创建页面处理器PagesProcessor和PagesCollector。 然后由收集器，从目录开始收集。\n在 基础架构中，有对处理流程进行介绍。 通过明确的分工，高效的协作，最终将所有文件分门别类，规整地放在中心货架上。\n现在我们来看看具体地实现思路和细节。\n先来举个例子：\n比如我们有两组数据要进行处理，一组是整型，一组是字符型。 我们需要一个来统筹管理的，分发任务。 还需要具体来处理信息的，一个整型处理器，一个字符型处理器。 为了让处理器之前紧密配合，就需要对处理流程进行统一。 可以看到总共分为三步，分别是开始、处理和等待。 这样在不同的阶段，负责协调的PagesProcessor就可以让其它的处理器各就各位，等待明确的信息就行。 其中在开始阶段，整型处理器和字符型处理器就已经准备好。 等待协调处理器发送具体处理对象了，这里用到了golang的频道作为信息传输通道。\n页面是处理完成了，那我们的货架又长什么样，处理好的内容需要如何摆在这些货架上呢？\nHugo给这个货架取的名字是contentMap。 包含了好几颗树：pages tree, sections tree, resources tree。 没错，contentMap就是这些树的集合：\ntype contentMap struct { // View of regular pages, sections, and taxonomies. pageTrees contentTrees // View of pages, sections, taxonomies, and resources. bundleTrees contentTrees // Stores page bundles keyed by its path\u0026#39;s directory or the base filename, // e.g. \u0026#34;blog/post.md\u0026#34; =\u0026gt; \u0026#34;/blog/post\u0026#34;, \u0026#34;blog/post/index.md\u0026#34; =\u0026gt; \u0026#34;/blog/post\u0026#34; // These are the \u0026#34;regular pages\u0026#34; and all of them are bundles. pages *contentTree // Section nodes. sections *contentTree // Resources stored per bundle below a common prefix, e.g. \u0026#34;/blog/post__hb_\u0026#34;. resources *contentTree } 其中pageTrees和bundleTrees又是树的集合：\nfunc newContentMap() *contentMap { m := \u0026amp;contentMap{ pages: \u0026amp;contentTree{Name: \u0026#34;pages\u0026#34;, Tree: radix.New()}, sections: \u0026amp;contentTree{Name: \u0026#34;sections\u0026#34;, Tree: radix.New()}, resources: \u0026amp;contentTree{Name: \u0026#34;resources\u0026#34;, Tree: radix.New()}, } m.pageTrees = []*contentTree{ m.pages, m.sections, } m.bundleTrees = []*contentTree{ m.pages, m.sections, } return m } 是为了方便后续的统一操作。\n结合这些信息，再回过头来看上面的样例。\n我们的目的是用contentMap组织好文件系统里的文件。 在示例中，contentMap可以将页面和资源有效的组织在一起，像header和resources。 其中\u0026quot;blog/a/index.md\u0026quot;是一个页面，\u0026ldquo;blog/a/b/data.json\u0026quot;和\u0026quot;blog/a/logo.png\u0026quot;都是资源文件，一个是数据类型，一个是图片类型。 最终都会以contentNode的形式，添加到对应的树中。 其中section tree也新增了一个结点，虽然没有相应的文件信息(fi: nil)，但path信息是\u0026rdquo;/blog/\u0026quot;。\n树的数据结构是基数树，如何将识别到的信息放入相应的位置，则属于Hugo的领域知识。\n比如Section的定义: sections。 第一级目录就是section，这是为什么\u0026quot;/blog/\u0026ldquo;会出现在章节树的结点中。 还有一种情况也属于章节，那主是任何包含了\u0026rdquo;_index.后缀\u0026quot;格式文件的目录，也属于章节。 同时Hugo管这种结构叫 Branch Bundles。 直译就是分支。 那为什么要这样组织？ 实际上是由Web 站点结构定义的。 Web站点的页面结构就是树状的。 有主页，了就是home page，还有不同的章节，如关于页面about page，它们都是从树根主页拓展开来的。\n从站点结构就可以看出，站点页面有像主页，章节这样的索引页面，也有像某一篇博客这样的内容页面。 Hugo管前者叫 List Page，后者则是普通页面。 在站点主题的模板中，都有对应的模板，像layouts/_default/list.html，layouts/posts/single.html。\nHugo正是根据站点的这些规律，按自己的理解，抽象出了List Page, Branch Bundle等等这些概念，将信息组织在了一起，并放入ContentMap中。\n再结合我们一直所使用的实例来检验一下：\n动手实践 - Show Me the Code of Build process # package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) func main() { s := \u0026amp;set{elements: []string{}} p := newPagesProcessor(s) p.Start(context.Background()) defer func() { err := p.Wait() if err != nil { fmt.Println(err) } }() data := []any{1, \u0026#34;hello\u0026#34;, 2, 3, 4, 5, 6, \u0026#34;world\u0026#34;, \u0026#34;happy\u0026#34;} for _, d := range data { err := p.Process(d) time.Sleep(1 * time.Millisecond) if err != nil { fmt.Println(err) return } } fmt.Println(s) } type set struct { elements []string } func (s *set) Add(element string) { s.elements = append(s.elements, element) } type pageProcessor interface { Process(item any) error Start(ctx context.Context) context.Context Wait() error } func newPagesProcessor(s *set) *pagesProcessor { ps := make(map[string]pageProcessor) ps[\u0026#34;i\u0026#34;] = \u0026amp;intProcessor{processor{ s: s, itemChan: make(chan interface{}, 2), }} ps[\u0026#34;s\u0026#34;] = \u0026amp;stringProcessor{processor{ s: s, itemChan: make(chan interface{}, 2), }} return \u0026amp;pagesProcessor{processors: ps} } type pagesProcessor struct { processors map[string]pageProcessor } func (p *pagesProcessor) Process(item any) error { switch v := item.(type) { // Page bundles mapped to their language. case int: err := p.processors[\u0026#34;i\u0026#34;].Process(v) if err != nil { return err } case string: err := p.processors[\u0026#34;s\u0026#34;].Process(v) if err != nil { return err } default: panic(fmt.Sprintf( \u0026#34;unrecognized item type in Process: %T\u0026#34;, item)) } return nil } func (p *pagesProcessor) Start( ctx context.Context) context.Context { for _, proc := range p.processors { ctx = proc.Start(ctx) } return ctx } func (p *pagesProcessor) Wait() error { var err error for _, proc := range p.processors { if e := proc.Wait(); e != nil { err = e } } return err } type processor struct { s *set ctx context.Context itemChan chan any itemGroup *errgroup.Group } func (p *processor) Process(item any) error { select { case \u0026lt;-p.ctx.Done(): return nil default: p.itemChan \u0026lt;- item } return nil } func (p *processor) Start(ctx context.Context) context.Context { p.itemGroup, ctx = errgroup.WithContext(ctx) p.ctx = ctx return ctx } func (p *processor) Wait() error { close(p.itemChan) return p.itemGroup.Wait() } type intProcessor struct { processor } func (i *intProcessor) Start( ctx context.Context) context.Context { ctx = i.processor.Start(ctx) i.processor.itemGroup.Go(func() error { for item := range i.processor.itemChan { if err := i.doProcess(item); err != nil { return err } } return nil }) return ctx } func (i *intProcessor) doProcess(item any) error { switch v := item.(type) { case int: i.processor.s.Add(strconv.Itoa(v)) default: panic(fmt.Sprintf( \u0026#34;unrecognized item type in intProcess: %T\u0026#34;, item)) } return nil } type stringProcessor struct { processor } func (i *stringProcessor) Start( ctx context.Context) context.Context { ctx = i.processor.Start(ctx) i.processor.itemGroup.Go(func() error { for item := range i.processor.itemChan { if err := i.doProcess(item); err != nil { return err } } return nil }) return ctx } func (i *stringProcessor) doProcess(item any) error { switch v := item.(type) { case string: i.processor.s.Add(v) default: panic(fmt.Sprintf( \u0026#34;unrecognized item type in stringProcessor: %T\u0026#34;, item)) } return nil } 输出样例：\n\u0026amp;{[1 hello 2 3 4 5 6 world happy]} Program exited. Build Processor线上可直接运行版本 Assemble # Assemble所做的事情很纯粹，那就是创建站点页面实例 - pageState。 因为支持多站点，contentMaps有多个。 所以Assemble不仅要创建pageState，还需要管理好所有的pages，这就用到了PageMaps。\ntype pageMap struct { s *Site *contentMap } type pageMaps struct { workers *para.Workers pmaps []*pageMap } 实际上pageMap就是由contentMap组合而来的。 而contentMap中的组成树的结点就是contentNode。\n正好，每个contentNode又对应一个pageState。\ntype contentNode struct { p *pageState // Set if source is a file. // We will soon get other sources. fi hugofs.FileMetaInfo // The source path. Unix slashes. No leading slash. path string ... } 所以Assemble不仅要为前面Process处理过生成的contentNode创建pageState，还要补齐一些缺失的contentNode，如Section。\nPageState # 可以看出，Assemble的重点就是组建PageState，那她到底长啥样：\ntype pageState struct { // This slice will be of same length as the number of global slice of output // formats (for all sites). pageOutputs []*pageOutput // This will be shifted out when we start to render a new output format. *pageOutput // Common for all output formats. *pageCommon ... } 从注解中可以看出普通信息将由pageCommon提供，而输出信息则由pageOutput提供。 比较特殊的是pageOutputs，是pageOutput的数组。 在 基础架构中，对这一点有作分析。 这要归因于Hugo的多站点渲染策略 - 允许在不同的站点中重用其它站点的页面。\n// hugo-playground/hugolib/page__new.go // line 97 // Prepare output formats for all sites. // We do this even if this page does not get rendered on // its own. It may be referenced via .Site.GetPage and // it will then need an output format. ps.pageOutputs = make([]*pageOutput, len(ps.s.h.renderFormats)) 那在Assemble中Hugo是如何组织pageState实例的呢？\n从上图中，可以看出Assemble阶段主要是新建pageState。 其中pageOutput在这一阶段只是一个占位符，空的nopPageOutput。 pageCommon则是在这一阶段给赋予了很多的信息，像meta相关的信息，及各种细节信息的providers。\n动手实践 - Show Me the Code of Create a PageState # package main import ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; ) func main() { outputFormats := createOutputFormats() renderFormats := initRenderFormats(outputFormats) s := \u0026amp;site{ outputFormats: outputFormats, renderFormats: renderFormats, } ps := \u0026amp;pageState{ pageOutputs: nil, pageOutput: nil, pageCommon: \u0026amp;pageCommon{m: \u0026amp;pageMeta{kind: KindPage}}, } ps.init(s) // prepare ps.pageOutput = ps.pageOutputs[0] // render fmt.Println(ps.targetPaths().TargetFilename) fmt.Println(ps.Content()) fmt.Println(ps.m.kind) } type site struct { outputFormats map[string]Formats renderFormats Formats } type pageState struct { // This slice will be of same length as the number of global slice of output // formats (for all sites). pageOutputs []*pageOutput // This will be shifted out when we start to render a new output format. *pageOutput // Common for all output formats. *pageCommon } func (p *pageState) init(s *site) { pp := newPagePaths(s) p.pageOutputs = make([]*pageOutput, len(s.renderFormats)) for i, f := range s.renderFormats { ft, found := pp.targetPaths[f.Name] if !found { panic(\u0026#34;target path not found\u0026#34;) } providers := struct{ targetPather }{ft} po := \u0026amp;pageOutput{ f: f, pagePerOutputProviders: providers, ContentProvider: nil, } contentProvider := newPageContentOutput(po) po.ContentProvider = contentProvider p.pageOutputs[i] = po } } func newPageContentOutput(po *pageOutput) *pageContentOutput { cp := \u0026amp;pageContentOutput{ f: po.f, } initContent := func() { cp.content = template.HTML(\u0026#34;\u0026lt;p\u0026gt;hello content\u0026lt;/p\u0026gt;\u0026#34;) } cp.initMain = func() { initContent() } return cp } func newPagePaths(s *site) pagePaths { outputFormats := s.renderFormats targets := make(map[string]targetPathsHolder) for _, f := range outputFormats { target := \u0026#34;/\u0026#34; + \u0026#34;blog\u0026#34; + \u0026#34;/\u0026#34; + f.BaseName + \u0026#34;.\u0026#34; + f.MediaType.SubType paths := TargetPaths{ TargetFilename: target, } targets[f.Name] = targetPathsHolder{ paths: paths, } } return pagePaths{ targetPaths: targets, } } type pagePaths struct { targetPaths map[string]targetPathsHolder } type targetPathsHolder struct { paths TargetPaths } func (t targetPathsHolder) targetPaths() TargetPaths { return t.paths } type pageOutput struct { f Format // These interface provides the functionality that is specific for this // output format. pagePerOutputProviders ContentProvider // May be nil. cp *pageContentOutput } // pageContentOutput represents the Page content for a given output format. type pageContentOutput struct { f Format initMain func() content template.HTML } func (p *pageContentOutput) Content() any { p.initMain() return p.content } // these will be shifted out when rendering a given output format. type pagePerOutputProviders interface { targetPather } type targetPather interface { targetPaths() TargetPaths } type TargetPaths struct { // Where to store the file on disk relative to the publish dir. OS slashes. TargetFilename string } type ContentProvider interface { Content() any } type pageCommon struct { m *pageMeta } type pageMeta struct { // kind is the discriminator that identifies the different page types // in the different page collections. This can, as an example, be used // to to filter regular pages, find sections etc. // Kind will, for the pages available to the templates, be one of: // page, home, section, taxonomy and term. // It is of string type to make it easy to reason about in // the templates. kind string } func initRenderFormats( outputFormats map[string]Formats) Formats { return outputFormats[KindPage] } func createOutputFormats() map[string]Formats { m := map[string]Formats{ KindPage: {HTMLFormat}, } return m } const ( KindPage = \u0026#34;page\u0026#34; ) var HTMLType = newMediaType(\u0026#34;text\u0026#34;, \u0026#34;html\u0026#34;) // HTMLFormat An ordered list of built-in output formats. var HTMLFormat = Format{ Name: \u0026#34;HTML\u0026#34;, MediaType: HTMLType, BaseName: \u0026#34;index\u0026#34;, } func newMediaType(main, sub string) Type { t := Type{ MainType: main, SubType: sub, Delimiter: \u0026#34;.\u0026#34;} return t } type Type struct { MainType string `json:\u0026#34;mainType\u0026#34;` // i.e. text SubType string `json:\u0026#34;subType\u0026#34;` // i.e. html Delimiter string `json:\u0026#34;delimiter\u0026#34;` // e.g. \u0026#34;.\u0026#34; } type Format struct { // The Name is used as an identifier. Internal output formats (i.e. HTML and RSS) // can be overridden by providing a new definition for those types. Name string `json:\u0026#34;name\u0026#34;` MediaType Type `json:\u0026#34;-\u0026#34;` // The base output file name used when not using \u0026#34;ugly URLs\u0026#34;, defaults to \u0026#34;index\u0026#34;. BaseName string `json:\u0026#34;baseName\u0026#34;` } type Formats []Format 输出结果：\n/blog/index.html \u0026lt;p\u0026gt;hello content\u0026lt;/p\u0026gt; page Program exited. PageState线上可直接运行版本 Render # 基础信息是由pageCommon提供了，那渲染过程中的输出由谁提供呢？\n没错，轮到pageOutput了：\n可以看到，在render阶段，pageState的pageOutput得到了最终的处理，为发布做准备了。 为了发布，最重的信息是发布什么，以及发布到哪里去。 这些信息都在pageOutput中，其中ContentProvider是提供发布内容的，而targetPathsProvider则是提供发布地址信息的。 其中地址信息主要来源于PagePath，这又和站点的RenderFormats和OutputFormats相关，哪下图所示：\n其中OutputFormats, RenderFormats及PageOutput之间的关系有在 基础架构中有详细提到，这里就不再赘述。\n// We create a pageOutput for every output format combination, even if this // particular page isn\u0026#39;t configured to be rendered to that format. type pageOutput struct { ... // These interface provides the functionality that is specific for this // output format. pagePerOutputProviders page.ContentProvider page.TableOfContentsProvider page.PageRenderProvider // May be nil. cp *pageContentOutput } 其中pageContentOutput正是实现了ContentProvider接口的实例。 其中有包含markdown文件原始信息的workContent字段，以及包含处理过后的内容content字段。 如Hugo Shortcode特性。 就是在这里经过contentToRender方法将原始信息进行处理，而最终实现的。\n动手实践 - Show Me the Code of Publish # package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) // publisher needs to know: // 1: what to publish // 2: where to publish func main() { // 1 // src is template executed result // it is the source that we need to publish // take a look at template executor example // https://c.sunwei.xyz/template-executor.html src := \u0026amp;bytes.Buffer{} src.Write([]byte(\u0026#34;template executed result\u0026#34;)) b := \u0026amp;bytes.Buffer{} transformers := createTransformerChain() if err := transformers.Apply(b, src); err != nil { fmt.Println(err) return } dir, _ := os.MkdirTemp(\u0026#34;\u0026#34;, \u0026#34;hugo\u0026#34;) defer os.RemoveAll(dir) // 2 // targetPath is from pageState // this is where we need to publish // take a look at page state example // https://c.sunwei.xyz/page-state.html targetPath := filepath.Join(dir, \u0026#34;index.html\u0026#34;) if err := os.WriteFile( targetPath, bytes.TrimSuffix(b.Bytes(), []byte(\u0026#34;\\n\u0026#34;)), os.ModePerm); err != nil { panic(err) } fmt.Println(\u0026#34;1. what to publish: \u0026#34;, string(b.Bytes())) fmt.Println(\u0026#34;2. where to publish: \u0026#34;, dir) } func (c *Chain) Apply(to io.Writer, from io.Reader) error { fb := \u0026amp;bytes.Buffer{} if _, err := fb.ReadFrom(from); err != nil { return err } tb := \u0026amp;bytes.Buffer{} ftb := \u0026amp;fromToBuffer{from: fb, to: tb} for i, tr := range *c { if i \u0026gt; 0 { panic(\u0026#34;switch from/to and reset to\u0026#34;) } if err := tr(ftb); err != nil { continue } } _, err := ftb.to.WriteTo(to) return err } func createTransformerChain() Chain { transformers := NewEmpty() transformers = append(transformers, func(ft FromTo) error { content := ft.From().Bytes() w := ft.To() tc := bytes.Replace( content, []byte(\u0026#34;result\u0026#34;), []byte(\u0026#34;transferred result\u0026#34;), 1) _, _ = w.Write(tc) return nil }) return transformers } // Chain is an ordered processing chain. The next transform operation will // receive the output from the previous. type Chain []Transformer // Transformer is the func that needs to be implemented by a transformation step. type Transformer func(ft FromTo) error // FromTo is sent to each transformation step in the chain. type FromTo interface { From() BytesReader To() io.Writer } // BytesReader wraps the Bytes method, usually implemented by bytes.Buffer, and an // io.Reader. type BytesReader interface { // Bytes The slice given by Bytes is valid for use only until the next buffer modification. // That is, if you want to use this value outside of the current transformer step, // you need to take a copy. Bytes() []byte io.Reader } // NewEmpty creates a new slice of transformers with a capacity of 20. func NewEmpty() Chain { return make(Chain, 0, 2) } // Implements contentTransformer // Content is read from the from-buffer and rewritten to to the to-buffer. type fromToBuffer struct { from *bytes.Buffer to *bytes.Buffer } func (ft fromToBuffer) From() BytesReader { return ft.from } func (ft fromToBuffer) To() io.Writer { return ft.to } 输出结果：\n1. what to publish: template executed transferred result 2. where to publish: /tmp/hugo2834984546 Program exited. Publish线上可直接运行版本 "},{"id":9,"href":"/docs/code/%E6%9E%84%E5%BB%BA/%E6%A8%A1%E6%9D%BF/","title":"Index","section":"构建","content":" Template executor # Deps在准备好NewPathSpec，NewSpec，NewContentSpec，NewSourceSpec后，调用onCreate正式创建HugoSites，并在最后一步，加载模板执行器。\n模板执行器只是提前将模板信息转换成了模板执行器，如何使用并没有涉及到。\n为了让我们对模板生命周期有更全面的了解，让我们以robots.txt为例，来看看是如何通过模板执行器生成最终文件的。\n了然于胸 - newTemplateExec时序图 # 从时序图中，可以了解到创建执行器，主要分两步。\n先创建包含了各种功能函数的executor。 其中的功能函数由两部分组成，一部分来自hugo，像htmlEscape等。 另一部分来自于golang的内置函数，如fmt.Sprint等等。 正是因为有这些功能函数的支持，才得以让模板的action块 - \u0026lsquo;{{}}\u0026lsquo;功能如此强大。\n执行器创建好后，接下来就要创建模板的handler了。 处理器提供了模板加载、查询等相关的服务，以方便使用。 因为查询服务依赖于加载服务，所以在处理器实例后，紧接着就是加载模板了。 而模板又分两部分，一部分是由hugo提供的默认模板，像robot.txt等。 另一部分就是由用户所提供的layouts文件，有来于主题的，也有来于用户自定义的layout。\n加载的是磁盘文件，得到的是解析过后的模板实例。\ntempl, err := prototype.New(info.name).Parse(info.template) 源码里用的是prototype，而不是直接用的html。 这是因为我们的模板有两种后缀，一种是txt，另一种是html，需要找到相应的原型来对模板进行解析。\n不管是什么模板，都是文本，HTML也不例外，也是文本。 HTML模板的源码也应证了这一点 - 直接调用文本模板的方法。 那这种关系是如何用代码实现的呢？\n拿到模板字节信息后，用词法分析器对模板字节流进行解析，得到分析好的词义结构。 对于HTML模板而言，为了安全，需要对词义结构进行检查和必要地修改。 因为我们可以从不同渠道，获得不同的主题，这些主题中又包含了很多模板，并且主题中可以嵌套主题，为了保证安全，避免执行恶意代码。 最后就是执行解析好的模板。\n为了方便理解，我们来举个例子 - robot.txt模板使用流程：\n查找：通过名字查找，调用templateExec中的handler查询方法LookupLayout进行查询。 执行：准备执行模板所需要的信息，调用templateExec中的executor执行方法ExecuteWithContext开始执行。 这里的执行方法实际上也是由text template提供的，前面咱们也提到了，不管是什么类型的模板，都是以text为基础的。 知道了工作流程后，让我们从源码层面，更深入的对Template进行理解。\n我们先来看第一步： 模板解析。\n词法解析 - parse # 创建Deps的最后一步是loadResources，其中主要指的是Template资源。 在创建templateExec实例的过程中，就需要加载hugo默认和用户创建的模板。 加载模板后，获取了模板的字节信息，要想为我们所有，首先要读懂这些字节，这时，我们就用到了解析Parse，而且是由text模板提供的。 Parse为什么可以读懂这些字符信息呢，她依靠的是内部了词法分析器lex - lexer，分析器需要对action block的语义有充分的理解。 读懂后转换为方便后续操作的数据结构tree，在hugo中实际载体是listNode类型。\n我们拿一段模板举个例子：\n从上例中，我们可以看到，左上方是输入的信息。 包含一篇博客 - post.md，和一个模板 - single.html。 通过转换会得到最右边的输出网页内容。 其中，包含在模板中第一行的信息，剩下的是由博客提供的信息，其中的特殊字符，还被进行了转义。\n在左下方第一步中，创建templateExec过程中，读取到了模板single.html。 通过解析，利用词法分析器，会得到如下状态：\n[“\u0026lt;p\u0026gt;\u0026lt;!-- HT…”, “{{”, “ “, ”.Content”, ” “, ”}}”, EOF] 为了理解其中的工作原理，让我们先来看一下action block的词法分析器是如何工作的。\nAction Block lexer # 将我们的模板片断和分析结果对应上，就可以得到上图所示。\n可以看到词法分析器就像语言大师，可以读懂句子里所有的细节，并能准确说出他们每一个人的名字。\nHugo又是怎么设计这个分析器的呢? # 正如上图所示，左边就是简化后的分析器结构体，其中主要的字段有四个，实际分为两组。\n一组是用来记录当前扫描的位置信息 - start, pos。 start指的是当前token起如的位置，如action block起始符{{，这里start指的就是第一个{符号的字节数组下标；而pos则是当前正在扫描的字符。\n另一组是用来记录行数的信息 - startLine, line。 和上面类似，一个用于记录起始行，另一个用于记录当前行。\n有了这两组信息，就可以精确地通过下标获取到具体的字节信息。\n让我们来看看Hugo是怎么通过这些字段，将tokens一个个的精准识别出来的。\n解析开始后，先进入到lexText处理函数，第一件做的事就是查找leftDelim - {{。 之所以这样设计，是因为在文本的眼里，她只关心哪些是文本，哪些不是。 而leftDelim的出现，意味着在当前字符串中不全是文本。\n我们的例子正是这样，有文本，还有非文本片断。 通过识别，发现存在leftDelim，起始位置是32。 当前位置是0，因为刚开始扫描。 如果当前扫描位置大于起始位置，意味着在这一段中都是文本信息。 紧接着通过扫描换行符数量来判断，当前的文本行数信息。 示例中有一个换行符，意味接下来的扫描起始于第二行。\n到目前为止，文本token的所有信息已经收集完毕。 可以正式提交第一个token了。 如左下方所示，当前text token中包含了起始位置信息pos，值val和行数信息line。 分别是起始位置0， 值从0到32，和行1。\n在后续扫描的起始信息中，包含起始位置32，和起始行2。\n进入到leftDelim token。 开始查看其中是否包含了注解，在我们的示例中没有注解。 所以直接可以进入到action主体，并扫描。\n在这里，有一个中间状态lexInsideAction，会识别在action内部可能出现的token，起到一个分发器的作用。\n判断的标准是基于next函数，也就是下一个字符。 我们的下一个字符是空格，会被isSpace捕获到，那分发器就会马上创建一个空格token，由右边的lexSpace函数继续处理，会合并多个空格。 在我们的示例中会出现两个space token，因此会由此函数提交两个space tokens。\n再回到分发器。 当捕获到的下一个字符是dot - .，会被函数isDot进行处理。 由右下角的lexField函数进行具体处理。 Hugo支持的field格式是字母和数字，所以会先识别出field的名字，并提交field token。\n最终，我们来到rightDelim - }}，也就是action block的终止符。 同样，我们也需要将它作为一个token进行提交，如中下方所示。\n这时我们就来到了这段字符的结尾了，也就是EOF - end of file处，分析器也会将这它作为一个独立的token进行提交。\n这样，Hugo的action block词法分析器将分析流程分为不同的阶段。 由对应的处理函数专注于某一相应状态下，对特定字符进行具体分析，各司其职。 并将token的逻辑规则构建在函数转换的过程中，自然的从一个状态切换到另一个状态。 可以说分工明确，简单有效。\nFSM - Finite State Machine # 从整体视角来看看样例中，生成的tokens之间的关系：\n从层级关系来看，可以清晰的看到text和action是一个层，在action中的元素是另一层。 除了action之外，都会识别token并提交token。 而action的主要作用是识别下一个token，并转交给具体的处理函数进行处理。\n这样一来，我们发现，每个处理函数，对应着不同的分析状态。 其中有的状态会提交token，有的状态只负责识别下一个可能的token。 从状态切换的视角来看，很像是FSM - Finite State Machine的工作模式。\n从上面的公式中可以看出。 输入信息是当前状态加上事件。 输出信息是处理动作加上新的状态。\n当前状态对应的是相应的处理函数，而事件则是识别到的字符信息。 与状态对应的数据就是位置信息和行信息。 处理动作就是函数中所做出的下一个状态决定。 同时也生成了新的数据，像新的位置信息和新地行信息。\n我们结合FSM的概念再梳理一下可能的实现方法：\n初始状态就是Text，初始数据就是样例模板片断。 触发动作后，识别出下一个状态是Left Delim，同时数据更新为action block相应的信息。 而触发事件就是当有请求想要获取下一个token - nextToken的时候。 这样我们就可以依据FSM的理念，同样实现一个action block模板的词法分析器了。\n动手实践 - Show Me the Code of FSM # package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/fsm\u0026#34; ) func main() { // initial fsm with init state and data f := fsm.New(firstState, \u0026amp;data{ err: nil, raw: \u0026#34;first\u0026#34;, }) // add state with handler f.Add(firstState, func(event fsm.Event) (fsm.State, fsm.Data) { if event.Type() == fsm.Action { fmt.Println(event.Data().Raw()) } return secondState, \u0026amp;data{ err: nil, raw: \u0026#34;second\u0026#34;, } }) f.Add(secondState, func(event fsm.Event) (fsm.State, fsm.Data) { if event.Type() == fsm.Action { fmt.Println(event.Data().Raw()) } return lastState, \u0026amp;data{ err: errors.New(\u0026#34;something wrong\u0026#34;), raw: \u0026#34;last\u0026#34;, } }) // error occurs f.Add(lastState, func(event fsm.Event) (fsm.State, fsm.Data) { if e := event.Data().Error(); e != nil { fmt.Println(e) return errorState, nil } // if there is no error // quite with eof state return eofState, \u0026amp;data{ err: nil, raw: \u0026#34;\u0026#34;, } }) for { // send message to notify fsm start the processing e := f.Process(\u0026#34;continue\u0026#34;) // quit with error if e != nil { fmt.Println(\u0026#34;break because of error\u0026#34;) break } // quite for eof state if f.State() == eofState { fmt.Println(\u0026#34;eof\u0026#34;) break } } } const ( firstState = \u0026#34;first\u0026#34; secondState = \u0026#34;second\u0026#34; lastState = \u0026#34;last\u0026#34; errorState = \u0026#34;error\u0026#34; eofState = \u0026#34;eof\u0026#34; ) type data struct { err error raw any } func (d *data) Error() error { return d.err } func (d *data) Raw() any { return d.raw } 样例输出：\n# FSM example first second break because of error Program exited. 线上可直接运行版本 FSM 模块源码 动手实践 - Show Me the Code of Action Block with FSM # package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/lexer\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/lexer/action\u0026#34; ) func main() { // Action example lex, err := action.New( \u0026#34;\u0026lt;p\u0026gt;\u0026lt;!-- HTML comment --\u0026gt;abc\u0026lt;/p\u0026gt;\\n{{.Content}}\u0026#34;) if err != nil { fmt.Println(err) return } var tokens []lexer.Token for { // lexer iterate token := lex.Next() tokens = append(tokens, token) // reach end, analyzing done if token.Type() == action.TokenEOF { break } } // output tokens detail for i, t := range tokens { fmt.Println(i + 1) fmt.Println(t.Value()) } return } 样例输出：\n# 5 tokens generated EOF State 1 \u0026lt;p\u0026gt;\u0026lt;!-- HTML comment --\u0026gt;abc\u0026lt;/p\u0026gt; 2 {{ 3 .Content 4 }} 5 Program exited. Action Lexer线上可直接运行版本 Action Lexer with FSM 动手实践 - Show Me the Code of Template Parser # 有了FSM, Action Lexer的加持后，我们再来实现Template Parser简直易于反掌。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/template/parser\u0026#34; ) func main() { d, err := parser.Parse(\u0026#34;example\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;\u0026lt;!-- HTML comment --\u0026gt;abc\u0026lt;/p\u0026gt;\\n{{.Content}}\u0026#34;) if err != nil { fmt.Println(err) return } fmt.Println(d.String()) } 样例输出：\n# output EOF State \u0026lt;p\u0026gt;\u0026lt;!-- HTML comment --\u0026gt;abc\u0026lt;/p\u0026gt; .Content Program exited. Template Parser线上可直接运行版本 Template Parser module 安全处理 - escape # 词法分析器就像是认字，能帮助读懂每个字，每个词的意思。 同样的字，不同的人，确可以写出完全不同的文章。 Hugo拿到词法分析器后，在最终执行之前，针对HTML模板，还做了一件重要的事情。\n那就是Escape - 主要是用来帮助消除安全隐患，将HTML中的恶意代码进行转义处理。\n要想做到这一点。 光读懂字词还不够，还需要掌握HTML领域的知识。 比如如果想在这过程中去掉注解，首先就要了解HTML中注解的语法。 如果想要识别出恶意代码，那就要先识别出常规代码。 这些领域知识都可以在 HTML标准文档中找到。\n有了这些领域知识，再结合词法解析器，我们就可以清楚地知道，在什么结点，需要进行怎样的转义处理。\n如上图所示，Hugo将token信息消化后，应用模板解析的领域知识，构建出清晰的树状结构。 我们随着Hugo的实现思路来进行分析。\nHugo用树结构体存储了所有Template相关的信息，其中在Escape阶段我们需要重点关注的是Root字段，ListNode类型。 展开之后，我们看到了熟悉的text结点和action结点。 有了这些结构，我们就有了结点之间的上下文，这样我们就可以着手Escape的具体操作了。\n按顺序从Text开始。\n在HTML中，text中可以包含 character references。 也就是以\u0026amp;符开始的字节，如\u0026lt;小于号。 因为HTML中无论tag的开始和结束，都是以\u0026lt;起始的。 如果为了保持纯文本，就需要将\u0026lt;转换成字符索引状态。 如果不这样做，假设在文本中存在\u0026lt;script\u0026gt;console.log(\u0026quot;evil\u0026quot;)\u0026lt;/script\u0026gt;这样的字符串信息，浏览器就会把它错当成代码运行了。 回到text结点中，如果碰到了文本结点，我们就需要将这些需要转换的字符进行统一处理了。\n和Text不一样的是，在Action结点中，我们除了注意注解、转义等，还需要将子结点有效地组织起来。 在action中，词法分析器会帮助分析出像identifier(HtmlEscape)，field(.Content)这样的token。 而且还是成串出现的，很像linux中的管道。\nHugo也是利用了这一点，将这些token通过流水线组装在了一起，而流水线中的每一步，都是一个command命令 - 有命令名及参数。 有了命令后，Hugo还将词法分析器的identifier, field进一步转换成模板解析领域名称。 如每个命令下都是一个操作 - operand，且每个操作由多个结点组成，Hugo半这些结点称作词 - term。\n通过数据结构，获取了这些详细的信息后。 如果想要对流水线处理的结果进行escape操作时，就变得很灵活了。 如我们可以在流水线中添加一道escape的工序。\n理清了之后，就又到了我们喜闻乐见的上代码环节了。\n动手实践 - Show Me the Code of Template Escape # package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/template/escaper\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/template/parser\u0026#34; ) func main() { d, err := parser.Parse(\u0026#34;example\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;\u0026lt;!-- HTML comment --\u0026gt;abc\u0026lt;/p\u0026gt;\\n{{.Content}}\u0026#34;) if err != nil { fmt.Println(err) return } fmt.Println(d.String()) d, err = escaper.Escape(d) if err != nil { fmt.Println(err) return } fmt.Println(d.String()) } 代码输出：\n# remove comments # add escape function to pipeline EOF State \u0026lt;p\u0026gt;\u0026lt;!-- HTML comment --\u0026gt;abc\u0026lt;/p\u0026gt; .Content EOF State \u0026lt;p\u0026gt;abc\u0026lt;/p\u0026gt;.Content | EscapeHtml Program exited. 可以看到，经过escape处理，最终我们移除了文本中的comments，以及在流水线中加上了EscapeHtml工序。\nTemplate Escape线上可直接运行版本 Template Escape module 执行模板 - execute # 根据上一个章节中Escape样例代码的输出结果，现在的语法树如上图右上角所示。 其中Text结点内容移除了注解，只剩下文本信息\u0026quot;abc\n\u0026quot;。 而Action结点中，在pipeline的最后加入了新的命令\u0026quot;EscapeHtml\u0026quot;。\n这样我们就顺利的进入到了模板执行环节。\n模板的应用，目的是为了得到以模板为框架，并填充好动态内容的渲染结果。 那我们最终想得到的内容需要写入到指定的缓存中，就如上图左io.writer所示。\n要想将动态内容填充到模板框架中，首先要获取动态内容。 有的内容是可以直接获取的，像Text结点中的信息。 而有的内容则需要实时计算得到的，就像Action结点中的pipeline。\n在golang中，最小可执行单元是函数，函数可单独存在，也可以由接收者管理。 在Hugo中，有用到系统内置函数，也有用到自定义函数，还有结构体Page实例的方法。 为了便于理解，在我们的实例中，都由统一接收者struct receiver管理：\ntype receiver struct { Data reflect.Value *escaper.Html } 将由用户提供的结构体实例，都放在Data中 - .Content。 通过组合具体的Escape结构体，像escaper.Html，来丰富receiver的功能 - EscapeHtml。\n函数的接收者已经明确，另一个需要注意的就是函数的参数。 像管道函数之所以方便使用，一是因为执行顺序一目了然，另一个优势就是隐性的参数传递，通常都是将前一个命令的执行结果作为后一个命令的最后一个参数传入。 这时我们就可以通过语法树的逻辑关系，将这一特性得以实现。\n动手实践 - Show Me the Code of Template Execute # package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/template/escaper\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/template/executor\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/template/parser\u0026#34; \u0026#34;html/template\u0026#34; ) func main() { d, err := parser.Parse(\u0026#34;example\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;\u0026lt;!-- HTML comment --\u0026gt;abc\u0026lt;/p\u0026gt;\\n{{.Content}}\u0026#34;) if err != nil { fmt.Println(err) return } d, err = escaper.Escape(d) if err != nil { fmt.Println(err) return } t := \u0026amp;tmpl{ name: \u0026#34;hello world template\u0026#34;, tmpl: d, } buf := \u0026amp;bytes.Buffer{} err = executor.Execute(t, buf, \u0026amp;content{}) if err != nil { fmt.Println(err) return } fmt.Println(buf.String()) } type content struct { } func (c *content) Content() template.HTML { return template.HTML(\u0026#34;hello template\u0026#34;) } type tmpl struct { name string tmpl *parser.Document } func (t *tmpl) Name() string { return t.name } func (t *tmpl) Tree() *parser.Document { return t.tmpl } 输出结果：\n# call Content and get hello template # html escape ignore template.HTML type content EOF State EOF State \u0026lt;p\u0026gt;abc\u0026lt;/p\u0026gt;hello template Program exited. Template Execute线上可直接运行版本 Template Execute module 通过对模板进行词法分析，读懂模板信息。 再按action block上下文进行解析，得到语法树。 为了保证安全，在执行前，需要对语法树进行escape转义处理。 最终，结合golang语言的特性，将动态内容填充到模板框架中，写入指定缓存，输出最终渲染结果。\n"},{"id":10,"href":"/docs/code/%E7%AB%99%E7%82%B9/","title":"站点","section":"源码实现","content":" HugoSites创建 # 当用户配置信息、Hugo默认配置信息，以及根据前面的信息所解析出来的模块信息都准备好后。 通过 事件风暴的主流程可以看出，Hugo下一步就开始创建站点了：\n其中第三步 - 准备hugo文件系统，在原始文件系统的基础上，为Hugo准备好工作目录和发布目录。 真正创建HugoSites的步骤，是第四步。\n在 基础架构中，我们从基础架构的角度对Hugo是如何构建站点进行了分析：\n文件系统的组织 以及模板的生命周期 从中，我们了解到，为了让接下来的站点构建专注在构建本身。\nHugo的文件系统需要将不同组件间的逻辑关系都梳理清楚，让多模块中的挂载点都有机的组合在一起，从而能够为其它模块提供便捷的服务。 从下面这张文件系统关系图能看出Hugo对站点领域中文件系统的理解： 模板信息也是在构建站点的时候进行加载的，从开始阶段的领域事件中可以看到： 虽然真正的模块执行阶段在站点渲染阶段，但同上面的文件系统一样，为了提供统一的服务，模块也需要在这之前分工明确，以做好准备。 跬步千里 - HugoSites源码实现 # 通过上面的组件分析，有帮助我们理解Hugo的设计理念，和模块组织结构。 为了进一步理解Hugo的具体实现，我们现在从源码出发，看一看Hugo是如何一步步将理念用代码实现的： 从左上角开始，调用NewHugoSites后，主要干了两件事，一个是createSitesFromConfig，另一个则是newHugoSites。\ncreateSitesFromConfig\n正是在这里，Hugo创建了Site，而且每个Site都有自己的outputFormats，而这依赖于siteMediaTypesConfig和siteOutputFormatsConfig。\nnewHugoSites\n创建的则是HugoSites。 从两个Site构建顺序和定义来看，HugoSites包含了Site，Site保留有HugoSites的引用：\ntype Site struct { language *langs.Language // Output formats defined in site config per Page Kind, or some defaults // if not set. // Output formats defined in Page front matter will override these. outputFormats map[string]output.Formats // All the output formats and media types available for this site. // These values will be merged from the Hugo defaults, the site config and, // finally, the language settings. outputFormatsConfig output.Formats mediaTypesConfig media.Types // The owning container. When multiple languages, there will be multiple // sites . h *HugoSites ... } // HugoSites represents the sites to build. Each site represents a language. type HugoSites struct { Sites []*Site *deps.Deps ... } 在创建HugoSites的过程中，主要要做两件事。 一件是准备好需要惰性初始化的信息，如h.init.data和h.init.layouts，另一件则是应用依赖applyDeps。\n其中重点放在了applyDeps，Hugo将所有需要在渲染前准备好的对象，都称作依赖。 其中包括模板信息、文件系统、站点发布者，站点信息采集者。 从上图也能看出Hugo的创建顺序：\n如果用户没有主动设置模板提供方TemplateProvider，则应用默认模板提供者，并保存在配置信息中。 新建依赖deps.New，主要是创建出NewPathSpec, NewSpec, NewContentSpec, NewSourceSpec这四个规范，用来简化渲染阶段对文件系统的使用步骤。 正式创建onCreated，准备好上面的基础信息后，现在需要创建出目标发布器NewDestinationPublisher，初始化站点信息initializeSiteInfo，新建页面收集器newPageCollections。 加载资源LoadResources，这里加载的资源主要是模板，由上面的模板提供方提供。 通过时序图了解到Hugo的实现细节后，我们还可以到简化后的 HugoSites游乐场代码分支进行实地体验：\n➜ hugo-playground git:(main) git checkout 02-hugo-sites Switched to branch \u0026#39;02-hugo-sites\u0026#39; ➜ hugo-playground git:(02-hugo-sites) 并且可以动行代码查看创建好后的HugoSites和Site实例：\n➜ hugo-playground git:(02-hugo-sites) go run . 输出实例： 从上面的时序图中，我们了解到Hugo创建HugoSites的主脉络。 接下来让我们将时序图进一步展开，来好好看看各阶段的实现细节。 因为还有很多细节等待着我们去研究，好多疑问需要用这些细节来进行解答。 比如究竟模板是怎么组织的？ 这些内置功能函数又是怎么应用上的？ 为什么要这么多的文件系统？ 都是用来做什么的？\n再用Input -\u0026gt; [?] -\u0026gt; Output模型来进行抽象总结，提取核心思想，化繁为简，真正理解Hugo的设计理念。 最终还是要通过动手实践，用源码解释源码，达到不仅理解，还要会的最终目标。\n了然于胸 - createSitesFromConfig时序图 # 将createSitesFromConfig进一步展开后，我们得到如下时序图：\n可以了解到，Hugo先通过配置信息，准备好多语言实例，然后为每种语言分别生成一个站点。\n在基础架中的 配置和语言关系栏，我们有介绍配置和语言的关系。 我们先来简单回顾一下：\n在config.toml中提前配置多语言相关信息，包括languageName，contentDir，weight。 解析完这些自定义信息后，Hugo把这些信息都存放在了config.Provider中，并对外提供了按键值查询的方法。 在创建站点的时候，先创建语言。通过上面的时序图我们还能进一步了解到，语言对象不仅包含了基础配置信息，还包含了ContentDir和Location等信息。 总的来看，语言包含了配置信息，以及一些用户自定义的内容相关的关键信息。\n再看上面时序图的右下角，也就是拿到语言信息后，要开始根据语言创建站点了。 在基础架构 站点创建时做的准备工作中，我们有提到创建站点时所需要准备的工作。 包括MediaType, OutputFormat和OutputFormats，他们之间的关联如下图所示： 抽象总结 - 输入语言，输出站点 # 通过用户配置的语言信息，转换成和语言一一对应的站点，就是createSitesFromConfig所专注的事情。 其中站点Site需要对提供的服务就是针对每种页面类型所提供的OutputFormats，依赖于内部信息Default outputFormats和Default mediaTypes。\n动手实践 - Show Me the Code of createSitesFromConfig # 在知道createSitesFromConfig的实现原理后，我们再来动动小手，用代码来总结代码，巩固一下知识。\n可以这里线上尝试， Show Me the Code, try it yourself\n代码里有注解说明，代码样例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) type configProvider struct { DefaultLanguage string } // Language manages specific-language configuration. type Language struct { Lang string // If set per language, this tells Hugo that all content files without any // language indicator (e.g. my-page.en.md) is in this language. // This is usually a path relative to the working dir, but it can be an // absolute directory reference. It is what we get. // For internal use. ContentDir string // Global config. // For internal use. Cfg configProvider } // Site contains all the information relevant for constructing a static // site. The basic flow of information is as follows: // // 1. A list of Files is parsed and then converted into Pages. // // 2. Pages contain sections (based on the file they were generated from), // aliases and slugs (included in a pages frontmatter) which are the // various targets that will get generated. There will be canonical // listing. The canonical path can be overruled based on a pattern. // // 3. Taxonomies are created via configuration and will present some aspect of // the final page and typically a perm url. // // 4. All Pages are passed through a template based on their desired // layout based on numerous different elements. // // 5. The entire collection of files is written to disk. type Site struct { language *Language // Output formats defined in site config per Page Kind, or some defaults // if not set. // Output formats defined in Page front matter will override these. outputFormats map[string]Formats // All the output formats and media types available for this site. // These values will be merged from the Hugo defaults, the site config and, // finally, the language settings. outputFormatsConfig Formats mediaTypesConfig Types } func main() { cusCfg := configProvider{ DefaultLanguage: \u0026#34;en\u0026#34;, } lang := \u0026amp;Language{ Lang: cusCfg.DefaultLanguage, ContentDir: \u0026#34;mycontent\u0026#34;, Cfg: cusCfg, } mediaTypes := DecodeTypes() formats := DecodeFormats(mediaTypes) outputFormats := createSiteOutputFormats(formats) s := \u0026amp;Site{ language: lang, outputFormats: outputFormats, outputFormatsConfig: formats, mediaTypesConfig: mediaTypes, } fmt.Println(\u0026#34;Site:\u0026#34;) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) } // Type (also known as MIME type and content type) is a two-part identifier for // file formats and format contents transmitted on the Internet. // For Hugo\u0026#39;s use case, we use the top-level type name / subtype name + suffix. // One example would be application/svg+xml // If suffix is not provided, the sub type will be used. // See // https://en.wikipedia.org/wiki/Media_type type Type struct { MainType string `json:\u0026#34;mainType\u0026#34;` // i.e. text SubType string `json:\u0026#34;subType\u0026#34;` // i.e. html Delimiter string `json:\u0026#34;delimiter\u0026#34;` // e.g. \u0026#34;.\u0026#34; } // Type returns a string representing the main- and sub-type of a media type, e.g. \u0026#34;text/css\u0026#34;. // A suffix identifier will be appended after a \u0026#34;+\u0026#34; if set, e.g. \u0026#34;image/svg+xml\u0026#34;. // Hugo will register a set of default media types. // These can be overridden by the user in the configuration, // by defining a media type with the same Type. func (m Type) Type() string { // Examples are // image/svg+xml // text/css return m.MainType + \u0026#34;/\u0026#34; + m.SubType } // Types is a slice of media types. type Types []Type const defaultDelimiter = \u0026#34;.\u0026#34; var HTMLType = newMediaType(\u0026#34;text\u0026#34;, \u0026#34;html\u0026#34;) func newMediaType(main, sub string) Type { t := Type{ MainType: main, SubType: sub, Delimiter: defaultDelimiter} return t } // DefaultTypes is the default media types supported by Hugo. var DefaultTypes = Types{ HTMLType, } // DecodeTypes takes a list of media type configurations and merges those, // in the order given, with the Hugo defaults as the last resort. func DecodeTypes() Types { var m Types // remove duplications // Maps type string to Type. Type string is the full application/svg+xml. mmm := make(map[string]Type) for _, dt := range DefaultTypes { mmm[dt.Type()] = dt } for _, v := range mmm { m = append(m, v) } return m } // Format represents an output representation, usually to a file on disk. type Format struct { // The Name is used as an identifier. Internal output formats (i.e. HTML and RSS) // can be overridden by providing a new definition for those types. Name string `json:\u0026#34;name\u0026#34;` MediaType Type `json:\u0026#34;-\u0026#34;` // The base output file name used when not using \u0026#34;ugly URLs\u0026#34;, defaults to \u0026#34;index\u0026#34;. BaseName string `json:\u0026#34;baseName\u0026#34;` } // Formats is a slice of Format. type Formats []Format // GetByName gets a format by its identifier name. func (formats Formats) GetByName( name string) (f Format, found bool) { for _, ff := range formats { if strings.EqualFold(name, ff.Name) { f = ff found = true return } } return } // HTMLFormat An ordered list of built-in output formats. var HTMLFormat = Format{ Name: \u0026#34;HTML\u0026#34;, MediaType: HTMLType, BaseName: \u0026#34;index\u0026#34;, } // DefaultFormats contains the default output formats supported by Hugo. var DefaultFormats = Formats{ HTMLFormat, } // DecodeFormats takes a list of output format configurations and merges those, // in the order given, with the Hugo defaults as the last resort. func DecodeFormats(mediaTypes Types) Formats { // Format could be modified by mediaTypes configuration // just make it simple for example fmt.Println(mediaTypes) f := make(Formats, len(DefaultFormats)) copy(f, DefaultFormats) return f } func createSiteOutputFormats( allFormats Formats) map[string]Formats { defaultOutputFormats := createDefaultOutputFormats(allFormats) return defaultOutputFormats } const ( KindPage = \u0026#34;page\u0026#34; kind404 = \u0026#34;404\u0026#34; ) func createDefaultOutputFormats( allFormats Formats) map[string]Formats { htmlOut, _ := allFormats.GetByName(HTMLFormat.Name) m := map[string]Formats{ KindPage: {htmlOut}, kind404: {htmlOut}, } return m } 输出样例：\n# 解析Formats传入的MediaType [{text html .}] # Site实例 # 拥有了语言相关的配置项 # 每个页面类型也明确了自己的输出格式 Site: \u0026amp;main.Site{ language:(*main.Language)(0xc0000161b0), outputFormats:map[string]main.Formats{ \u0026#34;404\u0026#34;:main.Formats{ main.Format{ Name:\u0026#34;HTML\u0026#34;, MediaType:main.Type{ MainType:\u0026#34;text\u0026#34;, SubType:\u0026#34;html\u0026#34;, Delimiter:\u0026#34;.\u0026#34;}, BaseName:\u0026#34;index\u0026#34;}}, \u0026#34;page\u0026#34;:main.Formats{ main.Format{ Name:\u0026#34;HTML\u0026#34;, MediaType:main.Type{ MainType:\u0026#34;text\u0026#34;, SubType:\u0026#34;html\u0026#34;, Delimiter:\u0026#34;.\u0026#34;}, BaseName:\u0026#34;index\u0026#34;}}}, outputFormatsConfig:main.Formats{ main.Format{ Name:\u0026#34;HTML\u0026#34;, MediaType:main.Type{ MainType:\u0026#34;text\u0026#34;, SubType:\u0026#34;html\u0026#34;, Delimiter:\u0026#34;.\u0026#34;}, BaseName:\u0026#34;index\u0026#34;}}, mediaTypesConfig:main.Types{ main.Type{MainType:\u0026#34;text\u0026#34;, SubType:\u0026#34;html\u0026#34;, Delimiter:\u0026#34;.\u0026#34;}}} Program exited. "},{"id":11,"href":"/docs/code/%E7%AB%99%E7%82%B9/markdown/","title":"Index","section":"站点","content":" Markdown文件是如何被翻译成HTML的 # Markdown是一种文件格式，也是一种约定的语言。 之所以大受欢迎，是因为Markdown其简洁的语法。 不仅让作者在写作的过程中专注在内容创作上，让读者流畅的进行阅读。 还可以将内容直接发布到互联网上，方便传阅，让作品可以轻松的接触到更多的读者。\n如果只是为了写作，传统的文本编辑器提供了更强大的样式支持，哪怕是高要求的印刷出版物，一样可以百分百支持。 随着互联网的发展，将文章放到网上已然成了一项基本需求。\n而传统的文本编辑器上网的能力似乎不能满足现在的普遍需求。 一是这些强大的编辑器通常出自某一家大公司，并不是行业标准。 种类繁多不说，各家标准也不同，还没有全部公开，这些都让浏览器团队有心无力。\n如果说只是要将内容放到网上，那传统的HTML不行吗？ 这就是浏览器钦定的格式啊。 确实如此，HTML是方便了浏览器解析、渲染和展示，但对于写作者来说，并不友好，光标签种类就几十种，更不要提各种不同标签的属性了。\n在这种左右两难的背景下，Markdown站了出来。 用简洁的语法替代了相对复杂的HTML，让创作者能更专注在内容创作上。 将标准开放，让大家参与其中，可遵循标准，也可以自定义标准，慢慢的也出现的统一的标准。\nHugo支持的就是Markdown语法，那Hugo是如何将Markdown语法文章翻译成HTML文本的呢？\n通过查看最新的Hugo源码，我们发现Hugo将默认的Markdown解析器设置成了Goldmark。\n那我们的疑问就变成了：Goldmark是如何将Markdown转换成HTML的呢？\nGoldmark工作原理 # 根据 Goldmark的介绍。 Goldmark遵循了 CommonMark 0.30规范。 用AST(Abstract Syntax Tree)结构对内容进行了解析。\n要想知道Goldmark的工作原理，得先弄清楚CommonMark和AST这两个知识点。\nCommonMark 0.30 # 说到CommonMark规范，大家可能不了解。 但说到GitHub Flavored Markdown，相信大家都有过使用经验，其实GitHub Flavored Markdown就是基于CommonMark规范演化而来的。\n细节在 CommonMark Spec 0.30中都有很清楚的描述。 下面我们从领域知识的角度，来进行解读。\n让我们从一个例子开始：\nA paragraph with two lines. indented code \u0026gt; A block quote. 上面是一段用Markdown语法编写的文本信息，在解析阶段，会被解析成AST，如下图所示：\nGoldmark先将文本信息读取到内存，如上图左所示。 那Goldmark是怎么解读这段文本的呢？\n对于字符流的处理，有的是按字符一个个进行处理的，如JSON解析。 有的则是按行进行处理的，如配置文件。\n通过Commonmark Spec中的 解析策略可以看出，是按行处理的。\n那我们上面的文本就会按下面的顺序，以行为单位进行处理：\n结合我们的MD写作习惯，让我们回想一下，是不是很多格式需要用换行来辅助说明。 比如段落，我们可以以每个句号为一行，可以换行，只要没有空行，就认为这些句子都是一个段落。 如果想要另起一个段落，直接用空行分隔就行。\n在读取到了这一行行内容之后，要做怎样的处理呢？\n同样是在CommonMark规范中的解析策略中可以了解到。 解析分为两步，首先是按Block将所有的行进行分类，这些行分别能组成什么类型的block。 按block将行处理完成后，就要对行内的信息进行处理了，在规范中将这些信息称之为inline信息。\n上面出现了两个领域概念，一个是block，另一个则是inline，那规范里又是怎么定义这两个概念的呢？\n在 Blocks and inlines章节，我们可以看到具体的定义：\nBlocks: 一个文档是由一系列blocks组成的 Inline: 有一些block可以包含其它的block，而另一些block则包含inline内容，如text, links, 加粗text等等 也就是说，在规范里，我们将一个MD文件称之为document，document是由block序列组成的。 其中有的block可以包含其它block，有的block则包含inline相关的信息。 在规范中也有给这两种block相应的名称。 能包含其它block的block，我们管它们叫container block。 只包含inline信息的block，我们管它们叫leaf block。\n其中container block有Block quotes, List items和Lists，这些block都可以包含其它block。\n再看Leaf blocks，有Setext headings, Indent code blocks, Paragraphs等等。 这些leaf blocks可能包含inlines，如Links, Images, Textual content等等。\n这样我们就可以将上面的文本信息转换成相应的block和inline了：\n将文本信息解析成领域语言后，我们还需要用AST对解析后的信息进行存储。\nAST # AST也就是Abstract Syntax Tree - 抽象语法树。 是一种数据结构，它可以用来存储有一逻辑关系的字符集。 还可以利用树状结构来存储一些逻辑关系。\n来举个例子：\n我们将解析完的源码用AST来表示就如上图所示。 在源码中，我们将解析完的序列叫Statement sequence，像while和return都是statement。\n在while中，有判断条件也有body。 在树状结构中，第一个子结点则是状态条件，另一个结点，就代表了body。\n先看状态条件，这是一个比较操作。 其中操作符是不等号，操作对象则是变量b和常量0。\n再看body对象，第一个分支也是一个条件判断，操作符为大于号，操作对象是变量a和变量b。 在这个判断条件中，body是if语句。 因为if, else可以成对出现，所以if判断语句肯定有一个判断条件，可能有两个body，一个是if body，另一个是else body。 上面的示例中就只有一个if body。 在if body中是一个赋值操作，赋值对象是变量a，运算操作是减法操作，运算减数是变量b，被减数则是变量a。\n可以看到，通过AST结构，我们将上面的示例代码段解析成了状态序列，其中包含了基本信息和结构信息，为源码编译时提供详细信息。\n通过上面的Markdown规范和了解到的源码AST示例，我们再举一个Markdown AST实例:\n上面的示例是我们Hugo Playground中的真实文本。 按照规范来进行解析，生成的AST如上图所示。\n我们将得到一个完整的Document树，其中有两个block结点，分别是heading和paragraph。 这两个block结点分别又包含了各自的inline结点text，并拥有相应的值。\n对CommonMark规范和AST有了了解后，我们来看看goldmark究竟是如何实现的。\ngoldmark的魔法 # 输入一段markdown文本，得到一颗AST树。 这是输入和输出，那要怎么设计能满足这一要求呢？\ngoldmark源码给出的答案是open block解析策略。 这在CommonMark规范中的解析策略中也有提到。 因为document是由block序列组成的，根据这一特点，我们可以通过深度优先算法，将block一个个按序解析完成。 虽然可能出现嵌套block的情况，但每一层结点的block同一时间只有一个。 这样我们只需要维护好这一处于开放状态的block就行。\n当我们解析到新block时，就将其一级级打开，同时关闭同一级刚打开的block。 这样我们就可以建立好上面的AST block树了。 可以看到根结点有三个子结点，分别是paragraph, ident code block和quote block，其中quote block是container block，还包含了一个paragraph。\n为了帮助更进一步的理解，根据goldmark实现源码，我们来一步步的重现一下goldmark的实现细节：\n我们知道document是由block序列组成的。 goldmark也是根据这一特点进行解析的 - 以block为中心，通过维护处于打开状态的block，一行行的进行解析。\n在进入解析之前，处于打开状态的block为空，也就我们看到的[]Block, block结构中有两个指针，一个是AST结点，另一个是block解析器指针，初始化时都为空。\n当读到第一行A paragraph\\n时，根据这一行的起始特征 - 没有缩进，没有特殊符号。 判断为Paragraph结点类型，随既打开一个Paragraph结点。 并将新打开的结点添加父结点 - 根结点。 同时更新[]Block，结点指针指向新打开的结点p，同时记录下相应的解析器pser。 并将字符信息的起始地址和结束地址都以segment的形式，记录在结点的Lines中。\n当读到第二行with two lines.\\n时，因为当前打开的block是Paragraph，根据Paragraph特性，判断这一行仍属于当前打开block。 接着调用lastBlock.Parser.Continue继续处理这一行的信息。 打开paragraphParser的Continue方法，可以看到，只要不是空行，解析器就把这一行以segment的形式，添加到结点的Lines中。 并返回状态Continue | NoChildren。\n当解析到第三行\\n时，流程还是和上面一行一样，不同的是这一次，Continue在识别到内容为空行时，直接返回的状态是Close。 这时根据返回状态，总解析流程意识到Paragraph已完成解析，可以关闭block了。 处于打开状态的[]Block队列又恢复到初始化状态，AST结点指针和当前block解析器指针都归为空。\n继续扫描新行 indented code\\n，因为前面的4格缩进，这次识别出来的类型为Indent Code Block。 随既创建新结点c并添加到父结点 - 根结点。 同时更新处于打开状态的block序列[]Block。\n继续扫描下一行\\n，和Paragraph不同的是，Indent Code Block是允许以空行分隔的，如 样例112所示。 这也就意味着，并不能直接关闭当前开放状态的block，而是继续扫描。\n这时就到了最后一行\u0026gt; A block quote.\\n。 通过识别到起始字符为\u0026gt;，通过查询关键字符相关的解析器，识别出这是一个新的block - Block quotes。 除了和上面将新结点添加到父结点外，还需要继续扫描后面的字符 A block quote.\\n。 这时仍处于打开block流程中，继续打开新Paragraph block，发现这已经是最后一行后，打开block流程结束。 进入到关闭前一个block的流程，没错，这里关闭的就是之前的indent block。 这时流程发现再没有其它可以打开的block后，进入最后的收尾阶段，关闭当前所有处于开放状态的blocks。 从后往前，先关闭leaf类型的Paragraph block，最后关闭它的父结点container类型的quote block。\n这样整个block解析流程就结束了，我们得到了上图左下角的AST数据结构。 根结点也就是Document结点下，第一层级有三个结点，分别是Paragraph, Indent, Quote block。 其中只有Quote block是container类型，可以包含子block，也就是第二层的Paragraph block。\n动手实践 - Show Me the Code of Markdown # 通过CommonMD规范和goldmark的实现样例，我们掌握了Markdown的领域相关知识。 通过上面的梳理，进一步了解到了详细的转换流程。 下面我们自已动一动手，实现一个可以支持Heading和Paragraph block的解析器。 从理论到实际，出发吧，伟大的工程师啊！\n可以这里尝试线上版本： Show Me the Code, try it yourself\n实例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/sunwei/gobyexample/modules/markdown/parser\u0026#34; ) func main() { var r = newReader() d, _ := parser.Parse(r.lines) d.Walk(func(v any, ws parser.WalkState) parser.WalkStatus { b := v.(parser.Block) if ws == parser.WalkIn { fmt.Println(\u0026#34;Walk in: \u0026#34;) fmt.Printf(\u0026#34;%s\\n\u0026#34;, b) } else { fmt.Println(\u0026#34;Walk out.\u0026#34;) } return parser.WalkContinue }) } type line struct { raw string startChar string } func (l *line) Raw() string { return l.raw } func (l *line) StartChar() string { return l.startChar } type reader struct { lines []parser.Line } func newReader() *reader { return \u0026amp;reader{lines: []parser.Line{ \u0026amp;line{raw: \u0026#34;### first blog\\n\u0026#34;, startChar: \u0026#34;#\u0026#34;}, \u0026amp;line{raw: \u0026#34;Hello Blog\\n\u0026#34;, startChar: \u0026#34;H\u0026#34;}, }} } 输出样例：\n# Walk result # Start from root Walk in: \u0026amp;{%!s(parser.BlockState=2) \u0026lt;nil\u0026gt; []} # In first child Walk in: \u0026amp;{ - {%!s(parser.BlockState=2) %!s(*parser.heading=\u0026amp;{}) [%!s(*parser.headLine=\u0026amp;{first blog})]} %!s(int=3)} Walk out. # In second child Walk in: \u0026amp;{%!s(parser.BlockState=2) %!s(*parser.paragraph=\u0026amp;{}) [%!s(*main.line=\u0026amp;{Hello Blog H})]} Walk out. # Out root Walk out. Program exited. "},{"id":12,"href":"/docs/code/%E7%AB%99%E7%82%B9/%E5%88%9B%E5%BB%BA/","title":"Index","section":"站点","content":" onCreated # Deps新建后，我们就可以应用Deps了。 在新建HugoSites的流程中，可以看到应用Deps的操作发生在onCreated中。\n了然于胸 - onCreate时序图 # 从左下角可以看出，onCreate主要分为三部分，分别是：\nNewDestinationPublisher: 为站点创建publisher initializeSiteInfo：初始化站点信息，将站点所依赖的信息都汇集到一块 newPageCollection：创建页面集合，因为最终渲染是以页面为单位，所以在HugoSites中为每个站点都配备了一个聚集器 NewDestinationPublisher # pub, err := publisher.NewDestinationPublisher( d.ResourceSpec, s.outputFormatsConfig, s.mediaTypesConfig, ) ... s.publisher = pub ResourceSpec来自于Deps，其中包含了全面文件系统信息的PathSpec，和outputFormats, mediaTypesConfig，在我们的例子里，都是默认配置。 而在publisher中，我们不拥有当前site拥有的配置信息 - outputFormatsConfig, mediaTypesConfig。 同时拥有默认信息和定制化信息，这样我们就可以针对当前site进行定制化处理了。\ninitializeSiteInfo # func (s *Site) initializeSiteInfo() error { // Assemble dependencies to be used in hugo.Deps. s.Info = \u0026amp;SiteInfo{ title: \u0026#34;title\u0026#34;, relativeURLs: s.Cfg.GetBool(\u0026#34;relativeURLs\u0026#34;), owner: s.h, s: s, } return nil } 在我们的例子中对基本信息做了简化，可以看到，这里会对站点所需要的基本信息，像标题等等进行汇总。\nnewPageCollection # ... pm := \u0026amp;pageMap{ contentMap: newContentMap(), s: s, } s.PageCollections = newPageCollections(pm) ... PageCollections是页面的集合，可以提供类似于页面查找的服务。\n"},{"id":13,"href":"/docs/code/%E7%AB%99%E7%82%B9/%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/","title":"Index","section":"站点","content":" LoadResources # 创建HugoSites的最后一步就是LoadResources，没错，不知不觉中，我们已经走到了这一步。\n// LoadResources loads translations and templates. func (d *Deps) LoadResources() error { if err := d.templateProvider.Update(d); err != nil { return fmt.Errorf(\u0026#34;loading templates: %w\u0026#34;, err) } return nil } LoadResources也就做了一件事，就是专注在通知templateProvider，可以开始更新了。\n我们的templateProvider就是默认的tplimpl.DefaultTemplateProvider。\n// Update updates the Hugo Template System in the provided Deps // with all the additional features, templates \u0026amp; functions. func (*TemplateProvider) Update(d *deps.Deps) error { tmpl, err := newTemplateExec(d) if err != nil { return err } return tmpl.postTransform() } 基本原理有在 基础架构的Template vs Layouts章节中有介绍，这里就不再复述。\n接下来我们将重心放到源码实现上。\n"},{"id":14,"href":"/docs/code/%E9%85%8D%E7%BD%AE/","title":"Index","section":"源码实现","content":" Config源码分析 # 在 基础架构中，从基础架构的视角出发。 有提到配置模块，以及 配置和语言的关系。\n下面我们从源码实现的角度，详细的来看看Hugo是如何设计和实现配置模块的。\n跬步千里 - Config模块源码 # 将 游乐场源码， 切换到 01-config分支：\n➜ hugo-playground git:(main) git checkout 01-config Switched to branch \u0026#39;01-config\u0026#39; Your branch is up to date with \u0026#39;origin/01-config\u0026#39;. ➜ hugo-playground git:(01-config) 通过将源码按配置模块进行裁剪，Config模块在我们面前也变得清晰，让我们在Hugo源码学习的道路上迈出了自信的一步。 通过命令行，我们可以看看具体的目录结构：\n➜ hugo-playground git:(01-config) tree . ├── LICENSE ├── README.md ├── command.sh ├── common │ ├── maps │ │ ├── maps.go │ │ └── params.go │ └── paths │ └── path.go ├── config │ ├── commonConfig.go │ ├── compositeConfig.go │ ├── configLoader.go │ ├── configProvider.go │ ├── defaultConfigProvider.go │ └── env.go ├── go.mod ├── go.sum ├── hugo-playground ├── hugofs │ ├── files │ │ └── classifier.go │ └── fs.go ├── hugolib │ └── config.go ├── langs │ ├── config.go │ └── language.go ├── log │ └── logger.go ├── main.go ├── modules │ ├── client.go │ ├── collect.go │ ├── config.go │ └── module.go ├── parser │ └── metadecoders │ ├── decoder.go │ └── format.go └── types ├── convert.go └── types.go 13 directories, 30 files 总共也就13个文件夹，30个文件，其中还包含了一些Github和Golang工程的默认文件。\n我们看看main.go文件中主要干了什么：\n... // 1. config log.Process(\u0026#34;main\u0026#34;, \u0026#34;load configurations from config.toml and themes\u0026#34;) cfg, _, err := hugolib.LoadConfig( hugolib.ConfigSourceDescriptor{ WorkingDir: tempDir, Fs: afs, Filename: \u0026#34;config.toml\u0026#34;, }, ) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, cfg) 主要就是调用了LoadConfig函数，生成了配置信息，最打印出来。 主文件中其它的代码我们有在 游乐场的介绍中提到过，感兴趣的小伙伴可以前往查看。\n如果想要运行程序，查看输出的配置信息长啥样，也可以进入到工程根目录，简单运行命令：\ngo run . 得到运行结果如下： 进一步查看LoadConfig函数，我们发现主要做了三件事：\nloadConfig，加载用户项目中的配置文件，如config.toml。 applyConfigDefaults，如果说上面是用户的自定义信息，那这里就是Hugo用到的默认信息。 collectModules，加载完自定义信息和默认信息后，根据得到的模块信息，准备模块，并将解析过后的模块信息，也放入配置信息中。 在本章我们重点看第1步loadConfig，在后续的章节里会有第2步applyConfigDefaults，和第3步collectModules的介绍。\n了然于胸 - loadConfig时序图 # 从时序图中，我们可以清晰的看到loadConfig被调用的环境。 由主函数发起调用，在hugolib/config.go中先是构建好configLoader，调用loadConfig函数，将config.toml文件转换成Map类型数据。\n在loadConfig中，通过函数名可以观察到Hugo的实现思路。 这也说明好的命名是多么的重要。\n（温馨提示，在阅读下述流程函数时，可打开 配置源码对照查看。）\nFromFileToMap，将目标文件config.toml转换成Map类型的数据。 loadConfigFromFile，为了达到上面的目的，首先要从硬盘加载这个文件。 UnmarshalFileToMap，加载后，需要将字符弃，解组成Map类型的数据。 UnmarshalToMap，解组对应的输出格式要求，可能不一样，这里是要求解组成Map类型，还有可能是其它类型。 FormatFromString，从文件名获取文件格式toml。 UnmarshaTo，通过获取的文件格式信息，以及文件数据信息，和对应的输出格式Map信息，解组总函数，知道该让谁具体负责了。 toml.Unmarshal，所有信息被传送到具体操作员toml，可以外聘，也可以自己实现。Hugo选择了外聘github.com/pelletier/go-toml/v2。 抽象总结 - 输入配置文件，输出Map格式数据 # 首先了解用户的需求，是将config.toml文件作为输入，要求输出Map类型的数据。 Hugo先是收集信息，包括文件数据data，文件格式toml，和输出类型map[string]any，找到专业的人go-toml，进行处理。 最终得到符合要求的Map信息。\n动手实践 - Show Me the Code of loadConfig # 在知道loadConfig的实现原理后，我们再来动动小手，用代码来总结代码，巩固一下知识。\n可以这里线上尝试， Show Me the Code, try it yourself\n代码里有注解说明，代码样例：\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; toml \u0026#34;github.com/pelletier/go-toml/v2\u0026#34; \u0026#34;golang.org/x/tools/txtar\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;strings\u0026#34; ) // 文件结构 // 文件名: config.toml // 文件内容：theme = \u0026#39;mytheme\u0026#39; var files = \u0026#34;-- config.toml --\\n\u0026#34; + \u0026#34;theme = \u0026#39;mytheme\u0026#39;\u0026#34; // Format 文件格式类型 type Format string // TOML 支持的格式，为简单示例，只支持TOML格式 const ( TOML Format = \u0026#34;toml\u0026#34; ) func main() { // 解析上面的文件结构 data := txtar.Parse([]byte(files)) fmt.Println(\u0026#34;File start:\u0026#34;) // Input: 数据，格式，输出类型 var configData []byte var format Format m := make(map[string]any) // 遍历解析生成的所有文件，通过File结构体获取文件名和文件数据 // f.Name 获取文件名 // f.Data 获取文件数据 // 如果是config.toml文件，则获取文件数据 for _, f := range data.Files { if \u0026#34;config.toml\u0026#34; == f.Name { configData = bytes.TrimSuffix( f.Data, []byte(\u0026#34;\\n\u0026#34;)) format = FormatFromString(f.Name) } } err := UnmarshalTo(configData, format, \u0026amp;m) if err != nil { fmt.Println(err) } else { fmt.Println(m) } fmt.Println(\u0026#34;File end.\u0026#34;) } // FormatFromString turns formatStr, typically a file extension without any \u0026#34;.\u0026#34;, // into a Format. It returns an empty string for unknown formats. // Hugo 实现 func FormatFromString(formatStr string) Format { formatStr = strings.ToLower(formatStr) if strings.Contains(formatStr, \u0026#34;.\u0026#34;) { // Assume a filename formatStr = strings.TrimPrefix( filepath.Ext(formatStr), \u0026#34;.\u0026#34;) } switch formatStr { case \u0026#34;toml\u0026#34;: return TOML } return \u0026#34;\u0026#34; } // UnmarshalTo unmarshals data in format f into v. func UnmarshalTo(data []byte, f Format, v any) error { var err error switch f { case TOML: err = toml.Unmarshal(data, v) default: return fmt.Errorf( \u0026#34;unmarshal of format %q is not supported\u0026#34;, f) } if err == nil { return nil } return err } 程序输出结果：\n# 解析后得到文件config.toml # 准备Input：config file data, format, map[string]any # 得到Output: map[theme:mytheme] File start: map[theme:mytheme] File end. Program exited. 了然于胸 - applyConfigDefaults时序图 # 上面的loadConfig帮助我们读取了文件系统里的config.toml文件，并将结果以map[string]any的格式。 那我们会把用户自定义的这些配置信息最终存储到哪儿，又将以什么形式提供服务呢？\n我们来通过applyConfigDefaults时序图找寻一下线索： 从上图左下脚可以看到在configLoader调用applyConfigDefaults方法后，实际调用的是l.cfg.SetDefaults：\n// hugo-playground/hugolib/config.go // line 54 func (l configLoader) applyConfigDefaults() error { defaultSettings := maps.Params{ ... \u0026#34;timeout\u0026#34;: \u0026#34;30s\u0026#34;, ... } l.cfg.SetDefaults(defaultSettings) return nil } 那l.cfg从哪儿来呢？ 我们可以往时序图左上方看。 在创建configLoader实例的时候，有一同创建cfg，直接调用config.New()：\n// hugo-playground/config/defaultConfigProvider.go // line 16 // New creates a Provider backed by an empty maps.Params. func New() Provider { return \u0026amp;defaultConfigProvider{ root: make(maps.Params), } } 实际返回的是一个接口Provider，而实现了这个接口的对象就是defaultConfigProvider，一起初始化的还有字段maps.Params类型的root。\n看来Provider就是默认配置项的接收者。 为了进一步验证我们的猜测，我们继续往右边看。 果然，在从config.toml中读到取用户的自定义配置信息后，也是调用的Provider(cfg)的Set方法，将解析后的map[string]any值设置到了\u0026quot;\u0026quot;字段。\n回到我们最初的问题：我们会把用户自定义的这些配置信息最终存储到哪儿，又将以什么形式提供服务呢？\n这时我们已经知道，不管是用户自定义信息，还是默认配置信息，我们都存储在了这个配置提供者里面。 相信ConfigProvider就是我们要找寻的答案。 是时候来看看这个Provider接口的定义了：\n// hugo-playground/config/configProvider.go // line 9 // Provider provides the configuration settings for Hugo. type Provider interface { ... Get(key string) any Set(key string, value any) SetDefaults(params maps.Params) ... } 确实，Provider不仅提供了Set方法，还提供了Get方法，那就没跑了。\n弄清了起点和终点后，我们继续看看过程，Set和SetDefaults方法具体是怎么将不同类型的数据设置到Provider中的。\n先看负责用户自定义配置项的Set方法。 拿到用户的配置信息后，首先需要将配置信息转换成Params类型：\n// hugo-playground/common/maps/params.go // line 9 // Params is a map where all keys are lower case. type Params map[string]any 实际他俩类型是一样的，都是map[string]any。\n在类型转换成Params后，需要通过PrepareParams进行处理，让内部格式保持统一。 而Params所做的主要事情包括两项：一是将所有key都转换成小写字符串，二是将所有的值都转换成通用类型any。 这样的好处就是信息都按统一标准Params格式进行存储，因为类型确定，所以方便拓展和提供其它类型的数据服务。 比如想要获取整形数据，可以在Provider接口中定义GetInt方法，那我们就可以将所获取的any类型的值，转换成Int。 同理，如果需要其它类型的数据服务，一样可以满足。\n再看负责默认配置的SetDefaults方法，比Set方法更简单，直接调用的就是PrepareParams。 因为自己定义的格式，自己最清楚如何使用。 相对面向用户的配置信息多样性，自己定义的默认值更具备确定性。\n抽象总结 - 输入不同类型的值，输出标准的configProvider # 从输入来看，我们要接收来自用户的自定义配置信息，同时也要接收默认的自定义配置信息，还有以后可能会碰到的单项更新信息。\n从输出来看，我们需要提供一个通用的配置信息提供方，统一标准，方便满足获取不同数据类型的需求。\n为了正确处理接收到的数据，并满足多样性数据服务的需求，Hugo将所有接收到的数据进行标准化处理，以统一的Params格式式进行存储。 这样就可以在标准化的基础上进行拓展，从而满足不同的数据需求。\n动手实践 - Show Me the Code of applyConfigDefaults # 在知道applyConfigDefaults的实现原理后，我们再来动动小手，用代码来总结代码，巩固一下知识。\n可以这里线上尝试， Show Me the Code, try it yourself\n代码里有注解说明，代码样例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strings\u0026#34; ) // Provider 定义提供方需要具备的能力 // 通过Key查询值 // 设置键值对 // 设置默认参数 type Provider interface { Get(key string) any Set(key string, value any) SetDefaults(params Params) } // Params 参数格式定义 // 关键字为字符类型 // 值为通用类型any type Params map[string]any // Set 根据新传入参数，对应层级进行重写 // pp为新传入参数 // p为当前参数 // 将pp的值按层级结构写入p // 递归完成 func (p Params) Set(pp Params) { for k, v := range pp { vv, found := p[k] if !found { p[k] = v } else { switch vvv := vv.(type) { case Params: if pv, ok := v.(Params); ok { vvv.Set(pv) } else { p[k] = v } default: p[k] = v } } } } func New() Provider { return \u0026amp;defaultConfigProvider{ root: make(Params), } } // defaultConfigProvider Provider接口实现对象 type defaultConfigProvider struct { root Params } // Get 按key获取值 // 约定\u0026#34;\u0026#34;键对应的是c.root // 嵌套获取值 func (c *defaultConfigProvider) Get(k string) any { if k == \u0026#34;\u0026#34; { return c.root } key, m := c.getNestedKeyAndMap(strings.ToLower(k)) if m == nil { return nil } v := m[key] return v } // getNestedKeyAndMap 支持多级查询 // 通过分隔符\u0026#34;.\u0026#34;获取查询路径 func (c *defaultConfigProvider) getNestedKeyAndMap( key string) (string, Params) { var parts []string parts = strings.Split(key, \u0026#34;.\u0026#34;) current := c.root for i := 0; i \u0026lt; len(parts)-1; i++ { next, found := current[parts[i]] if !found { return \u0026#34;\u0026#34;, nil } var ok bool current, ok = next.(Params) if !ok { return \u0026#34;\u0026#34;, nil } } return parts[len(parts)-1], current } // Set 设置键值对 // 统一key的格式为小写字母 // 如果传入的值符合Params的要求，通过root进行设置 // 如果为非Params类型，则直接赋值 func (c *defaultConfigProvider) Set(k string, v any) { k = strings.ToLower(k) if p, ok := ToParamsAndPrepare(v); ok { // Set the values directly in root. c.root.Set(p) } else { c.root[k] = v } return } // SetDefaults will set values from params if not already set. func (c *defaultConfigProvider) SetDefaults( params Params) { PrepareParams(params) for k, v := range params { if _, found := c.root[k]; !found { c.root[k] = v } } } // ToParamsAndPrepare converts in to Params and prepares it for use. // If in is nil, an empty map is returned. // See PrepareParams. func ToParamsAndPrepare(in any) (Params, bool) { if IsNil(in) { return Params{}, true } m, err := ToStringMapE(in) if err != nil { return nil, false } PrepareParams(m) return m, true } // IsNil reports whether v is nil. func IsNil(v any) bool { if v == nil { return true } value := reflect.ValueOf(v) switch value.Kind() { case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice: return value.IsNil() } return false } // ToStringMapE converts in to map[string]interface{}. func ToStringMapE(in any) (map[string]any, error) { switch vv := in.(type) { case Params: return vv, nil case map[string]string: var m = map[string]any{} for k, v := range vv { m[k] = v } return m, nil default: fmt.Println(\u0026#34;value type not supported yet\u0026#34;) return nil, nil } } // PrepareParams // * makes all the keys lower cased // * This will modify the map given. // * Any nested map[string]interface{}, map[string]string // * will be converted to Params. func PrepareParams(m Params) { for k, v := range m { var retyped bool lKey := strings.ToLower(k) switch vv := v.(type) { case map[string]any: var p Params = v.(map[string]any) v = p PrepareParams(p) retyped = true case map[string]string: p := make(Params) for k, v := range vv { p[k] = v } v = p PrepareParams(p) retyped = true } if retyped || k != lKey { delete(m, k) m[lKey] = v } } } func main() { // 新建Config Provider实例 // 实例中defaultConfigProvider实现了接口 provider := New() // 模拟设置用户自定义配置项 // config.toml中关于主题的配置信息 // 类型是map[string]string // 需要转换成map[string]any，也就是Params类型 provider.Set(\u0026#34;\u0026#34;, map[string]string{ \u0026#34;theme\u0026#34;: \u0026#34;mytheme\u0026#34;, }) // 模拟默认配置项 // 超时默认时间为30秒 provider.SetDefaults(Params{ \u0026#34;timeout\u0026#34;: \u0026#34;30s\u0026#34;, }) // 输出提前设置的所有配置信息 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, provider.Get(\u0026#34;\u0026#34;)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, provider.Get(\u0026#34;theme\u0026#34;)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, provider.Get(\u0026#34;timeout\u0026#34;)) } 程序输出结果：\n# 输出Config Provider提前设置好的信息 # 包括用户自定义信息，和默认信息 # 准备Input：自定义信息，默认信息 # 得到Output: 通过Config Provider获取所有配置信息 main.Params{\u0026#34;theme\u0026#34;:\u0026#34;mytheme\u0026#34;, \u0026#34;timeout\u0026#34;:\u0026#34;30s\u0026#34;} \u0026#34;mytheme\u0026#34; \u0026#34;30s\u0026#34; Program exited. 了然于胸 - collectModules时序图 # 经过loadConfig和applyConfigDefaults，我们已经将用户自定义信息和默认信息都归置妥当，并且放在了Config Provider中，方便查用。\nHugo在拿到这些信息后，立马着手的事情就是collectModules，也就是收集模块信息了。\n正如上图中loadModulesConfig所示，拿到配置信息后，就进行解码decodeConfig操作。 在我们的 示例中，我们的项目用到了名为mytheme的主题，所以在项目配置信息中，我们需要把主题添加到导入项Imports中。\n准备好了模块的配置信息后，接下来就是要根据这些配置信息，对模块进行处理了。\n需要先准备好回调函数beforeFinalizeHook，为什么要准备这和个回调函数呢？ 我们先把这个疑问放一放，一会我们就能发现实际的触发场景。\n回调函数设置好后，接着就开始收集模块了。 如上图左上角所示，首先需要创建Module Client用来具体处理模块的收集工作。 为什么要叫Client呢？ 这是因为现在Hugo支持Golang的mod模式，意味着可以用go.mod来导入主题，那我们就需要下载依赖包 - 主题工程来管理依赖了。 这样来看，叫客户端是不是就不难理解了。 在我们的 示例中，主题目录是用来做流程讲解示范的，只有一个文本文件，所以这里的场景并不涉线上go模块加载。\n客户端设置好后，开始收集，如上图中间所示，收集过程总共分四步：\n按配置递归收集所有模块 - Collect 设置处于活跃状态的模块 - setActiveMods 触发提前设置的回调函数 - HookBeforeFinalize 移除重复的挂载信息 - Finalize Collect\n先为项目创建工程模块Project Module，然后开始递归收集模块：\nfunc (c *collector) collect() { ... // c.gomods is [], GetMain() returns ni projectMod := createProjectModule(c.gomods.GetMain(), c.ccfg.WorkingDir, c.moduleConfig) // module structure, [project, others...] if err := c.addAndRecurse(projectMod, false); err != nil { c.err = err return } ... } 这里为什么会用到递归呢？ 因为在Hugo中，模块之间是有相互依赖的。 通过最开始的模块配置信息也可以看出，我们把依赖的模块放在了Imports中，Project Module就需要导入\u0026quot;mytheme\u0026quot;模块。 在实际情况中，\u0026ldquo;mytheme\u0026quot;有可能也是依赖于其它的主题，所以也需要导入其它模块。\n从上面时序图右下方可以看到，addAndRecurse做了四件事：\n为导入的模块创建模块文件夹，用来放置模块所有文件 应用主题配置，就像最开始解析项目模块的配置信息一样，看是否还需要导入其它模块 将模块添加到模块列表中 为新模块重复上述步骤 这样，我们就能顺着项目模块的配置信息，逐个将所有的模块信息收集齐全了。\nsetActiveMods\n递归收集完所有模块信息后，需要根据用户配置，进一步将禁用的模块给过滤到，留下这一次构建所需要的模块。\nHookBeforeFinalize\n过滤完模块后，在Finalize敲定前，是时候回调我们之前设置好地回调函数了。\n除了加载多语言设置处，回调函数所做的操作主要集中在上面时序图的右下脚。 就是为项目模块准备好所有的挂载Mount，包括Content, Static, Layouts, Archetypes, Data, Assets, i18n，共七个组件。 其中Content和其它的组件有点不一样。 因为Content挂载点和多语言一一对应，也就是说有几种语言，就会有几个内容目录。\nFinalize\n等有了所有的模块的信息，挂载点也收集完毕后，我们还要做一件事情。 那就是要保证这些挂载点在全局视野下，没有重复。\n结合时序图，我们进一步将其中的关键对象结构体，根据这些结构体的属性和行为，按流程处理后所得到的最终结果放在一起，可视化出来。 方便大家理解：\n抽象总结 - 输入不同类型的值，输出标准的configProvider # 在上图中，通过下方输出部分可以看出，一个模块配置项，对应一个模块。\n在左边的模块配置信息中，包含了模块之间的依赖信息。 在上面的示例中项目模块饱含了主题模块。\n在右边的模块实例中，首先要区分哪一个是项目模块，因为项目模块是站点构建的起点。 所以在模块中需要能标识身份信息的字段projectMod。\n如果从挂载Mounts的角度来看模块，那每个模块实际上就是一个合并后的根文件系统。 Hugo将这个文件系统用七个组件进行了划分。\n项目模块必需得包含这些信息，但因为依赖于其它模块，所以需要将项目模块放在最后处理。 Hugo将项目模块放在了模块队列的第一个，并用一个回调函数帮助在合适的时间点，对项目模的挂载进行了统一的处理。\n再用Input -\u0026gt; [?] -\u0026gt; Output模型来进行分析，可以抽象为以下模型： 主题信息来源于用户自定义信息，作为输入传入收集模块功能单元。 在处理过程中，Hugo按Name, Module Config, Module, Mounts的对应关系，将模块相关信息进行处理。 最终生成所有模块的信息，并通过将这些信息设置在Config Provider中，为后续的操作做好准备。\n动手实践 - Show Me the Code of collectModules # 在知道collectModules的实现原理后。 按照我们的传统，让我们动动小手，用代码来总结代码，巩固一下知识。\n可以这里线上尝试， Show Me the Code, try it yourself\n代码里有注解说明，代码样例：\npackage main import \u0026#34;fmt\u0026#34; type Mount struct { // relative path in source repo, e.g. \u0026#34;scss\u0026#34; Source string // relative target path, e.g. \u0026#34;assets/bootstrap/scss\u0026#34; Target string // any language code associated with this mount. Lang string } type Import struct { // Module path Path string } // Config holds a module config. type Config struct { Mounts []Mount Imports []Import } type Module interface { // Config The decoded module config and mounts. Config() Config // Owner In the dependency tree, this is the first module that defines this module // as a dependency. Owner() Module // Mounts Any directory remappings. Mounts() []Mount } type Modules []Module var modules Modules // moduleAdapter implemented Module interface type moduleAdapter struct { projectMod bool owner Module mounts []Mount config Config } func (m *moduleAdapter) Config() Config { return m.config } func (m *moduleAdapter) Mounts() []Mount { return m.mounts } func (m *moduleAdapter) Owner() Module { return m.owner } // happy path to easily understand func main() { // project module config moduleConfig := Config{} imports := []string{\u0026#34;mytheme\u0026#34;} for _, imp := range imports { moduleConfig.Imports = append(moduleConfig.Imports, Import{ Path: imp, }) } // Need to run these after the modules are loaded, but before // they are finalized. collectHook := func(mods Modules) { // Apply default project mounts. // Default folder structure for hugo project ApplyProjectConfigDefaults(mods[0]) } collectModules(moduleConfig, collectHook) for _, m := range modules { fmt.Printf(\u0026#34;%#v\\n\u0026#34;, m) } } // Module folder structure const ( ComponentFolderArchetypes = \u0026#34;archetypes\u0026#34; ComponentFolderStatic = \u0026#34;static\u0026#34; ComponentFolderLayouts = \u0026#34;layouts\u0026#34; ComponentFolderContent = \u0026#34;content\u0026#34; ComponentFolderData = \u0026#34;data\u0026#34; ComponentFolderAssets = \u0026#34;assets\u0026#34; ComponentFolderI18n = \u0026#34;i18n\u0026#34; ) // ApplyProjectConfigDefaults applies default/missing module configuration for // the main project. func ApplyProjectConfigDefaults(mod Module) { projectMod := mod.(*moduleAdapter) type dirKeyComponent struct { key string component string multilingual bool } dirKeys := []dirKeyComponent{ {\u0026#34;contentDir\u0026#34;, ComponentFolderContent, true}, {\u0026#34;dataDir\u0026#34;, ComponentFolderData, false}, {\u0026#34;layoutDir\u0026#34;, ComponentFolderLayouts, false}, {\u0026#34;i18nDir\u0026#34;, ComponentFolderI18n, false}, {\u0026#34;archetypeDir\u0026#34;, ComponentFolderArchetypes, false}, {\u0026#34;assetDir\u0026#34;, ComponentFolderAssets, false}, {\u0026#34;\u0026#34;, ComponentFolderStatic, false}, } var mounts []Mount for _, d := range dirKeys { if d.multilingual { // based on language content configuration // multiple language has multiple source folders if d.component == ComponentFolderContent { mounts = append(mounts, Mount{Lang: \u0026#34;en\u0026#34;, Source: \u0026#34;mycontent\u0026#34;, Target: d.component}) } } else { mounts = append(mounts, Mount{Source: d.component, Target: d.component}) } } projectMod.mounts = mounts } func collectModules(modConfig Config, hookBeforeFinalize func(m Modules)) { projectMod := \u0026amp;moduleAdapter{ projectMod: true, config: modConfig, } // module structure, [project, others...] addAndRecurse(projectMod) // Add the project mod on top. modules = append(Modules{projectMod}, modules...) if hookBeforeFinalize != nil { hookBeforeFinalize(modules) } } // addAndRecurse Project Imports -\u0026gt; Import imports func addAndRecurse(owner *moduleAdapter) { moduleConfig := owner.Config() // theme may depend on other theme for _, moduleImport := range moduleConfig.Imports { tc := add(owner, moduleImport) if tc == nil { continue } // tc is mytheme with no config file addAndRecurse(tc) } } func add(owner *moduleAdapter, moduleImport Import) *moduleAdapter { fmt.Printf(\u0026#34;start to create `%s` module\\n\u0026#34;, moduleImport.Path) ma := \u0026amp;moduleAdapter{ owner: owner, // in the example, mytheme has no other import config: Config{}, } modules = append(modules, ma) return ma } 输出结果：\n# collect theme as module start to create `mytheme` module # project module has no owner with default mounts \u0026amp;main.moduleAdapter{projectMod:true, owner:main.Module(nil), mounts:[]main.Mount{main.Mount{Source:\u0026#34;mycontent\u0026#34;, Target:\u0026#34;content\u0026#34;, Lang:\u0026#34;en\u0026#34;}, main.Mount{Source:\u0026#34;data\u0026#34;, Target:\u0026#34;data\u0026#34;, Lang:\u0026#34;\u0026#34;}, main.Mount{Source:\u0026#34;layouts\u0026#34;, Target:\u0026#34;layouts\u0026#34;, Lang:\u0026#34;\u0026#34;}, main.Mount{Source:\u0026#34;i18n\u0026#34;, Target:\u0026#34;i18n\u0026#34;, Lang:\u0026#34;\u0026#34;}, main.Mount{Source:\u0026#34;archetypes\u0026#34;, Target:\u0026#34;archetypes\u0026#34;, Lang:\u0026#34;\u0026#34;}, main.Mount{Source:\u0026#34;assets\u0026#34;, Target:\u0026#34;assets\u0026#34;, Lang:\u0026#34;\u0026#34;}, main.Mount{Source:\u0026#34;static\u0026#34;, Target:\u0026#34;static\u0026#34;, Lang:\u0026#34;\u0026#34;}}, config:main.Config{Mounts:[]main.Mount(nil), Imports:[]main.Import{main.Import{Path:\u0026#34;mytheme\u0026#34;}}}} # theme module owned by project module with no import in the example \u0026amp;main.moduleAdapter{projectMod:false, owner:(*main.moduleAdapter)(0xc000102120), mounts:[]main.Mount(nil), config:main.Config{Mounts:[]main.Mount(nil), Imports:[]main.Import(nil)}} Program exited. "},{"id":15,"href":"/docs/how/%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4/","title":"Index","section":"Docs","content":" Hugo 事件风暴 # Hugo的功能很全面，拥有强大的自定义函数库，可以用来制作模板、短代码等。 这在站点的构建过程中，可以帮助提供各种数据，如获取目录结构，主动加载文件。 以及页面信息汇总，方便展示分页列表或者搜索。 还可以帮助分类，提供标签服务。\n支持多语言，创建国际化站点一样简单。\n主题库更是能满足各种不同的个性化需求，更贴近专业使用场景，你还可以零成本切换。\nHugo是如何一步步将博客变成站点的？ 下面我们还是通过 游乐场实例，来一探究竟。\n邀你一起来动手。 用我们最喜欢的IDE，打开我们的 游乐场项目源码。 通过直接输出日志的方式，来看一看hugo的完整构建流程。\n$ cd /go/to/hugo-playground $ go run . 先来看一看主流程。 通过搜索以字符串\u0026quot;==\u0026gt; Process main:\u0026ldquo;开头的日志条目，我们可以了清楚的看到主函数的处理流程如下所示：\n==\u0026gt; Process main: prepare example project file systems ==\u0026gt; Process main: load configurations from config.toml and themes ==\u0026gt; Process main: setup hugo file systems based on machine file system and configurations ==\u0026gt; Process main: create hugo sites based on deps ==\u0026gt; Process main: hugo building... 准备样例文件系统。100%模拟真实项目，写入硬盘 加载项目配置文件 - config.toml，并解析配置信息，如读取配置主题theme = mytheme信息 准备好hugo file systems。因为hugo项目的默认结构有包含多个目录，hugo会根据不同目录生成多个文件系统。（tips: 可以用$ hugo new site \u0026lt;name\u0026gt; 命令查看默认项目目录结构） 创建hugo sites。hugo支持多语言，会为每个语言创建一个site。创建前需要准备好所有的依赖，如上面提到的文件系统就是依赖之一。 开始构建，并发布站点资源 GoLang Template # 从主流程可以看出，Hugo的渲染思路并不复杂，就是用模板(Layouts)，将不同的内容(Content)渲染成网站静态资源(Site)。\n而实现这一设计的核心技术就是GoLang Template。\n通过Markdown解析器将post.md解析成结构体Post 通过GoLang Template包根据index.html创建模板实例 执行并生成渲染后的最终结果 Show Me The Code # package main import ( \u0026#34;html/template\u0026#34; \u0026#34;os\u0026#34; ) // index html template var indexTemplate = \u0026#34;\u0026lt;html\u0026gt;\\n \u0026lt;body\u0026gt;\\n {{.Content}}\\n \u0026lt;/body\u0026gt;\\n\u0026lt;/html\u0026gt;\\n\u0026#34; // Post struct with exposed filed Content type Post struct { Content string } func main() { // New Post with content // Source file could be post.md post := Post{\u0026#34;\u0026lt;h2\u0026gt;Section\u0026lt;/h2\u0026gt;\\n \u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\\n\u0026#34;} // New template with indexTemplate, name as \u0026#34;index\u0026#34; tmpl, err := template.New(\u0026#34;index\u0026#34;).Parse(indexTemplate) if err != nil { panic(err) } // Render post with template `index` // write result to os.Stdout err = tmpl.Execute(os.Stdout, post) if err != nil { panic(err) } } Output Example:\n# body content with tag h2: Section # tag p: Hello World \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026amp;lt;h2\u0026amp;gt;Section\u0026amp;lt;/h2\u0026amp;gt; \u0026amp;lt;p\u0026amp;gt;Hello World\u0026amp;lt;/p\u0026amp;gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Try it yourself\n了解了站点渲染的基本原理后，我们再从全局视角来看看Hugo完整的构建流程。\n看Hugo对站点构建的理解和设计 # 在 游乐场项目源码下， 运行以下命令：\n$ cd /go/to/hugo-playground $ go run . 就可以得到构建全流程日志，如下所示\n➜ hugo-playground git:(main) go run . ==\u0026gt; Process main: prepare example project file systems ==\u0026gt; Process main: load configurations from config.toml and themes ==\u0026gt; Process LoadConfig: start init configLoader ==\u0026gt; Process loadConfig: load config.toml from hard disk ==\u0026gt; Process loadConfig: set loaded config map to configLoader.cfg with key \u0026#39;\u0026#39; ==\u0026gt; Process LoadConfig: apply config defaults ==\u0026gt; Process LoadConfig: load modules config ==\u0026gt; Process decodeConfig: set mytheme as Imports in DefaultModuleConfig, Config{} ==\u0026gt; Process LoadConfig: collect modules with modulesConfig ==\u0026gt; Process collectHook: apply default mounts to project module ==\u0026gt; Process collectModules: set active modules to config with key \u0026#39;allModules\u0026#39; ==\u0026gt; Process LoadConfig: done ==\u0026gt; Process main: setup hugo file systems based on machine file system and configurations ==\u0026gt; Process newFs: create /public folder ==\u0026gt; Process newFs: new base path fs \u0026amp;BasePathFs{} ==\u0026gt; Process main: create hugo sites based on deps ==\u0026gt; Process createSitesFromConfig: start ==\u0026gt; Process NewLanguages: create multiple languages, only \u0026#39;en\u0026#39; in our case ==\u0026gt; Process newSite: create site with DepsCfg with language setup ==\u0026gt; Process media.DecodeTypes: set default media types ==\u0026gt; Process output.DecodeFormats: set default output formats based on media types, and customized output formats configuration ==\u0026gt; Process site output formats: map siteOutputFormats to every hugo page types(KindPage, KindHome...) ==\u0026gt; Process createSitesFromConfig: end ==\u0026gt; Process newHugoSites: get number of worker ==\u0026gt; Process newHugoSites: init HugoSites ==\u0026gt; Process newHugoSites: add data to h.init ==\u0026gt; Process newHugoSites: add layouts to h.init ==\u0026gt; Process newHugoSites: configLoader applyDeps ==\u0026gt; Process applyDeps: set cfg.TemplateProvider with DefaultTemplateProvider ==\u0026gt; Process applyDeps: new deps ==\u0026gt; Process New PathSpec: new PathSpec with all source filesystem built ==\u0026gt; Process New resources Spec: with pathSpec, outputFormats, MediaTypes ==\u0026gt; Process New content Spec: content converter provider inside ==\u0026gt; Process New source Spec: with source filesystem and language ==\u0026gt; Process applyDeps-onCreate: set site publisher as DestinationPublisher ==\u0026gt; Process applyDeps-onCreate site initializeSiteInfo: set site title and owner ==\u0026gt; Process applyDeps-onCreate pageMap: with pageTree, bundleTree and pages, sections, resources ==\u0026gt; Process applyDeps-onCreate site PageCollections: with pageMap ==\u0026gt; Process applyDeps-onCreate site RefLinker: to manage ref link ==\u0026gt; Process applyDeps: deps LoadResources to update template provider, need to make template ready ==\u0026gt; Process templateProvider Update: new TemplateExec ==\u0026gt; Process GoFuncs: map template.GoFuncs to funcMap ==\u0026gt; Process GoFuncs: map texttemplate.GoFuncs to funcMap ==\u0026gt; Process newTemplateNamespace: with funcMap ==\u0026gt; Process NewLayoutHandler: to process layout request ==\u0026gt; Process main: hugo building... ==\u0026gt; Process HugoSites Build: start ==\u0026gt; Process HugoSites Build process: site initialize with title and owner ==\u0026gt; Process readAndProcessContent: new source spec with PathSpec, ContentInclusionFilter and BaseFs Content.Fs ==\u0026gt; Process readAndProcessContent: collect content with PagesProcessor ==\u0026gt; Process AssemblePages: pageMaps to assemble all pages ==\u0026gt; Process pm.CreateMissingNodes: check root section ==\u0026gt; Process assemblePages: assembleSections firstly ==\u0026gt; Process assemblePages: walk pageMap pages ==\u0026gt; Process pageMap pages.Walk: new page from content node ==\u0026gt; Process pageMap pages.Walk: assemble resources ==\u0026gt; Process render: h.init layouts do start ==\u0026gt; Process newHugoSites: h.init run s.Tmpl().MarkReady ==\u0026gt; Process render: init site render formats ==\u0026gt; Process site preapre pages for render: pageState init output format ==\u0026gt; Process pageState: init page do start ==\u0026gt; Process pageState: init contentProvider with page content output ==\u0026gt; Process site preapre pages for render: pageState init output format ==\u0026gt; Process pageState: init page do start ==\u0026gt; Process pageState init: new page paths ==\u0026gt; Process pageState init: new page output ==\u0026gt; Process pageState init: init OutputFormatsProvider, targetPathDescriptor, SitesProvider ==\u0026gt; Process pageState: new page content output ==\u0026gt; Process pageState: init contentProvider with page content output ==\u0026gt; Process site preapre pages for render: pageState init output format ==\u0026gt; Process pageState: init page do start ==\u0026gt; Process pageState init: new page paths ==\u0026gt; Process pageState init: new page output ==\u0026gt; Process pageState init: init OutputFormatsProvider, targetPathDescriptor, SitesProvider ==\u0026gt; Process pageState: new page content output ==\u0026gt; Process pageState: init contentProvider with page content output ==\u0026gt; Process render: render start with siteRenderContext ==\u0026gt; Process Site render: render pages ==\u0026gt; Process renderPages: start 3 workers to do page rendering ==\u0026gt; Process render page: resolve template for page ==\u0026gt; Process render page: resolve template for page ==\u0026gt; Process render page: resolve template for page ==\u0026gt; Process render and write page: render for template ==\u0026gt; Process output initContent: init render hooks ==\u0026gt; Process output initContent: content to render ==\u0026gt; Process render and write page: publish page ==\u0026gt; Process render and write page: publish page ==\u0026gt; Process Site render: render 404 ==\u0026gt; Process pageState init: new page paths ==\u0026gt; Process pageState init: new page output ==\u0026gt; Process pageState init: init OutputFormatsProvider, targetPathDescriptor, SitesProvider ==\u0026gt; Process hugoSite render: cross sites robots TXT ==\u0026gt; Process pageState init: new page paths ==\u0026gt; Process pageState init: new page output ==\u0026gt; Process pageState init: init OutputFormatsProvider, targetPathDescriptor, SitesProvider ==\u0026gt; Process render and write page: render for template ==\u0026gt; Process render and write page: publish page ==\u0026gt; Process HugoSites Build: done 直观感受好像没有Golang Template流程看起来那么清晰。\n我们现在利用DDD领域驱动开发的事件风暴方法来对日志进行分析，以帮助我们进一步理解Hugo对站点构建这一领域的理解。\nDDD之事件风暴 # 为了帮助我们充分理解某一特定领域，统一团队所有成员对这一领域知识的认知。 DDD提出了事件风暴这一方法。 该方法以研讨会的形式，让领域专家和团队成员坐在一起，用对话的形式将领域中关键事件一一识别出来，并用卡片将达成一致的事件记录下来，贴在墙壁或白板上。\n我们的领域专家就是Hugo的源码库，这里就是简化后的 Hugo游乐场。 而上面产出的全流程日志，就是站点领域专家对关键事件的描述。\nHugo构建之主流程 - 事件风暴版 # 和之前的时序图版本对比：\n同样轻量，便于理解。\nHugo构建之LoadConfig # 通过对日志3到13行的分析，加载配置项的关键事键按发生时间排列如图如示：\n==\u0026gt; Process main: load configurations from config.toml and themes ==\u0026gt; Process LoadConfig: start init configLoader ==\u0026gt; Process loadConfig: load config.toml from hard disk ==\u0026gt; Process loadConfig: set loaded config map to configLoader.cfg with key \u0026#39;\u0026#39; ==\u0026gt; Process LoadConfig: apply config defaults ==\u0026gt; Process LoadConfig: load modules config ==\u0026gt; Process decodeConfig: set mytheme as Imports in DefaultModuleConfig, Config{} ==\u0026gt; Process LoadConfig: collect modules with modulesConfig ==\u0026gt; Process collectHook: apply default mounts to project module ==\u0026gt; Process collectModules: set active modules to config with key \u0026#39;allModules\u0026#39; ==\u0026gt; Process LoadConfig: done 引入配置加载器，用来处理配置项的相关操作。 从硬盘读取配置文件。因为Hugo支持多种格式的配置项，如yaml, toml, json等，所以要适配这些不同类型的配置文件。 解析配置文件，根据文件后缀选用相应的解析工具，读取配置文件中的配置信息。 将解析过后的map值，保存到配置加载器的根结点，对应的键值是空字符串''。并会对所有的配置键值进行小写处理，并保存，所以配置项对大小写不敏感。 应用默认配置。在用户的配置文件上中没有进行说明的，将会采用Hugo默认配置项。 加载模块配置项。这里引入了模块的概念，但和Nginx的模块有所区别。Hugo的模块指的是包含Hugo文件标准结构的目录，如主题，用户项目本身。 其中主题是可以嵌套主题的，也就是说我们所使用的Theme A可能是基于Theme B构建的，而项目本身也有自己的标准目录，也可以有自己的layouts文件夹。 那覆盖顺序就是Project Layouts \u0026gt; Theme A Layouts \u0026gt; Theme B Layouts。Hugo模块只有两类，Project模块和其它模块。 从文件结构上讲，其实是一样的。 解析模块配置项。在项目配置文件config.toml中通常会配置主题项：theme = \u0026ldquo;mytheme\u0026rdquo;，这就是告诉配置加载器，本项目依赖于这个主题，即这个模块。 设置解析结果到模块配置项。既然模块之间可以相互依赖，那加载资源的时候就有加载顺序，需要将依赖关系提前梳理好。 Hugo实现这一需求依赖的是模块配置项的Imports字段。 根据模块配置，收集模块。通过上一步的关系梳理，现在就是加载模块的时候了，将模块文件结构，按标准文件结构解析成一个个的挂载项，为构建文件系统做准备。 应用默认挂载到项目模块。项目本身也是遵循的标准文件结构的，也需要将文件结构消化成相应的挂载项。 将活跃模块添加到配置项。在我们的用例中，有Project和Mytheme两个模块。在配置项中，对应的字段是\u0026quot;allModule\u0026rdquo;。 配置项包含了所有配置相关的信息，除了用户自定义的字段，还有Hugo的默认配置。 其中较为特殊的就是\u0026quot;allModule\u0026quot;字段，里面包含了包括项目模块在内的所有模块信息。 LoadConfig不仅包含常规配置项信息，不包含了模块的配置信息。\nHugo构建之HugoFs # 通过对日志14到24行的分析，可以看到Hugo对自身File System的理解和设计：\n==\u0026gt; Process main: setup hugo file systems based on machine file system and configurations ==\u0026gt; Process newFs: create /public folder ==\u0026gt; Process newFs: new base path fs \u0026amp;BasePathFs{} ==\u0026gt; Process main: create hugo sites based on deps ==\u0026gt; Process createSitesFromConfig: start ==\u0026gt; Process NewLanguages: create multiple languages, only \u0026#39;en\u0026#39; in our case ==\u0026gt; Process newSite: create site with DepsCfg with language setup ==\u0026gt; Process media.DecodeTypes: set default media types ==\u0026gt; Process output.DecodeFormats: set default output formats based on media types, and customized output formats configuration ==\u0026gt; Process site output formats: map siteOutputFormats to every hugo page types(KindPage, KindHome...) ==\u0026gt; Process createSitesFromConfig: end 创建public文件夹。public是默认的站点发布文件夹名，当然，也支持自定义。 创建基本路径Fs。只包含源项目文件系统和发布文件系统，也是Hugo文件系统基础所在。 创建多语言。Hugo支持多语言站点发布。会是语言为单位，在包含基础配置信息的基础上，准备相应的语言配置信息，也可以将语言描述对象理解为语言配置项。 设置站点依赖。如果要构建站点，会依赖很多信息。Hugo将所有的信息都放在了依赖里。如上面提到的基础路径文件系统及配置项。当然远不止这两项。 设置站点语言。Hugo公为每个语言生成一个站点。 设置站点默认媒体类型。站点资源要符合Web服务器要求，就需要保证站点的媒体内容是Hugo所支持的，并可正确转换成Web服务器支持的媒体类型。 设置站点默认输出格式。用户产出的内容将会以Web服务器支持的格式进行输出，所以输出格式也是站点的一部分。 映射站点输出格式到所有页面类型。Hugo将页面分为了五类，每一类和输出格式是如何对应的，也需要在这里进行说明。 从HugoFs可以理解到。 Hugo认为一个站点，需要包含：\n源，也就是用户创造的内容。 发布地址，public文件系统 配置信息，包含用户自定义、默认配置，及所有模块的相关信息。 语言，和站点一一对应，多个语言对应多个站点 输出格式，以什么形式进行渲染。输出格式中包含了媒体类型，如HTML格式通常是text/html类型。 Hugo构建之Sites # 通过对日志25到46行的分析，可以看到Hugo对Sites的理解和设计：\n==\u0026gt; Process newHugoSites: get number of worker ==\u0026gt; Process newHugoSites: init HugoSites ==\u0026gt; Process newHugoSites: add data to h.init ==\u0026gt; Process newHugoSites: add layouts to h.init ==\u0026gt; Process newHugoSites: configLoader applyDeps ==\u0026gt; Process applyDeps: set cfg.TemplateProvider with DefaultTemplateProvider ==\u0026gt; Process applyDeps: new deps ==\u0026gt; Process New PathSpec: new PathSpec with all source filesystem built ==\u0026gt; Process New resources Spec: with pathSpec, outputFormats, MediaTypes ==\u0026gt; Process New content Spec: content converter provider inside ==\u0026gt; Process New source Spec: with source filesystem and language ==\u0026gt; Process applyDeps-onCreate: set site publisher as DestinationPublisher ==\u0026gt; Process applyDeps-onCreate site initializeSiteInfo: set site title and owner ==\u0026gt; Process applyDeps-onCreate pageMap: with pageTree, bundleTree and pages, sections, resources ==\u0026gt; Process applyDeps-onCreate site PageCollections: with pageMap ==\u0026gt; Process applyDeps-onCreate site RefLinker: to manage ref link ==\u0026gt; Process applyDeps: deps LoadResources to update template provider, need to make template ready ==\u0026gt; Process templateProvider Update: new TemplateExec ==\u0026gt; Process GoFuncs: map template.GoFuncs to funcMap ==\u0026gt; Process GoFuncs: map texttemplate.GoFuncs to funcMap ==\u0026gt; Process newTemplateNamespace: with funcMap ==\u0026gt; Process NewLayoutHandler: to process layout request 获取worker容量。将会决定在渲染过程中有几个goroutine用来渲染页面。 初始化Hugo Sites。在Hugo里有两个site，一个是Sites，另一个是HugoSites。Site和Language一一对应，HugoSites和Site是一对多的关系。 注册data相关处理行为到初始化。Hugo用到了lazy init的，因为有一些初始化的工作依赖于某些处理后的数据，需要在一开始说明，但在适当的时机激活。 注册layouts相关处理行为到初始化。同上，Hugo layouts就相当于是golang里的模板，这里会真正加载内部模板和用户自定义模板。 配置加载器应用依赖。将依赖关联到配置加载器中。 设置默认模板提供方到配置。负责提供模板相关的服务，并且关联到配置中。 新建依赖。创建依赖实例，关联之前准备的依赖项。 新建路径规范。PathSpec，根据所有模块的挂载信息，和Hugo标准文件结构，生成OverlayFs格式的统一文件系统服务。 新建资源规范。ResourceSpec，基于PathSpec，提供不同资源的处理工具，如图片。 新建内容规范。ContentSpec，基于PathSpec中的Content.Fs，提供站点内容相关的具体服务，如内容长度统计等。 新建来源规范。SourceSpec，对BaseFs中的source统一管理，提供过滤等服务。 设置站点发布者。当站点准备好发布时，发布相关的工作都由发布者负责。 设置站点标题。对站点基础信息标题进行设置，包括标题的处理函数。如全大写、驼峰、首标题第一个字首字母大写等。 设置站点所有者。既站点的拥有者。 初始化页面映射。PageMap，一个站点会有一个PageMap，用来管理所有的Page，在Hugo里Page指所有站点不同类型的页面，像Home, Section, Term等。 设置站点页面收集器。如何将实际用户创作的内容，如post、页面管理生成的内容，如section和目录结构一一映射，并用PageMap管理起来，谁来负责 - 页面收集器。 设置站点索引链接器。页面是一个个的页面，页面之间的关系需要索引来进行管理。 通过模板提供者开始更新。通过上面的配置信息，对模板配置进行更新。 新建模板执行器。当模板全部加载和转换完成后，新建TemplateExec对外提供执行功能，将内容按模板进行渲染。 收集模板函数到函数映射。Golang Template提供了一些内置函数，方便用程序的形式处理一些内容，如print。Hugo对此进行了增强，定义了很多功能强大的函数。 收集文本函数到函数映射。Hugo提供了两大类函数，一大类来自于默认template，另一大类来自于text template。 新建模板命名空间。前模板相关信息封闭在命名空间中，这样方便治理各类模板和函数。 新建layout处理器。在对外提供服务时，还可以根据需求对layout进行最后的转换，以满足一些定制化需求。 Hugo构建之LoadConfig # 通过对日志47到99行的分析，可以看到Hugo如何构建站点的：\n==\u0026gt; Process main: hugo building... ==\u0026gt; Process HugoSites Build: start ==\u0026gt; Process HugoSites Build process: site initialize with title and owner ==\u0026gt; Process readAndProcessContent: new source spec with PathSpec, ContentInclusionFilter and BaseFs Content.Fs ==\u0026gt; Process readAndProcessContent: collect content with PagesProcessor ==\u0026gt; Process AssemblePages: pageMaps to assemble all pages ==\u0026gt; Process pm.CreateMissingNodes: check root section ==\u0026gt; Process assemblePages: assembleSections firstly ==\u0026gt; Process assemblePages: walk pageMap pages ==\u0026gt; Process pageMap pages.Walk: new page from content node ==\u0026gt; Process pageMap pages.Walk: assemble resources ==\u0026gt; Process render: h.init layouts do start ==\u0026gt; Process newHugoSites: h.init run s.Tmpl().MarkReady ==\u0026gt; Process render: init site render formats ==\u0026gt; Process site preapre pages for render: pageState init output format ==\u0026gt; Process pageState: init page do start ==\u0026gt; Process pageState: init contentProvider with page content output ==\u0026gt; Process site preapre pages for render: pageState init output format ==\u0026gt; Process pageState: init page do start ==\u0026gt; Process pageState init: new page paths ==\u0026gt; Process pageState init: new page output ==\u0026gt; Process pageState init: init OutputFormatsProvider, targetPathDescriptor, SitesProvider ==\u0026gt; Process pageState: new page content output ==\u0026gt; Process pageState: init contentProvider with page content output ==\u0026gt; Process site preapre pages for render: pageState init output format ==\u0026gt; Process pageState: init page do start ==\u0026gt; Process pageState init: new page paths ==\u0026gt; Process pageState init: new page output ==\u0026gt; Process pageState init: init OutputFormatsProvider, targetPathDescriptor, SitesProvider ==\u0026gt; Process pageState: new page content output ==\u0026gt; Process pageState: init contentProvider with page content output ==\u0026gt; Process render: render start with siteRenderContext ==\u0026gt; Process Site render: render pages ==\u0026gt; Process renderPages: start 3 workers to do page rendering ==\u0026gt; Process render page: resolve template for page ==\u0026gt; Process render page: resolve template for page ==\u0026gt; Process render page: resolve template for page ==\u0026gt; Process render and write page: render for template ==\u0026gt; Process output initContent: init render hooks ==\u0026gt; Process output initContent: content to render ==\u0026gt; Process render and write page: publish page ==\u0026gt; Process render and write page: publish page ==\u0026gt; Process Site render: render 404 ==\u0026gt; Process pageState init: new page paths ==\u0026gt; Process pageState init: new page output ==\u0026gt; Process pageState init: init OutputFormatsProvider, targetPathDescriptor, SitesProvider ==\u0026gt; Process hugoSite render: cross sites robots TXT ==\u0026gt; Process pageState init: new page paths ==\u0026gt; Process pageState init: new page output ==\u0026gt; Process pageState init: init OutputFormatsProvider, targetPathDescriptor, SitesProvider ==\u0026gt; Process render and write page: render for template ==\u0026gt; Process render and write page: publish page ==\u0026gt; Process HugoSites Build: done 检查站点标题。开始构建之前，先检查一下是否设置好了这些基础信息。 检查站点所有者信息。同上。 为内容Fs新建来源规范。SourceSpec，针对正在构建的站点，进一步定制化，说明哪些文件需要处理，哪些应该忽略。 用页面收集器收集站点内容。上一阶段是准备阶段，构建阶段是真正地收集阶段。 用页面映射聚集所有页面。一个站点对应一个PageMap，根据上面收集的结果，对收集到的页面进行一一映射管理。 走查缺失结点。Hugo引入了section概念，这样方便管理内容的层级关系。 在收集页面时，Hugo用的是 基数树对页面进行管理的。 这样对于section而言，就需要在树结构中补全相应缺失结点。 聚集章节。章节也是一种页面类型，上面是针对页面走查缺失的章节结点，对页面信息进行补全。这里是专门用来处理章节。 为内容结点创建页面。我们最终的目标是把收集到的信息，用模板给渲染出来，这里创建的页面PageState结构体，就是上面代码例子中的Post，用来为渲染做准备。 聚集页面资源。一篇博客中会引用一起图片，数据等，都属于博客的资源，需要和页面对应上。 回调layout注册项进行初始化。在一开始注册的模板提供方和注册到lazy init里的加调方法，对模板内容文件进行处理。如模板解析，加入命名空间等。 初始化渲染格式。通过前面的输出信息，明确渲染要求，并进行输出。 初始化页面状态。PageState，前面是准备初始化所需的内容，这里专门进行初始化。 作为渲染的关键，因为所有模板需要的信息都依赖于这个结构体，这导致PageState结构体体积巨大。 初始化内容提供商。对于渲染阶段而言，重点是将内容转换为站点文件，抽象出对应的服务，有助于封装隐藏在背后的复杂度，方便消费者使用。 标明页面内容输出格式。Hugo支持对同一页面输出多种格式，这里就是为满足用户的输出需求进行准备。 新建页面路径。PagePath，为PageState准备页面路径相关的信息，帮助说明输出格式，及目标发布地址。 新建页面输出。PageOutput，包含所有输出所需要的信息，如页面渲染提供商、Table of Content提供商等。 初始化页面输出供应商。获取相应的配置信息并初始化。 初始化页面目标路径描述符。页面将要发布到哪个目标，需要用描述符承载相应的信息。 初始化页面站点供应商。和站点相关的信息在此维护。 新建页面内容输出。和页面内容输出相关的信息在此提供。 用页面输出初始化内容供应商。内容供应商依赖于页面内容输出。 Worker开始渲染页面。当渲染流程中的对象都准备就绪时，由上一步提供的worker开始获取渲染业务，并进行实际渲染。 为页面查找模板。通过模板提供商查找页面模板，为了组织起所有内容，Hugo提供了模板查找逻辑，帮助定位合适的模板。 用模板渲染页面。通过模板执行器，对PageState进行渲染。 初始化渲染回调钩子。提供渲染过程中的交互接口。 初始化渲染内容。为页面输出配置相关博客内容。 发布页面。将渲染好的内容发布到对应目标地址。 渲染404。对应用户博客，404页面属于独立页面，可以重用上面的流程进行渲染和发布。 渲染robots TXT说明文件。对于搜索引擎提供爬取说明。和404页面一样属于独立页面。 小结 # 本章用DDD事件驱动开发中的事件风暴Event Storming方法，对Hugo构建全流程中的关键事件进行了收集和分析，以帮助大家了解到构建的全过程。\n可以看到，基于Golang Template提供的基础功能，Hugo在此基础上，进行了增强：\nHugo眼中的站点构建，需要涵盖从用户博客项目到发布站点的全流程。\n首先要通过配置文件理解用户对站点的具体需求，如想用哪个风格的主题，站点叫什么名字，要支持几种语言，以及以什么格式进行输出。 为了减轻用户的认知负担，Hugo采用主动配置加默认配置的策略，帮助用户补全构建站点所需要的其它信息。\n了解了用户需求后，Hugo需要将用户的博客内容有效地进行组织。 项目内包含了主题，甚至主题里面还嵌套了主题。 还包含了项目本身的所有文件。 无论是主题，还是博客本身，都遵循下面这一目录结构:\n. ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── static └── themes 在组织这些文件时，就需要考虑这些文件的依赖关系，像layouts之间是覆盖的关系，这就对挂载顺序有要求。 而像static目录相对比较特殊，所有的文件是什么样，就原封不动的拷贝到最终目录。 面对这些需求，Hugo的做法是将博客本身视为一个模块，同样将主题模块也视为一个模块，并清晰的用挂载点来帮助说明具体的信息，并将解析后的信息放入配置结构中。 后续通过这些信息，用OverlayFs技术提供需要合并的服务，用BaseFs提供基础的文件服务，还有大而全的标准服务。\n配置信息全了，文件系统也按需求准备好了，接下来就要开始收集站点的页面了。 Hugo为content目录定义了Section章节概念：\ncontent └── blog \u0026lt;-- Section, because first-level dir under content/ ├── funny-cats │ ├── mypost.md │ └── kittens \u0026lt;-- Section, because contains _index.md │ └── _index.md └── tech \u0026lt;-- Section, because contains _index.md └── _index.md 这样，在扫描所有文章的同时，还需要关注章节的相关信息。 所以在扫描完所有的文章后，还需要补全章节的结点，并进行专门的章节扫描。\n最后根据输出的要求，用layouts模板对收集到的页面信息PageState进行渲染，输出并发布到指定目录。\n"},{"id":16,"href":"/docs/how/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/","title":"Index","section":"Docs","content":" Hugo基础架构 # 通过 个人站点和 自定义主题实例，我们可以了解到如何使用Hugo创建自己的站点以及主题。 使用起来很简单，很快就能上手。\n同时Hugo还是基于Apache 2.0协议的开源项目，这意味着你完全可以大胆地发挥自己的创造力。\n比如针对源码领域的站点，像 深入理解Hugo，将源码和注解分离，并可以在 Golang Play上执行。 让源码的学习体验更加立体，不仅有解释，还能参与其中，修改样例，进一步帮助理解。\n目前Hugo还无法支持构建这样的站点，主要有两个原因。 一是 内容格式，Hugo目前主要支持的内容格式是Markdown，而上面的内容格式是.go源码文件。 其次是 功能函数，Hugo并没有处理代码的函数可以直接使用，要想解析源码及注解。 虽然可以组合字符串函数进行处理，但使用起来繁琐，拓展起来困难，维护起来更是让人连连摇头。\n不过，源码都给我们了，还能要求更多吗？ 毕竟我们可是有追求的软件工程师啊！\n无论是从实用的角度，还是通过学习优秀源码，来进行交流学习的角度，我们都有充分的理由来对这一宝藏进行发掘。\n本章的目标就是打开藏宝图来了解Hugo的基础架构，主要从以下两个方向展开：\n对架构思路做一个概要说明，对基础架构有一个全貌的理解 从模块代码入手，讨论配置和语言的关系、Hugo的模块、文件系统的组织、站点内容的收集方案、模板的生命周期，以及发布的流程。 通过阅读本章内容，我们将会对Hugo这个站点构建工具有一个全面的认识，并对各阶段之间的关系有一个清晰的认识，为接下来详细源码实现讲解章节打好基础。\n出发吧，伟大的工程师啊！\nHugo的架构设计 # 结合Hugo站点构建领域 事件，和 Hugo游乐场源码，Hugo的架构设计会变得很清晰：\nHugo的架构思路很容易理解，主要分三大块，分别是配置模块，站点模块和依赖模块。\n配置模块\nHugo最先解析的，就是用户项目的配置文件config.toml。 由configLoader发起，从硬盘读取配置文件，解析后存储为键值对对象。 configLoader主要需完成三件事，加载用户项目配置文件是第一件，用来理解用户的自定义需求。 第二件是补全默认配置Defaults Config，这样才能保其它模块正常运作。 第三件是生成模块配置信息，从用户项目开始，将用户项目作为第一个模块 - project module，在我们的实例中还有第二个模块，那就是主题模块mytheme。 模块之间有依赖关系，并且只有一个所有者Owner。 项目模块project module比较特殊，因为是初始模块，所以不属于任何其它模块。\ntype Module interface { ... // Owner In the dependency tree, this is the first // module that defines this module as a dependency. Owner() Module ... } 所有信息收集齐全后，会对外提供config.Provider服务：可查询，可更新配置项。\nHugoSites模块\n这是构建站点的核心模块，相当于DDD中的聚合根，内部组织构建站点所需要的全部信息，对外提供站点构建服务。\nHugoSites的初始化依赖于DepsCfg和Site，没错，有两个site。 HugoSites和Site的关系是一对多，Site和Language的关系是一一对应的，所以多语言站点会为每一个语言创建一个站点，共同组成了HugoSites。\n语言项是由DepsCfg创建的，但会存储在config.Provider中，所以都用浅黄色标明。 而DepsCfg的初始化则依赖于Fs和config.Provider。 Fs记载了源文件地址和发布地址。 源文件来自于用户项目，也就是实际的硬盘文件系统。 发布地址是获取自config.Provider，默认的是public文件夹，在这里会检测是否已经存在，如果没有则主动创建。 最后将新创建的信息如workingDir等信息同步回config.Provider。\n可以看出，他们的依赖关系是HugoSites \u0026lt;- Site \u0026lt;- Language \u0026lt;- DepsCfg \u0026lt;- Fs。\nDeps模块\nHugo将构建站点所需要的所有服务和对象都称作依赖，全部放在了Deps中。\n在构建依赖的过程中，会生成提供模板的TemplateProvider； 明确输入输出的媒体类型MediaType；和输出格式的OutputFormats；都会更新到config.Provider中。\n也会为收集站点内容做好准备，会有Page Collection帮助收集。 最终发布站点时需要用到的发布服务则是Publisher。 这些都会更新到Site中。\n同时，还需要将资源统一管理，明确规范，这样可以保障在使用时的便捷性，也符合面向对向设计原则中的单一职责原则。 包含提供统一标准文件结构服务的Path Spec； 和拥有所有媒体类型和输出格式信息的Resources Spec； 以及针对Content信息提供服务的Content Spec； 加上帮助定义资源策略，如过滤功能的Source Spec。\n有了Deps的帮助，所有构建站点所需的信息，如原材料、规则和输出格式等，都已准备妥当。\n万事俱备，只欠东风！\nHugo的组件设计 # 架构图可以帮助我们从全局视角理解Hugo的架构设计。 现在让我们更近一步，从模块的角度来观察Hugo架构的细节\n配置和语言的关系 # Hugo提供了强大的配置功能，如配置文件、配置目录、配置主题等等。 构建站点过程中，只要是你能想到的定制化需求，基本都能通过配置实现。\n为了满足不同的定制化需求，Hugo的思路是首先要处理好多配置文件之间的关系，所以需要合并一些配置项，这样就需要大小写不敏感。 定制化只是一小部分，其它的通用信息，就用默认配置来进行说明。\n支持多语言是常见需求，现在好多软件遵循的策略就是国际化优先。 那Hugo是怎么理解语言和配置的关系呢？\n在 个人站点实例中，我们在config.toml中和语言相关的配置如下：\ndefaultContentLanguage = \u0026#39;zh\u0026#39; [languages] [languages.zh] languageName = \u0026#39;中文\u0026#39; contentDir = \u0026#39;content\u0026#39; weight = 1 [languages.en] languageName = \u0026#39;English\u0026#39; contentDir = \u0026#39;content.en\u0026#39; weight = 2 可以配置默认语言，支持的多语言有中文和英语。\n那这样看来，配置应该包含语言。 也就是说语言应该是配置结构体中的一个字段。 而事实是这样的吗？ 让我们还是从 Hugo游乐场源码出发，来一探究竟。\n在此之前，我们先从架构图中寻找线索： 可以看到，最终创建Language的地方是在DepsCfg，并不是Config。 这和我们的直觉是相反的，让我们来看看关键的config.Provider，DepsCfg和Language相关代码片断。\nconfig.Provider\n// Provider provides the configuration settings for Hugo. type Provider interface { ... Get(key string) any Set(key string, value any) ... } 可以看出，Provider接口提供了Get和Set方法，就像一个key/value仓库。 那语言相关的配置同样也存储在了Provider里面。\nDepsCfg\n// DepsCfg contains configuration options that can be used to configure Hugo // on a global level, i.e. logging etc. // Nil values will be given default values. type DepsCfg struct { // The language to use. Language *langs.Language // The configuration to use. Cfg config.Provider ... } DepsCfg中包含了config.Provider以及Language。\n创建站点的时候，直接传入的就是DepsCfg:\n// newSite creates a new site with the given configuration. func newSite(cfg deps.DepsCfg) (*Site, error) { ... } 在调用创建站点前，DepsCfg就已经把Language准备好了:\nfunc createSitesFromConfig(cfg deps.DepsCfg) ([]*Site, error) { ... languages := getLanguages(cfg.Cfg) for _, lang := range languages { ... cfg.Language = lang s, err = newSite(cfg) ... } return sites, nil } 而从Language结构体可以看出：\n// Language manages specific-language configuration. type Language struct { Lang string Weight int // for sort // Global config. // For internal use. Cfg config.Provider ... } Language是包含了Cfg config.Provider的。 也就是说Language和Config的关系实际上是包含关系，并不像我们上面感受到的那样。 仔细一想，合情合理。 Config专注提供配置key/value仓库管理服务，而Language和Site是一一对应的，需要其它配置信息补充说明。\nHugo的模块 # 提到模块化，大家可能会想到的是Nginx模块，IDEA插件等等。 通常是我可以通过上传一些模块，来满足我的差异化需求。 之所以大家都喜欢这种模块，主要是因为足够灵活，不用费太大的劲就可以满足自身的需求。 因为很多时候，虽然大体上差不多，但总有一些细节上的差异。 这也正说明软件的复杂度，除了技术上的复杂度，还有业务上的复杂度。 大多数情况下，我们面对的主要是业务复杂度。 这也正是在软件领域，对\u0026quot;隔行如隔山\u0026quot;这句俗语最好的阐述。 如今，不仅互联网行业，金融行业，就算传统的制造业，都已经使用上了信息化系统，来帮助企业的生产和管理。 同样是请假系统，哪怕在同样的行业，不同的公司，都会有所差异。\n而Hugo的模块和大家印象中的模块有点不一样，并不是以功能为单位，来满足差异化需求。 而是以目录结构为主，来识别相同的结构。\n先来看看在我们架构中，模块的位置：\n在架构图中，Modules需要统一组织起来，依赖于Modules Config描述信息，而这个信息的加载是由configLoader负责的。\n我们再从 Hugo游乐场源码来看一看实际的调用时序：\n可以看出，在我们的游乐场中，由主函数，调用LoadConfig方法，并在该方法中为Modules做了两件事。 一件是loadModulesConfig，把和Modules相关的配置信息整理到Module Config中。 另一件则是collectModules，根据收集到的配置信息，按模块的标准，将模块信息标准化。\n先来看看Module Config的源码定义：\n// Config holds a module config. type Config struct { Mounts []Mount Imports []Import // Meta info about this module (license information etc.). Params map[string]any } 可以看出，重要字段有两个，一个是Mounts，一个是Imports。 loadModulesConfig中主要是对Imports字段进行处理，在我们实例中：\n-- config.toml -- theme = \u0026#34;mytheme\u0026#34; ... 主题的配置信息是theme = \u0026quot;mytheme\u0026quot;，解析成模块配置信息就成了c.Imports = [mytheme]。\n接下来就是收集模块collectModules了：\nfunc (l configLoader) collectModules(modConfig modules.Config, ...) (modules.Modules, ...) { ... } 传入刚收集到的模块配置信息，输出标准的模块信息。 而我们刚收集到的配置信息只有Imports有值，并且只有一个值\u0026quot;mytheme\u0026quot;，输出实例如下图所示：\nfmt.Printf(\u0026#34;%#v\\n\u0026#34;, modulesConfig) modules.Config{ Mounts:[]modules.Mount(nil), Imports:[]modules.Import{ modules.Import{ Path:\u0026#34;mytheme\u0026#34;, ... }}, Params:map[string]interface {}(nil) } 为什么Hugo管Theme叫模块呢？\n输入以下命令，创建一个站点：\n➜ tmp hugo new site xyz 查看目录结构：\n➜ xyz tree . ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── public ├── static └── themes 7 directories, 2 files 再输入以下命令，创建一个主题:\n➜ tmp hugo new theme mytheme 同样查看目录结构：\n➜ mytheme tree . ├── LICENSE ├── archetypes │ └── default.md ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── footer.html │ ├── head.html │ └── header.html ├── static │ ├── css │ └── js └── theme.toml 7 directories, 11 files 我们把Site和Theme的目录结构放在一起比对一下：\n通过对比，我们不难发现，目录结构基本上是一到的，都包含了archetypes, layouts, static等等。\n在Hugo官网中，有对 目录结构有明确说明。 从源码中也可以看到：\n// hugo-playground/hugofs/files/classifier.go const ( ComponentFolderArchetypes = \u0026#34;archetypes\u0026#34; ComponentFolderStatic = \u0026#34;static\u0026#34; ComponentFolderLayouts = \u0026#34;layouts\u0026#34; ComponentFolderContent = \u0026#34;content\u0026#34; ComponentFolderData = \u0026#34;data\u0026#34; ComponentFolderAssets = \u0026#34;assets\u0026#34; ComponentFolderI18n = \u0026#34;i18n\u0026#34; ) var ( ComponentFolders = []string{ ComponentFolderArchetypes, ComponentFolderStatic, ComponentFolderLayouts, ComponentFolderContent, ComponentFolderData, ComponentFolderAssets, ComponentFolderI18n, } ) 可以看出，Hugo通过标准化目录结构的方式，让每一个模块都遵循这一统一原则，这样无论在解析主题还是用户项目的时候，都有章可循。\n再看看Hugo对 模块的说明：\nHugo Modules are the core building blocks in Hugo. A module can be your main project or a smaller module providing one or more of the 7 component types defined in Hugo: static, content, layouts, data, assets, i18n, and archetypes.\n也就是说 static, content, layouts, data, assets, i18n, and archetypes 这7个组件的任意组合，我们都认为是符合模块的要求。\nHugo的模块是基于Go Modules构建的，使用起来也很方便：\n[module] [[module.imports]] path = \u0026#39;github.com/sunwei/zero\u0026#39; 也就是说，我们现在加载主题可以通过加载模块的形式，不用再把主题以git submodule的导入，更方便，更合理了。\n搞清楚为什么主题也是模块后，我们再一起看下最终，我们得到了什么样的模块详细配置信息：\n// hugo-playground/hugolib/config.go // line 140 ... log.Process(\u0026#34;collectModules\u0026#34;, \u0026#34;set active modules to config with key \u0026#39;allModules\u0026#39;\u0026#34;) for i, m := range moduleConfig.ActiveModules { fmt.Println(i) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, m) } ... Output: ==\u0026gt; Process collectModules: set active modules to config with key \u0026#39;allModules\u0026#39; 0 \u0026amp;modules.moduleAdapter{path:\u0026#34;project\u0026#34;, ... projectMod:true, owner:modules.Module(nil), mounts:[]modules.Mount{ modules.Mount{Source:\u0026#34;mycontent\u0026#34;, Target:\u0026#34;content\u0026#34;, Lang:\u0026#34;en\u0026#34;}, modules.Mount{Source:\u0026#34;data\u0026#34;, Target:\u0026#34;data\u0026#34;, Lang:\u0026#34;\u0026#34;}, modules.Mount{Source:\u0026#34;layouts\u0026#34;, Target:\u0026#34;layouts\u0026#34;, Lang:\u0026#34;\u0026#34;}, modules.Mount{Source:\u0026#34;i18n\u0026#34;, Target:\u0026#34;i18n\u0026#34;, Lang:\u0026#34;\u0026#34;}, modules.Mount{Source:\u0026#34;archetypes\u0026#34;, Target:\u0026#34;archetypes\u0026#34;, Lang:\u0026#34;\u0026#34;}, modules.Mount{Source:\u0026#34;assets\u0026#34;, Target:\u0026#34;assets\u0026#34;, Lang:\u0026#34;\u0026#34;}, modules.Mount{Source:\u0026#34;static\u0026#34;, Target:\u0026#34;static\u0026#34;, Lang:\u0026#34;\u0026#34;}}, ...} 1 \u0026amp;modules.moduleAdapter{path:\u0026#34;mytheme\u0026#34;, ... projectMod:false, owner:(*modules.moduleAdapter)(0xc00019e410), mounts:[]modules.Mount(nil), ...} 从输出结果看，一共有两个模块，一个是project，另一个是mytheme。 因为在我们的实例中，mytheme只有一个txt文件，七个组件中的任何一个都没有，所以mounts为空，而project模块则有每个组件的Mount。\nHugo通过巧妙的标准化目录结构设计，实现了Hugo Module。 强大的拓展性和便捷性，让用户可以专注于内容创作，个性化也得到了大大的满足。\n文件系统的组织 # Hugo目前主要的操作都是对本地文件进行的。 比如读取配置信息、模版信息、博客内容，写入站点信息等等。 因为这些操作都离不开文件系统，Hugo因此对文件信息的组织做了许多工作，以确保调用方良好的使用体验。\nAfero # 首先是选择基础文件系统 afero.Fs:\nAfero is a filesystem framework providing a simple, uniform and universal API interacting with any filesystem, as an abstraction layer providing interfaces, types and methods. Afero has an exceptionally clean interface and simple design without needless constructors or initialization methods.\nAfero提供的服务基本和Golang原生Fs接口一致，其次兼容多操作系统，这样就既对语言兼容，还对系统兼容，并且使用体验还和原生一致。 确实为Hugo提供了良好的文件系统基础。\n为了直观查看Hugo中多种Fs的关联，我们把afero.Fs标作如下结构，包含文件系统的基础操作样例：\nHugo架构中的Fs # 我们再来回顾下，Hugo架构中Fs应用的场景：\n最先出现的是Fs，用来记录最贴近真实目录的文件系统，作为DpesCfg的参数，最终由HugoSites创建Deps的时候，透传给了Deps。 Deps是真正组织构建整个文件系统体系的模块，最终用PathSpec将前面的原始文件系统组织成了Hugo所需要的文件系统。 最终供给Template和Page相关操作使用。\nHugoFs # 我们先看基础的Fs，也就是HugoFs：\n可以看到，基础hugoFs包含输入源Source，和输出目标地址PublishDir，以及用来只读的WorkingDir。 并且第一项都是afero.Fs类型，所以颜色和afero.Fs颜色一致。 后面也会用来颜色来对不同类型的文件系统进行关联。\nPathSpec # 通过上面的Hugo架构图我们知道，最终HugoFs被传入Dpes，并由PathSpec来统一组织和管理所有路径相关信息：\n从上图看出PathSpec包含了hugoFs和Paths，还有另一个重要的BaseFs。\n先看Paths，包含了基础文件系统，还包含了主题和工作目录信息，以及Modules相关的信息。 基于Fs和Path，PathSpec需要消化这些基础信息，并提供完整的文件系统服务。\nBaseFs # 通过准备好的基础信息hugoFs和Paths，BaseFs不仅要提供一些基础服务，比如源文件系统和发布目标文件系统，以及工作目录等相关信息。 还需要按Hugo要求的基础目录对文件进行组织，像Content, Data, i18n, Layouts, Archetypes, Assets。 并且要求严格按模块加载顺序，提供最终的文件服务，比如用户在工程目录增自定义了一些模板，需要覆盖主题里自带的模板时。\n如上图所示，BaseFs用SourceFilesystems来对基础目录进行组织，用theBigFs来提供最终合并文件系统服务。\nSourceFilesystems # 想要映射出Hugo的基础文件结构，Hugo设计出了对应的结构SourceFilesystems来表示，并用字段一一对应。 每一项又具有共同的特征，既SourceFilesystem。\n大家可以回忆下，在上一节 Hugo的模块中有提到，每一个模块是如何在Mount中存储这些信息的。\ntheBigFs # 多模块会生成多个相同结构的文件系统，谁在前，谁在后，由模块配置信息决定。 那最终如何合并这些文件系统呢？ 由上图可以看出，Hugo给出的答案是Overlay，工作原理可参考 Wikipedia OverlayFS。\nOverlay的组织是由filesystemCollector来进行的，用到了文件元数据FileMetaInfo来进行描述，方便相关的文件操作，如查询，排序等。 在生成最终状态的Overlay视图前，需要RootMappingFs来帮助组织按Content, Static等进行分类的文件系统。 最终由Collector来将对应的文件放到对应的集合中。\n有了以上这些组织好的文件系统后，想想可能的应用场景？\n文件系统场景一 - ContentSpec # // hugo-playground/deps/deps.go // line 145 log.Process(\u0026#34;New content Spec\u0026#34;, \u0026#34;content converter provider inside\u0026#34;) contentSpec, err := helpers.NewContentSpec(cfg.Language, ps.BaseFs.Content.Fs) 准备好PathSpec后，ContentSpec的创建立马就用到了Content.Fs，也就是SourceFilesystem.Fs，依赖于theBigFs.overlayMountsContent。\n文件系统场景二 - loadTemplates # // hugo-playground/tpl/tplimpl/template.go // line 340 if err := helpers.SymbolicWalk(t.Layouts.Fs, \u0026#34;\u0026#34;, walker); err != nil { if !os.IsNotExist(err) { return err } return nil } 在加载用户自定义模板时，就用到了Layouts.Fs。 通过walker对文件系统中的模板文件进行相应的处理，依赖于b.theBigFs.overlayDirs[files.ComponentFolderLayouts]\n结合以上文件系统的设计和应用，我们可以感受到Hugo文件系统的设计需求来自于自身的特点。 因为用到了模块的理念，以及模块基础结构的设计。 基础的hugoFs并不能满足Hugo在操作文件系统过程中的所有需求，因此需要进一步封装。\nHugo的做法是用PathSpec来组织所有信息，隐藏复杂度，抽象出BaseFs提供更为贴近使用场景的综合服务。 用SourceFilesystems组织出符合Hugo基础结构特点的直观服务，并用OverlayFs底层技术，实现了多文件系统合并的需求，最终支持到真正的实际使用场景。 包括提供文章内容服务的Content文件系统，和加载自定义模板时的Layouts文件系统，等等。\n站点内容的收集方案 # 文件系统的组织已经帮我们将用户站点项目按Hugo基础组件的结构进行了组织。 我们从BaseFs.Content.Fs可以直接获取站点内容的文件系统索引，可以直接读取文件信息，生成站点面面了。\n但Hugo不这么认为，我们可以用下面两个场景来了解一下Hugo的鸿鹄之志。\n场景一：Headless Bundle\n有一种页面，我们不希望她单独作为一个页面来发布。 但可以在需要她的时候，以变量的形式获取到她。 这就是Hugo对这种需求提供的解决方案： Headless Bundle。\n如果直接遍历文件系统，我们在处理该文件的时候，需要知道她的类型，如果是Headless类型的，就不按常规类型处理。 那文件类型就需要在解析文件的时候，从文件信息中获取到。 页面类型的信息可以放在文件配置中，也可以通过特殊的命名规则来表明，此类方案还有许多。\n如果其它的页面依赖于Headless页面，就要考虑页面解析顺序所带来的问题。 如果Headless在前面被解析，就要存储好相关索引信息，以方便后续依赖于她的文件进行查询。 如果在其它页面之后解析，可能的方案是将之前处理的页面标记为未完成状态，并指明所依赖的Headless页面，并挂起等待条件成熟时被唤醒。 等相应的Headless页面解析完成后，时机成熟时，恢复之前页面的解析流程。 这种方案在依赖的Headless页面较多的情况下，会出现不断挂起的状况。 加上这些配置都依赖于手工维护，解析效率和正确性都很难保障。\n场景二：Page Resources\nHugo Page可以包含不同的资源，常见的有图片类型的，还有音频、视频、数据、压缩包等等多种类型的资源。\n下载页面会提供资源的下载链接，比如软件的安装包，针对不同的操作系统，会提供不同的版本。 Hugo可以很聪明的识别，哪个文件是页面文件，哪些页面是资源文件，并将资源文件信息放在页面的Resources属性里。 这样就方便用户根据页面，来灵活组织这些资源，可以生成一个某一类型软件的下载汇总信息，还可以生成某一章节的下载软件信息。\n如果直接遍历文件系统，每个文件都是相对独立的，需要通过配置信息或者其它的方式标明同一层级的从属关系，还要标明不同层级之间的引用关系。 这些都需要在全局构建信息中存储。 因为互相独立，遍历过程中又会有先后顺序，关系越复杂，重复信息出现的概率就会越高。 当有新的需求出现时，复杂的逻辑处理也不利于软件的拓展。\n从以上两个场景中，可以观察到。 简单的遍历文件系统，确实可以获取基本的文件信息。 但如果需要灵活地组织各种不同的信息，如依赖关系，资源汇总等等跨页面处理场景，我们还需要进一步对站点内容进行发掘，以页面为单位进行组织和管理。\n磨刀不误砍柴工 # 从 Hugo事件风暴中可以清楚的看到Hugo正式收集站点内容是在Hugo Build阶段，之前都是在做准备：\n分工明确，高效协作 # 电商现在的状态已然不是正在融入我们的生活，而是成为了我们生活的一部分。 并且过了拼产品类目的时期，基本上你家有的，我这也有。 现在拼的更多的是特色，和服务。 既然是特色，那每家多多少少都有些不一样。 而服务，基本上都是相同的，其中最重要的要属快递服务。 谁能以最短的时间将包裹送达消费者手中，谁将最容易获得消费者的认可，从而占有更高的市场份额，获得投资者的青睐，进入良性的循环发展。\nHugo也认同最短时间送达这样的服务理念。 拿到待处理的内容后，立马出库装车送到离消费者最近的分拣中心，再由高效的分类机器人对货品进行分类。\nHugo对内容处理的目标\n在我们的样例中，我们的Content就是mycontent目录所代表的文件系统，经过PathSpec处理后，文件系统可通过site.BaseFs.Content.Fs得到。 最终，Hugo需要对内容文件系统中的所有内容进行分类，并存放在PageMap货架上，这样方便快递小哥快速取货，装车并将包裹送达用户手中。\n那Hugo到底是怎么做到的呢？\n陆地集装箱 \u0026ndash; 大卡车\n在实际生活中，包裹会从全球各地通过分拣中心网络，靠大卡车运输到离消费者最近的分拣点。 而Hugo的\u0026quot;大卡车\u0026quot;就是PagesCollector，不像现实世界那么复杂，货物都在site.BaseFs.Content.Fs中。\n分拣机器人\n等货物运到分拣中心后，经过不断对分拣效率进行优化，现在已经做到可以完全自动化。 PagesController将所有文件送达后，自动分拣机器人PagesProcessor便开始工作，无缝衔接。 为了提高处理效率，Hugo为每一个站点都提供了一个机器人，由PagesProcessor负责分发任务，sitePagesProcessor专注处理自己所擅长的语言类别。\n通过明确的分工，高效的协作，最终将所有文件分门别类，规整的放在中心货架上。\n模板的生命周期 # 在 Hugo事件风暴中，我们了解到Hugo的设计理念 - 给用户提供始终如一的轻松写作体现。 而实现这一理念则是以Golang Template为基础，开发出更多实用功能，让内容创造者专于内容创作的同时，还拥有良好的体验。\n让我们回顾一下Golang Template的实现步骤： 再看看Hugo是如何围绕其展开的： Hugo围绕着Golang Template做了很多设计，现在我们通过和模板相关的领域事件，一起来看看模板的生命周期，从而能够有更全面的理解。\nHugo模板生命周期领域事件 # 还是从领域事件入手，来看看有哪些关键事件和模板强相关：\n除了上面和Golang Template一一映射的事件外，还有更细节的事件，为了直观好看，我们把这些事件收集到一起来进行分析：\n可以看到和模板强相关的事件，主要集中在创建HugoSites和Build阶段。 进一步细分，可发现模板生命周期可分为三个阶段：\n开始阶段，包括注册回调，并选定模板服务提供方，并出发模板更新。 注册layouts回调到HugoSites初始化字段 设置默认模板提供方到配置项 通知模板提供者开始更新 准备阶段，包括准备好模板执行器，收集模板相关的功能函数，解析Hugo内置和用户自定义模板，将所有模板存储到模板命名空间，以及用layout处理器连接layout和模板。 新建模板执行器 收集模板函数到函数映射 收集文本函数到函数映射 新建模板命名空间 新建layout处理器 渲染阶段，准备好页面内容后，回调在开始阶段注册的layouts事项，通过layout处理器查找相应的模板，最终用模板进行渲染，生成站点页面 为内容结点创建页面 回调layout注册项进行初始化 为页面查找模板 用模板渲染页面 事件可以帮助我们清晰地了解到Hugo设计的模板生命周期。 下面我们再通过 Hugo游乐场源码梳理一遍具体实现流程，好让我们能更立体地了解到模板生命周期，同时也可以为后面的代码实现讲解章节做好准备。\nTemplate vs Layouts\n我们先来看看Hugo中两个容易混淆的概念，Template和Layouts。\n在创建 自定义Hugo主题的时候，我们接触最多的就是Layouts。 官方文档解释Layouts就是用来当模板的，这样解释并没有问题，但这会让我们很容易产生一种Layouts既模板的错觉，并将Layouts和模板直接划上等号。\n但真的是这样的吗，让我们从代码层面看看他们的关联：\n通过查看新建主题的目录结构，我们会发现自动生成的的文件主要在layouts目录下，里面有首页模板，还有页头和页尾模板，等等。 在代码中，Layouts的出现通过都是以[]string字符串数组的形式出现的。 也就是说在代码中Layouts就是用来记录layout相关的文件路径信息的。\n如果想将Layouts转换成Golang Template，首先需要将其转换成templateInfo。 并记录文件名，分析是否是文本类型，将layout文件内容以字符串存储在tempalte字段中。\n其中是否是文本类型，涉及到Golang Template的设计知识。\nGolang将Template按类型进行了划分。如HTML和Text，通过对HTML标签进行转换，最终也会被转换成Text。 说到底，通过对不同模板类型的转换，都会变成文本类型。\n通过templateInfo，最终Hugo会生成真正的Hugo模板结构体templateState。 可以看出该结构体实现了Template接口。\n所以我们可以得出结论：Layouts不等于Template，是制作Template的原材料。\n弄清了Template和Layouts之间的关系，我们分别来看看Template生命周期中的开始、准备和渲染阶段。\n开始阶段\nHugoSites中的init字段是hugoSitesInit类型的，其中就包含了lazy.init类型的layouts。 这样就可以在layouts字段注册一些回调方法，方便在时机成熟的时候回调。\n同时，对于HugoSites而言，直接面对的是模板服务的提供商，所以需要在这个阶段将TemplateProvider作为提供商，设置在配置信息中。 等信息都准备妥当后，就可以通知模板服务提供商开始工作更新了。\n准备阶段\n对外提供整体服务，并和Deps关联的是templateExec。 包含了texttemplate.executer和templateHandler，以及所有的模板功能函数。 颜色表明各结构之间的关联关系。\n可以看出，texttemplate.executer包含了templateExecHelper，因为在执行的过程中，通过对模板的分析，可能会用上功能函数。\n而templateHander则需要处理和template相关的一些操作。 main字段是templateNamespace类型，里面存储了HTML和Text原型信息，并存储了由原型创建的所有templateState在templateStateMap中。 layoutHandler则是连接layout和template的关键，比如通过layout查询template时，就由layoutHandler全权负责。\n渲染阶段\n结合开始阶段和准备阶段一览：\n通过前期的准备和组织，我们来看看渲染阶段是怎么发生的：\n页面渲染发生在site_render.go中，从pageRender正式开始。\n总共分为两大步，一是page.resolveTemplate解析模板，拿到模板后再开始site.renderAndWritePage渲染和写入页面。\n解析模板 因为Site组合了Deps，所以也和Deps一样，同样持有templateExec信息，通过调用templateExec的LookupLayout方法，查询模板信息。 因为这些模板信息都已经存储在了templateNamespace里的templateStateMap中。\n渲染页面 在pageRender中已经拥有了页面信息pageState，通过上一步又获取了模板信息，所以是时候开始真正地site.renderForTemplate渲染了。 还是通过templateExec调用Execute方法。 因为当前的执行器是texttemplate.executer类型，所以真正地执行是在texttemplate.executer的ExecuteWithContext方法中。 这里是直接用的Golang Template源码，而不是调用Golang的默认包。 因为Golang默认包中自带的功能函数，并不能完全满足Hugo的诉求。 在后续代码实现章节将会详细讲述，这里还是专注在基础架构的初步理解上。\n小结 # 从Golang Template应用示例开始，我们了解到了Golang中模板工作的基本流程。 这有助于我们进一步理解Hugo的设计和实现。\n通过对Hugo领域事件中模板强相关的核心事件进行分析，我们将Hugo模板的生命周期大致分为三个阶段：开始、准备、渲染。\n为了立体的理解模板生命周期，我们不仅从领域事件进行梳理，还从代码结构进行分析。 看到了Hugo是基于HTML和Text模板原型，帮助将所有的Layouts转换成Template，并存储在了Template命名空间中。 还看到为了拓展Golang Template的功能，Hugo将强大的自定义函数保存在了执行器中。 这让模板在渲染过程中，有了更多的帮手。 而这一切，都封装在了对外统一提供的服务templateExec中，不仅对内进行封装，还对外提供了便捷。\n还有更多有意思的事情，比如Hugo为什么不能直接用Golang内置的Template包，而要独立维护？ 我们也会在后续代码实现章节，进一步展开讲解。 和大家一起，一探究竟。\n发布的流程 # 通过 模板的生命周期我们可以看到在最后的渲染阶段，先找到页面的Template，然后对页面进行渲染。 这样我们就有了根据模板生成的待发布内容。\n站点发布主要的任务就是将作者所创作的内容，通过模板转换生成待发布的内容，按照站点的输出格式，写入到我们指定的文件目录。\n那这里就会有两个问题：\n作者所创作的内容是怎么存储在页面中的，又要怎么使用呢？ 发布过程中的信息，如输出格式、文件名、写入地址又是谁提供的呢？ 我们还是从Golang Template基本原理出发:\n在index.html模板中，我们计划用{{.Content}}属性来获取内容。 如果要成功获取，就需要在我们的内容提供商Post实例中，在Content字段设置上正确的值。 如果都按约定准备好后，在最终Golang Template执行结果中，我们就能发现右上角的内容。\n在我们的 游乐场示例中，我们也有一个用到了.Content的layout - layouts/_default/single.html：\n-- mycontent/blog/post.md -- --- title: \u0026#34;Post Title\u0026#34; --- ### first blog Hello Blog -- layouts/_default/single.html -- {{ .Content }} === Static Content === single.html会用做独立页面的模板，如上面的mycontent/blog/post.md。 通过模板渲染过后，post.md中的内容就会替换掉single.html中的{{ .Content }}。\n那Hugo的页面对象PageState又是怎么提供内容服务的呢，也和上面一样，放在属性里吗？ 我们在 Hugo Playground源码中，很快找到了答案：\n// Page is the core interface in Hugo. type Page interface { ContentProvider ... } // ContentProvider provides the content related values for a Page. type ContentProvider interface { Content() (any, error) ... } 没错，就是ContentProvider。 可以看出Golang Template不仅支持属性，同时还支持方法。 共同的特点就是要对外可见 - 都是大写字母开头。\n那上面的两个问题就变得更具体了：\nPageState中的ContentProvider是谁？ 发布流程中所需的详细信息是怎么来的？ 发布相关的领域事件\n同样，我们还是可以通过 领域事件风暴中，发布相关的领域事件入手：\n可以看到，关键时机有两个。 一个是在站点Site创建的时期，另一个则是在构建时期。\n让我们专注在和发布相关的事件上：\n这些事件的解读在 领域事件风暴中有具体描述，这里就不再赘叙。\n结合 源码，我们进一步将上述事件转换成代码流程图：\n不出所料，为PageState提供内容和其它信息服务的对象确实存在，那就是pageOutputs。 但心中不禁升起一丝疑问，为什么是个复数？\n// We create a pageOutput for every output format combination, even if this // particular page isn\u0026#39;t configured to be rendered to that format. type pageOutput struct { ... // These interface provides the functionality that is specific for this // output format. pagePerOutputProviders page.ContentProvider ... } // these will be shifted out when rendering a given output format. type pagePerOutputProviders interface { targetPather ... } 通过查阅上述源码定义，我们更加确定了我们分析的正确性。 PageOutput确实如我们所料，提供了ContentProvider服务和targetPather服务，这样我们前面的两个问题就有了着落。 再加上注解：\nWe create a pageOutput for every output format combination, even if this particular page isn\u0026rsquo;t configured to be rendered to that format.\n我们发现pageOutput是和output format一一对应的，也就是说有多少种输出格式，就有多少个pageOutput，这也解释了上面关于复数的疑问。\n那究竟是个什么样的对应关系，为什么要这样设计呢？ 让我们还是结合上面的流程图来进行分析。\n站点创建时做的准备工作\n我们先看在创建Site的时候，都准备了哪些和发布相关的信息。 上图右边是流程图站点的部分，从对象引用关系来看，可以了解到OutputFormats依赖于OutputFormat，但不是聚合关系。 而OutputFormat又依赖于MediaType。\nMediaType\n从上图左侧的结构图可以看出，OutputFormat是拥有MediaType字段的。 在MediaType包含的主要字段是main和sub。\n那这些字段是干什么用的呢？ 我们可以通过上图中间的部分来进一步了解。 在Hugo的DefaultTypes中，经过简化，我们保留了HTML, MD, TOML, TEXT四种类型。 拿HTML MediaType举例，实际上长这样text/html。 没错main字段就是text，而sub字段才是html。 因为首先HTML媒体类型的文件是以文本形式存储在磁盘上的，然后才是内容是以HTML格式进行组织的。 关于Media Type的详细介绍，可以参考 Wikipedia。\nOutputFormat\n再来看看OutputFormat：\n// Format represents an output representation, usually to a file on disk. type Format struct { // The Name is used as an identifier. Internal output formats (i.e. HTML and RSS) // can be overridden by providing a new definition for those types. Name string `json:\u0026#34;name\u0026#34;` MediaType media.Type `json:\u0026#34;-\u0026#34;` // The base output file name used when not using \u0026#34;ugly URLs\u0026#34;, defaults to \u0026#34;index\u0026#34;. BaseName string `json:\u0026#34;baseName\u0026#34;` ... } 通过注解可以看到，实际的作用就是记载了要将一个文件输出到磁盘上的相关说明信息。 比如BaseName的默认值就是index，首页就会用到，默认文件名是index.html。\nHugo提供的DefaultFormats根据我们的示例简化后，保留了HTML, JSON, MD三种。 其中HTML是指我们将以HTML的输出格式将文件写入到磁盘。\n实例如下：\nHTMLFormat = Format{ Name: \u0026#34;HTML\u0026#34;, MediaType: media.HTMLType, BaseName: \u0026#34;index\u0026#34;, Rel: \u0026#34;canonical\u0026#34;, IsHTML: true, Permalinkable: true, // Weight will be used as first sort criteria. HTML will, by default, // be rendered first, but set it to 10 so it\u0026#39;s easy to put one above it. Weight: 10, } OutputFormats\n如果OutputFormats和OutputFormat不是聚合关系，那又是什么关系呢？\n我们直接来看看OutputFormats的结构，就清楚答案了。\n这里的OutputFormats实际上就是按照Hugo页面的五种类型，分别提供的OutputFormat映射关系。 如果是home类型的页面，那这种类型的页面只提供按HTML格式渲染的结果，而不是其它的格式，如JSON。 也就是说在一个站点下，会为每个类型的页面都定义清楚合法的输出格式。 这将会有效保障页面在渲染的过程中，输出格式的有效性。\nrenderFormats\n有了全面的站点页面输出规范后，为什么还要这个renderFormats呢？\n从上图右下角可以看到，实际上renderFormats来自于outputFormats。 是将所有页面的outputFormats合并，去重后产生的。 可以理解为renderFormats代表着这个站点所有输出的类型。 在我们的实例中，因为所有页面只支持HTML一种类型，所以合并去重后，自然我们这个站点的renderFormats只有一个，就是HTML了。\n从值的角度我们已经知道了两者之间的关联了，那为何Hugo要设置一个renderFormats呢？ 从名字上看是以站点Site为单位，可以理解为站点在渲染时所有的渲染格式。\n那为什么HugoSites也有一个一模一样的renderFormats呢？ 从上图左上方可以看出，Site的renderFormats组成了HugoSites的renderFormats。 这个好理解，因为HugoSites是由多个不同语言的Site所组成的，那就是说HugoSites的renderFormats代表了全站点的渲染格式。\n继续通过上图往右看，可以发现更多的线索。 原来pageOutputs和HugoSites的renderFormats是一一对应关系，也就是说全站点有多少种渲染格式，就有多少个pageOutputs。\n这里不禁又冒出另一个大大的问号 - 每个站点都拥有自己的页面，也都有自己的输出格式，为什么要为单个站点页面提供全站点输出格式的pageOutputs呢？\n同样，我们还是可以从源码中找到答案：\n// hugo-playground/hugolib/page__new.go // line 97 // Prepare output formats for all sites. // We do this even if this page does not get rendered on // its own. It may be referenced via .Site.GetPage and // it will then need an output format. ps.pageOutputs = make([]*pageOutput, len(ps.s.h.renderFormats)) 从上面的代码中可以看到，这样设计的原因是页面可能会被其它的页面引用，甚至被不同语言的页面所调用。\n对应的.Site.GetPage功能函数在多语言使用场景下的 具体说明如下：\nThe previous examples have used the full content filename to lookup the post. Depending on how you have organized your content (whether you have the language code in the file name or not, e.g. my-post.en.md), you may want to do the lookup without extension. This will get you the current language’s version of the page:\n{{ with .Site.GetPage \u0026#34;/blog/my-post\u0026#34; }}{{ .Title }}{{ end }} 既然存在跨站点调用的情况，那就得为调用方准备好调用方所需要的输出格式。 这样回过头来看，为每个页面pageState准备全站点渲染格式的pageOutputs是必需的。\npageOutputs\n在发布流程中，除了内容，还有一些基础信息也很重用，如发布到哪，以什么名字写入等等。 pageOutput做为输出信息的总载体，这些信息自然了也包在其中，通过上图右上方可以看到负责提供这些信息的对象是PagePaths。 其中提供目标文件名的则是其中的targetPaths。\nPagePaths\n细心的小伙伴会发现Site的OutputFormats和PagePaths之间有一条虚线连接。 之所以是虚线，是因为PagePaths实际上是从pageMeta中获取的信息，但根源，实际上还是来源于Site的OutputFormats。\n结合中下方有进一步实样例解释。 可以看到PagePaths会根据当前页面pageState的类型pageKind来获取当前类型的OutputFormats。 会根据每一种OutputFormat生成相应的targetPathsHolder。\n根据每一个PageOutput的OutputFormat类型，选中相应的targetPathsHolder，设置在pagePerOutputProviders之中。 这样在渲染页面时：\nfunc pageRenderer( ctx *siteRenderContext, s *Site, pages \u0026lt;-chan *pageState, results chan\u0026lt;- error, wg *sync.WaitGroup) { defer wg.Done() for p := range pages { templ, found, err := p.resolveTemplate() ... targetPath := p.targetPaths().TargetFilename if err := s.renderAndWritePage(\u0026#34;page \u0026#34;+p.Title(), targetPath, p, templ); err != nil { fmt.Println(\u0026#34; render err\u0026#34;) fmt.Printf(\u0026#34;%#v\u0026#34;, err) results \u0026lt;- err } ... } } 就可以通过p.targetPaths().TargetFilename获取到目标文件名了。\n独立页面的发布流程 # Hugo将页面分成了两大类，一类就是上面介绍的常规页面，另一类就是接下来要看的独立Standalone页面，如404页面。\nfunc (s *Site) render404() error { p, err := newPageStandalone(\u0026amp;pageMeta{ s: s, kind: kind404, urlPaths: pagemeta.URLPath{ URL: \u0026#34;404.html\u0026#34;, }, }, output.HTMLFormat, ) if err != nil { return err } if !p.render { return nil } var d output.LayoutDescriptor d.Kind = kind404 templ, found, err := s.Tmpl().LookupLayout(d, output.HTMLFormat) if err != nil { return err } if !found { return nil } targetPath := p.targetPaths().TargetFilename if targetPath == \u0026#34;\u0026#34; { return errors.New(\u0026#34;failed to create targetPath for 404 page\u0026#34;) } return s.renderAndWritePage(\u0026#34;404 page\u0026#34;, targetPath, p, templ) } 代码流程很清晰，先通过newPageStandalone创建页面，紧接着查找模板，获取目标文件名，最后渲染并写入页面。 整体流程基本一致。\n既然PageOutput是发布流程上的关系所在，那我们还是用PageOutput的视角来看看独立页面会有哪些不同，同时也可以检测一下我们之前的理解是否正确。\n// hugo-playground/hugolib/page__new.go // line 92 func newPageFromMeta( n *contentNode, parentBucket *pagesMapBucket, meta map[string]any, metaProvider *pageMeta) (*pageState, error) { ... if ps.m.standalone { ps.pageOutput = makeOut(ps.m.outputFormats()[0], shouldRenderPage) } else { outputFormatsForPage := ps.m.outputFormats() } ... } 通过newPageFromMeta源码我们发现，对standalone的页面是有特殊处理的，而且用的就是render404中传入的output.HTMLFormat生成了pageOutput。\n这样一来，我们可以确定的说，无论是普通页面，还是独立页面，基本上都是以pageOutput为核心进行展开的，符合同一套发布流程。 让我们再来回顾一下发布流程全景图：\n"},{"id":17,"href":"/docs/how/%E6%B8%B8%E4%B9%90%E5%9C%BA/","title":"Index","section":"Docs","content":" Hugo 游乐场 # 使用Hugo构建站点的体验很棒。 首先是构建速度快，其次是使用起来简单，一个hugo命令，我们的站点就已经就绪。\n在构建过程中，Hugo提供了丰富的内置功能函数，可以在构建过程中向你提供所需要的几乎任何站点相关的信息。 通过可重用模板，让主题来帮助处理所有展示和布局相关的问题。 让作者更专注在内容的创作上。\n游乐场 # 站点构建的就将写好的内容，转化成Web服务器能理解的网站资源。 比如我们写作的时候用的是Markdown格式，生成的网站资源通常是HTML格式。\n下面是一个简单的初始化博客内容：\n-- config.toml -- theme = \u0026#34;mytheme\u0026#34; contentDir = \u0026#34;mycontent\u0026#34; -- myproject.txt -- Hello project! -- themes/mytheme/mytheme.txt -- Hello theme! -- mycontent/blog/post.md -- --- title: \u0026#34;Post Title\u0026#34; --- ### first blog Hello Blog -- layouts/index.html -- {{ $entries := (readDir \u0026#34;.\u0026#34;) }} START:|{{ range $entry := $entries }}{{ if not $entry.IsDir }}{{ $entry.Name }}|{{ end }}{{ end }}:END: -- layouts/_default/single.html -- {{ .Content }} === Static Content === 可以看到我们自定义了一个主题mytheme，只有一个mytheme.txt文件，并没有实际的模板文件。 这将会在下面的构建流程讲解中，帮助我们理解到主题是如何嵌套和加载的。\n我们的内容文件夹是mycontent，在blog目录下有一篇简单博文/blog/post.md。 如果想要独立访问这篇博文，就需要为她生成一个HTML文件，这样我们就可以在浏览器中访问了。\n在样例中，为了生成首页和博客，我们还在layouts下创建了两个模板。 一个是首页模板index.html，另一个则是单篇文章会用到的模板_default/single.html。\n通过golang tools txtar解析上述文本，方便我们转换成如下结构的磁盘文件：\n. ├── config.toml ├── layouts │ ├── _default │ │ └── single.html │ └── index.html ├── mycontent │ └── blog │ └── post.md ├── myproject.txt └── themes └── mytheme └── mytheme.txt 通过Hugo命令进行构建，就能生成如下站点资源：\n➜ public tree . ├── blog │ └── index.html ├── index.html └── robots.txt 并包含了我们想要的信息：\n站点首页 # ➜ public cat index.html START:|config.toml|myproject.txt|:END:% 博客页面 # ➜ public cat blog/index.html \u0026lt;h3 id=\u0026#34;first-blog\u0026#34;\u0026gt;first blog\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;Hello Blog\u0026lt;/p\u0026gt; === Static Content === % 那Hugo的这个魔术到底是怎么变出来的呢？\n为了了解Hugo构建的核心原理，通过对Hugo最新源码进行裁剪，移除当前阶段不必要的\u0026quot;噪音\u0026quot;。 结合我们上面的实例，手动生成了一个最小可工作源码库 - hugo游乐场。 以保证我们在这个游乐场可以尽情地玩耍，专注于核心原理，享受整个源码的学习过程。\n通过命令:\ngit ls-files | grep \u0026#39;\\.go\u0026#39; | xargs wc -l 分别统计 gohugoio/hugo和 hugo playground的代码行数。 我们得到的数据分别是 163075 和 33990 行。\n整整缩减了近四倍！\n相信各位看官也会虎躯一震，信心倍增！看源码原来也可以这么开心。 请准备好瓜子饮料小板凳，各位看官你细听分说。\nShow Me The Code # package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;golang.org/x/tools/txtar\u0026#34; ) // 文件结构 // 文件名: config.toml // 文件内容：theme = \u0026#39;mytheme\u0026#39; var files = \u0026#34;-- config.toml --\\n\u0026#34; + \u0026#34;theme = \u0026#39;mytheme\u0026#39;\u0026#34; func main() { // 解析上面的文件结构 data := txtar.Parse([]byte(files)) fmt.Println(\u0026#34;File start:\u0026#34;) // 遍历解析生成的所有文件，通过File结构体获取文件名和文件数据 // f.Name 获取文件名 // f.Data 获取文件数据 for _, f := range data.Files { filename := filepath.Join(\u0026#34;workingDir\u0026#34;, f.Name) data := bytes.TrimSuffix(f.Data, []byte(\u0026#34;\\n\u0026#34;)) fmt.Println(filename) fmt.Println(string(data)) } fmt.Println(\u0026#34;File end.\u0026#34;) } Output:\n# 解析后得到文件config.toml，以及下面的文件内容 # workingDir就是我们的工作目录，通常是要写入的文件目录 File start: workingDir/config.toml theme = \u0026#39;mytheme\u0026#39; File end. Try it yourself\n"},{"id":18,"href":"/docs/introduction/","title":"Index","section":"Docs","content":" 引言 # 为什么学习深入Hugo # 欢迎来到《深入Hugo：成为静态站点生成领域专家》。 这本书将带领您深入探索静态站点生成技术，并应用领域驱动设计（DDD）原则，让您不仅成为一个熟练的开发者，还能在这个领域脱颖而出。\n在这个引言中，让我们讨论为什么这门课程如此重要。我们要强调一些核心理念，这些理念将贯穿整本书，并帮助您充分理解学习的价值。\n这本书适合谁 # 本书适合各种不同背景和经验水平的读者，包括但不限于：\n开发者和工程师：如果您是一名开发者，希望深入了解静态站点生成技术以及如何应用DDD原则，这本书将为您提供宝贵的知识和实践机会。\n软件架构师：如果您是一名软件架构师，希望提高自己的架构和设计能力，以应用于静态站点生成项目，本书将为您提供相关的指导和案例研究。\n学生和自学者：无论您是计算机科学专业的学生还是自学的技术爱好者，这本书将帮助您建立坚实的技术基础，探索新领域。\n想要进一步提升职业竞争力的人：如果您希望通过学习新的技术和领域知识来提高职业竞争力，这本书将为您提供成为领域专家的机会。\n学以至用 # 学习本书的目的不仅仅是获取知识，而是将知识付诸实践。 我们相信学以至用是深化理解的最佳途径。 因此，在本书中，我们将鼓励您积极参与练习和实际项目，以确保您真正掌握所学内容。\n教会他人以深化理解 # 教会他人是巩固自己知识的有效方式。 在本书中，我们将鼓励您与他人分享所学，无论是通过教育、协作还是与开源社区的互动。 通过教会他人，您将深化自己的理解，并帮助其他人在这个领域取得成功。\n证书的价值 # 本书不仅将帮助您掌握Hugo和DDD的知识，还将提供课程完成证书，这将成为您简历的有力加分项。 您将有机会获得这份证书，以证明您的成就，提高您在职业领域的竞争力。\n贡献开源项目和提供咨询 # 学习Hugo和DDD不仅仅是为了自己。 您还将学会如何贡献到开源项目，分享您的经验，与开源社区互动。 此外，您将有机会应用所学，提供咨询和定制站点服务，将知识转化为实际价值。\n学以至用和实际项目 # 在本书的后续章节中，我们将引导您创建一个轻量的Hugo示例项目，并使用DDD来实现。 这个实际项目将帮助您将所学知识付诸实践，深化理解，同时为读者提供一个连贯的案例，以便他们跟随您的指导构建自己的项目。\n让我们一起开始这段充满发现和成长的学习之旅！\n"},{"id":19,"href":"/docs/what/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/","title":"Index","section":"Docs","content":" 个人站点样例: https://sunwei.xyz # Hugo能很方便的帮助我们构建站点，接下来我们来重放一下我的个人站点是如何构建出来的。\n需求 # 将原有的纯HTML站点切换成Hugo站点。\n原站点一览：\n功能也不复杂，让我们切换到原始版本。 通过git history可以查到提交记录如下： ➜ xyz git:(master) git checkout ef51befc96f398dcfac1b5c04eb4dc7101633012 得到源码如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;sunwei.xyz\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;width: 400px; margin: 20px auto;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;中文\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;/en.html\u0026#34;\u0026gt;English\u0026lt;/a\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;孙伟\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;专注企业级端到端解决方案\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h5\u0026gt; \u0026lt;span\u0026gt;读书笔记\u0026lt;/span\u0026gt; \u0026lt;/h5\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;https://ent.sunwei.xyz\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; 企业级应用 \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;https://buildkit.notes.sunwei.xyz/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; Moby Buildkit 源码读书笔记 \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h5\u0026gt;\u0026lt;span\u0026gt;工具\u0026lt;/span\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;https://jsoneditoronline.cn/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; JSON 在线编缉器 \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;https://fsky.top\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; 程序员创作素材 - Top Funny Sky \u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h5\u0026gt;\u0026lt;span\u0026gt;关于\u0026lt;/span\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/sunwei\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; GitHub \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;mailto:me@sunwei.xyz\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; 邮箱：me@sunwei.xyz \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;small\u0026gt; © Copyright 2020, sunwei.xyz \u0026lt;br\u0026gt; 兼容 \u0026lt;strong\u0026gt;IE6\u0026lt;/strong\u0026gt; \u0026lt;span\u0026gt;\u0026amp;#128526;\u0026lt;/span\u0026gt; \u0026lt;/small\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以看到，纯HTML，为了让站点居中，使用了简单的样式，同时还支持中英双语。 兼容性更不用说，把IE6刨出来，都测不出任何BUG。\n切换前结合Hugo进行分析 # 结合Hugo的使用方法，结合上述源码，我们把需要完成的工作拆分成如下任务：\n配置站点基本信息 提取Header 提取Footer 配置多语言信息，提取多语言切换功能组件 提取样式 并将内容分别放在中，英内容文件夹下 首页汇总 开始将sunwei.xyz切换成Hugo模式 # 通过以上分析，及任务的拆分，我们现在正式进入切换环节。\nHugo项目的基础结构 # 创建一个Hugo站点很方便，通过以下命令：\n➜ tmp hugo new site xyz 查看目录结构：\n➜ xyz tree . ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── public ├── static └── themes 7 directories, 2 files 可以看到默认的文件夹有7个，根据我们的需求，我们需要保留：\ncontent，用来存放站点内容，如果content文件夹用来存放中文，我们还需要再创建一个content.en来存放英文 layouts，用来存放站点页面模板 static，因为有对站点用到居中样式，所以要存放样式文件 config.toml， 基本配置信息和多语言信息都会存放在其中 文件结构看起来如下：\n➜ xyz git:(master) tree . ├── README.md ├── config.toml ├── content ├── content.en ├── layouts └── static 之所以移除public目录，是因为我们将会使用Github Pages + Actions来发布我们的站点，所以每次都会在构建时自动创建发布目录。\n配置站点基本信息 # 我们只需要配置baseURL和title就行，打开config.toml并输入：\nbaseURL = \u0026#39;https://sunwei.xyz/\u0026#39; title = \u0026#39;sunwei.xyz\u0026#39; 提取Header # 通过查询Hugo的layouts说明，我们发现，是支持模板互相引用的，所以我们先把这些重复使用较多的代码提取出来，方便重用。\n进入到layouts，并创建分类目录partials，创建文件head.html，并将原站点header内容拷贝其中：\n\u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;/css/style.css\u0026#34;\u0026gt; \u0026lt;title\u0026gt;sunwei.xyz\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; 提取Footer # 同理，进入到layouts，在分类目录partials下，创建文件foot.html，并将原站点footer内容拷贝其中：\n\u0026lt;footer\u0026gt; \u0026lt;small\u0026gt; Copyright (c) {{ now.Format \u0026#34;2006\u0026#34;}}, sunwei.xyz \u0026lt;/small\u0026gt; \u0026lt;/footer\u0026gt; 这里比较有意思的是这个Copyright，从2006年开始计算，得到当前年份。 对细节感兴趣的小伙伴，可以参考 golang time\n配置多语言信息，提取多语言切换功能组件 # 当点击多语言链接时需要切换到对应语言内容。 将语言切换控件切换成Hugo layouts模板前，先更新配置文件如下：\nbaseURL = \u0026#39;https://sunwei.xyz/\u0026#39; title = \u0026#39;sunwei.xyz\u0026#39; defaultContentLanguage = \u0026#39;zh\u0026#39; [languages] [languages.zh] languageName = \u0026#39;中文\u0026#39; contentDir = \u0026#39;content\u0026#39; weight = 1 [languages.en] languageName = \u0026#39;English\u0026#39; contentDir = \u0026#39;content.en\u0026#39; weight = 2 接下来还是一样，进入到layouts，在分类目录partials下，创建文件language.html，并将原站点footer内容拷贝其中：\n{{ range $.Site.Home.AllTranslations }} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Language.LanguageName }}\u0026lt;/a\u0026gt; {{ end }} 可以看到，这里要用到Hugo提供的函数range，以及获取语言相关的配置信息，并设置上对应链接。 是不是很方便，不用再硬编码这些链接了。\n提取样式 # 因为原站点中有用到样式，让内容居中显示。 我们需要把样式，提取出来，并放在相应的位置。\n这一次不再是layouts，而是static目录下。 进入目录后，创建css文件夹，并在里面创建样式文件style.css:\n.content { width: 400px; margin: 20px auto; } 并将内容分别放在中，英内容文件夹下 # 因为需要中英双语，在之前已经为中英切换组件配置了多语言相关信息。 这次需要将内容放入对应的文件夹中。\n在配置项中，中文对应的文件夹是content：\ndefaultContentLanguage = \u0026#39;zh\u0026#39; [languages] [languages.zh] languageName = \u0026#39;中文\u0026#39; contentDir = \u0026#39;content\u0026#39; weight = 1 在content目录下，创建表示章节的文件_index.md：\n--- title: Introduction date: 2022-09-05T16:32:38+08:00 --- 敏捷咨询、研发效能治理、云原生、源码分享 --- ### 读书笔记 * [企业级应用](https://ent.sunwei.xyz) * [Moby Buildkit 源码读书笔记](https://buildkit.notes.sunwei.xyz/) ### 工具 * [JSON 在线编缉器](https://jsoneditoronline.cn/) * [程序员创作素材 - Top Funny Sky](https://fsky.top) ### 关于 * [GitHub](https://github.com/sunwei) * [邮箱：me@sunwei.xyz](mailto:me@sunwei.xyz) 同理，在content.en目录下，放入英文版内容。\n在Hugo中，index.md表示一个常规页面，访问路径就是对应所在目录的目录名，可以包含其它页面。 比如content/about/index.md，对应的访问链接就是baseURL/about。\n而_index.md，通常是列表类型，通常有子目录，但不能包含其它页面。\n不过目前官方关于index.md和_index.md的明确比较说明，还没有准备好。 所以很多时候并没有那么明确的区分。\n首页汇总 # 准备好内容后，接下来要做的就是用首页对header, footer, language, content进行汇总了。\n因为我们的站点是个人品牌站点，重点是向其它人介绍所专注的领域，相关的博文，工具。 目前并不需要在首页展示博客列表，对首页的定位也不是一个单纯的页面，所以我们选择用_index.md。\n我们的输出格式是默认的HTML。 想要把主页渲染出来，我们同样需要layout中的模板。 先来看一下Hugo主页Layout的 查找规则：\n1. layouts/index.html.html 2. layouts/home.html.html 3. layouts/list.html.html 4. layouts/index.html 5. layouts/home.html 6. layouts/list.html 7. layouts/_default/index.html.html 8. layouts/_default/home.html.html 9. layouts/_default/list.html.html 10. layouts/_default/index.html 11. layouts/_default/home.html 12. layouts/_default/list.html 没错，任意选择其中一个就行。\n在这我们选择了最常见的index.html，那接下来我们就要进入layouts目录，并创建index.html文件，汇总所有提取出来的内容：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ default .Site.Language.Lang .Site.LanguageCode }}\u0026#34;\u0026gt; {{- partial \u0026#34;head.html\u0026#34; . -}} \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; {{- partial \u0026#34;language.html\u0026#34; . -}} \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;{{ .Site.Title }}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{ .Content }}\u0026lt;/p\u0026gt; {{- partial \u0026#34;foot.html\u0026#34; . -}} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以看出，模板语言很容易理解。\n接下来，我们可以直接在本地查看实际效果：\nhugo serve 输入地址 http://localhost:1313/，就能看到我们的站点了：\n简直一模一样。\n以后想要加入 深入理解Hugo系列，更新站点的时候，直接写MD就可以了。 真的很方便。\n最后的目录结构看起来是这个样子的：\n➜ xyz git:(master) tree . ├── CNAME ├── README.md ├── command.sh ├── config.toml ├── content │ └── _index.md ├── content.en │ └── _index.md ├── layouts │ ├── index.html │ ├── partials │ │ ├── foot.html │ │ ├── head.html │ │ └── language.html │ └── taxonomy │ └── taxonomy.html └── static └── css └── style.css 11 directories, 12 files 源码可参考Github sunwei/xyz\n"},{"id":20,"href":"/docs/what/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98/","title":"Index","section":"Docs","content":" 自定义Hugo主题 # Hugo可以创建站点，还可以创建自己的主题。 以站点 sunwe.xyz为例。 让我们将站点中的内容和主题分离，让我们专注在内容创作上。 同时还可以让更多和我们有共同诉求的人，重用我们的主题。\n需求分析 # 我们的目标是分离出站点的主题，也就是将content和layouts，及static分离开，并作为主题引入。\n所需要的步骤如下：\n创建主题仓库 将模板样式从原有站点分离出来 引入主题 实施细节 # 接下来我们一步步的实现以上需求。\n创建主题仓库 # 因为站点定位个人品牌，需求并不复杂，以简洁为主。 我们给主题取名zero，寓意起点。\n首先创建好空的zero Github仓库，再用Hugo命令生成主题默认目录结构：\n➜ zero git:(main) ✗ hugo new theme . Creating theme at /Users/sunwei/github/sunwei/zero/themes ➜ zero git:(main) ✗ ls LICENSE README.md public resources themes 可以看出，Hugo认为我们是在站点里，正在给站点创建主题。 实际上我们需要的是themes里面的内容。 在我们的实例中，其实就theme.toml这一个主题配置文件。 拷贝到我们的仓库根目录下后，更新其中说明内容如下：\nname = \u0026#34;Zero\u0026#34; license = \u0026#34;MIT\u0026#34; licenselink = \u0026#34;https://github.com/sunwei/zero/blob/master/LICENSE\u0026#34; description = \u0026#34;Hugo Theme for sunewi.xyz\u0026#34; homepage = \u0026#34;https://sunwei.xyz/\u0026#34; demosite = \u0026#34;https://sunwei.xyz\u0026#34; tags = [\u0026#34;zero\u0026#34;, \u0026#34;sunwei.xyz\u0026#34;] features = [\u0026#34;clean\u0026#34;] min_version = \u0026#34;0.41.0\u0026#34; [author] name = \u0026#34;Sun Wei\u0026#34; homepage = \u0026#34;https://sunwei.xyz\u0026#34; 其它的文件都可以移除掉，因为我们并不是从零开始创建一个主题，而是将sunwei.xyz站点的主题独立出来。\n为了让主题支持用模块的形式导入，我们还需要在仓库根目录下创建一个golang的模块文件go.mod，并更新内容如下：\nmodule github.com/sunwei/zero go 1.18 这是因为Hugo模块是基于Golang模块开发的。 上面的代码第一行表示的是这个go模块的名字github.com/sunwei/zero，如果想导入这个模块，就需要导入这个索引。 第二行表示支持的go版本。\n准备好主题配置信息和Golang模块信息后，我们就可以引入站点主题了。\n将模板样式从原有站点分离出来 # 打开 站点源码。 将其中的layouts和static目录，全部拷贝至我们的zero主题仓库根目录。 当前zero主题目录结构如下所示：\n➜ zero git:(main) tree . ├── LICENSE ├── README.md ├── go.mod ├── layouts │ ├── index.html │ ├── partials │ │ ├── foot.html │ │ ├── head.html │ │ └── language.html │ └── taxonomy │ └── taxonomy.html ├── static │ └── css │ └── style.css └── theme.toml 5 directories, 10 files 实际上我们的zero主题，到此已经完成了。 将更新推送到远端，就是一个大家都可以用的Hugo主题了。 真的很方便！\n引入主题 # 主题是创建完成了，接下来就是应用了。 打开 站点源码，移除相应的layouts和static目录。\n先在config.toml配置文件中引入主题：\nbaseURL = \u0026#39;https://sunwei.xyz/\u0026#39; title = \u0026#39;sunwei.xyz\u0026#39; theme = \u0026#34;github.com/sunwei/zero\u0026#34; defaultContentLanguage = \u0026#39;zh\u0026#39; [languages] [languages.zh] languageName = \u0026#39;中文\u0026#39; contentDir = \u0026#39;content\u0026#39; weight = 1 [languages.en] languageName = \u0026#39;English\u0026#39; contentDir = \u0026#39;content.en\u0026#39; weight = 2 接着新建go模块信息文件go.mod：\nmodule github.com/sunwei/xyz go 1.18 用Hugo模块命令更新模块配置信息:\n➜ xyz git:(master) hugo mod get -u go: no module dependencies to download hugo: downloading modules … go: downloading github.com/sunwei/zero v0.0.0-20221005003323-b204559ecb5e go: added github.com/sunwei/zero v0.0.0-20221005003323-b204559ecb5e hugo: collected modules in 2784 ms 再看go.mod，有自动插入模块信息：\nmodule github.com/sunwei/xyz go 1.18 require github.com/sunwei/zero v0.0.0-20221005003323-b204559ecb5e // indirect 实际上也可以主动指明版本号，但前提是zero有发布具体版本。 实际上Hugo mod模块命令也可以很方便为咱们管理更新。\n再一起来看下现在sunwei.xyz站点仓库的目录结构:\n➜ xyz git:(master) tree . ├── CNAME ├── README.md ├── command.sh ├── config.toml ├── content │ └── _index.md ├── content.en │ └── _index.md ├── go.mod └── go.sum 2 directories, 8 files 和之前的相比：\n➜ xyz git:(master) tree . ├── CNAME ├── README.md ├── command.sh ├── config.toml ├── content │ └── _index.md ├── content.en │ └── _index.md ├── layouts │ ├── index.html │ ├── partials │ │ ├── foot.html │ │ ├── head.html │ │ └── language.html │ └── taxonomy │ └── taxonomy.html └── static └── css └── style.css 11 directories, 12 files 是不是更简洁明了！ 这就让我们可以更加专注在内容的创作上了。 感谢Hugo！\n相关链接 # Github站点 sunwei.xyz源码 Github主题 zero源码 站点Demo https://sunwei.xyz "}]