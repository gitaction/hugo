<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="PathSpec # 我们一个个来看，先看PathSpec。 通过Hugo架构设计中介绍的 文件系统的组织我们了解到，PathSepc正是文件系统的关键所在。
NewPathSpec时序图 # 从上图可以看出，Hugo为自己量身打造的文件系统，庞大且复杂。 光文件系统就有很多种，仅上面提到的就有BasePathFs，BaseFs，baseFileDecoratorFs，OverlayFs，RootMappingFs，SliceFs, LanguageFs。 可以说琳琅满目，数不胜数。 在感叹的同时，也不禁惊心，学习曲线这么陡，可要怎么学！？
为了不把深入理解Hugo系列写成从入门到放弃系列，让我们先静下心来，发挥一下跬步千里的精神。 陡坡再陡，一天走一步，也总有到头的时候。
通过观察，我们发现无论Hugo如何组织这些文件系统，目标实际上只有一个，那就是在使用的时候，简单直接，将复杂的需求封装在内部。 那说一千，道一万，还是个文件系统。
所以首先我们要弄清楚什么是文件系统，以及Hugo是怎么使用文件系统的。 这么多文件系统之间又是个什么样的关系？
从最开始准备的Path，我们看到除了一些常见的信息，如基础Fs，配置信息Cfg，主题目录，工作目录还有发布目录外，还包含了所有模块的信息AllModules。 模块和文件系统又是什么样的关系？ 接着我们发现在真正构建文件系统的时候，sourceFilesystemBuilder首先做的事情就是创建OverlayFs，为什么这里用到了OverlayFs，要帮助Hugo解决什么样的问题？ 在创建OverlayFs的过程中，还用到了Radix Tree基数树数据结构，基数树是什么，又为什么要用？
通过以上这些疑问，我们可以把这个陡坡分拆成一个个的小坡：
什么是文件系统，Hugo是怎么理解的？ 多个文件系统之间是如何关联的？ Modules和文件系统之间，又存在什么样的关系？ 什么是OverlayFs，为什么要用？ 什么是radix tree? 先弄清楚这些问题，再让我们回过头来查看源码。
出发吧，伟大的软件工程师啊！
什么是文件系统，Hugo是怎么理解的？ # 管理人力的，我们叫人力系统；管理招聘的，我们叫招聘系统；那管理文件的，我们就叫文件系统。
在Hugo架构设计 文件系统的组织中，我们有提到Hugo的文件系统是基于Afero库来构建的。
那我们先来看看Afero是怎么定义文件系统的： 通过Hugo对文件系统的实际应用，我们可以发现主要用到了Afero中的两个接口，一个是Fs，另一个是Lstater。 前面一个就是文件系统了，包含打开文件，查询状态等文件相关的操作。 后面的状态机Lstater则在查询状态的后面加上了如果可能的字样，增强了适用性。
那Afero在PathSpec中是怎么得到应用的呢？ 我们知道在创建依赖Deps之初，有将文件信息传入依赖配置项depsCfg中，这里是最原始的文件信息，虽然叫Fs，但并没有提供文件系统的功能。 真正开始组织和构建文件系统的是中间的BaseFs，不仅关联上初始的信息，还包含了文件系统收集完成后的SourceFilesystems。 里面的源文件系统SourceFilesystem都完整的实现了Afero中的Fs和Lstater接口。
这里举一个实际的应用场景，来帮助理解： readAndProcessContent就是用来读取和处理站点内容的函数，将会在下一个章节渲染中进行介绍。 在这里，我们将用这个具体的场景，来帮助我们理解上面的文件系统BaseFs究竟是在为什么做准备。
从上图可以看到，如果我们要开始处理站点内容了。 我们可以通过站点site实例，很容易的得到站点内容的文件系统。 而这个真实的文件系统，正是来自于BaseFs中的Content.Fs。
拿到内容文件系统后，就可以创建好Walkway实例，并对其中的文件进行遍历Walk了。
site又是怎么持有BaseFs的？ 这个不是在PathSpec中吗？
这里就要提到Golang的组合机制了，可以用组合的方式，对结构体进行拓展： 可以清晰地看到他们之间的关系就是Site -> Deps -> PathSpec -> BaseFs，就是有点长，容易迷失方向。
在Walk的过程中，主要用到的就是Lstater中的LstatIfPossible方法。
多个文件系统之间是如何关联的？ # 我们通过一个实际应用场景，了解到为什么要这样组织文件系统。
从Hugo架构设计 文件系统的文件系统章节了解到了Hugo中复杂的文件系统：
虽然这张图能够从基础架构的角度出发，帮我们了解到文件系统是如何组织在一起的。 看起来有些复杂，但仍没能展示所有的文件系统之间的关联。 比如说，在BaseSpec中的SourceFilesystems里面，SourceFilesystem中的Fs究竟指的是哪些文件系统，和OverlayFs又有什么关联呢？"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="3.5.2.1 PathSpec"><meta property="og:description" content="PathSpec # 我们一个个来看，先看PathSpec。 通过Hugo架构设计中介绍的 文件系统的组织我们了解到，PathSepc正是文件系统的关键所在。
NewPathSpec时序图 # 从上图可以看出，Hugo为自己量身打造的文件系统，庞大且复杂。 光文件系统就有很多种，仅上面提到的就有BasePathFs，BaseFs，baseFileDecoratorFs，OverlayFs，RootMappingFs，SliceFs, LanguageFs。 可以说琳琅满目，数不胜数。 在感叹的同时，也不禁惊心，学习曲线这么陡，可要怎么学！？
为了不把深入理解Hugo系列写成从入门到放弃系列，让我们先静下心来，发挥一下跬步千里的精神。 陡坡再陡，一天走一步，也总有到头的时候。
通过观察，我们发现无论Hugo如何组织这些文件系统，目标实际上只有一个，那就是在使用的时候，简单直接，将复杂的需求封装在内部。 那说一千，道一万，还是个文件系统。
所以首先我们要弄清楚什么是文件系统，以及Hugo是怎么使用文件系统的。 这么多文件系统之间又是个什么样的关系？
从最开始准备的Path，我们看到除了一些常见的信息，如基础Fs，配置信息Cfg，主题目录，工作目录还有发布目录外，还包含了所有模块的信息AllModules。 模块和文件系统又是什么样的关系？ 接着我们发现在真正构建文件系统的时候，sourceFilesystemBuilder首先做的事情就是创建OverlayFs，为什么这里用到了OverlayFs，要帮助Hugo解决什么样的问题？ 在创建OverlayFs的过程中，还用到了Radix Tree基数树数据结构，基数树是什么，又为什么要用？
通过以上这些疑问，我们可以把这个陡坡分拆成一个个的小坡：
什么是文件系统，Hugo是怎么理解的？ 多个文件系统之间是如何关联的？ Modules和文件系统之间，又存在什么样的关系？ 什么是OverlayFs，为什么要用？ 什么是radix tree? 先弄清楚这些问题，再让我们回过头来查看源码。
出发吧，伟大的软件工程师啊！
什么是文件系统，Hugo是怎么理解的？ # 管理人力的，我们叫人力系统；管理招聘的，我们叫招聘系统；那管理文件的，我们就叫文件系统。
在Hugo架构设计 文件系统的组织中，我们有提到Hugo的文件系统是基于Afero库来构建的。
那我们先来看看Afero是怎么定义文件系统的： 通过Hugo对文件系统的实际应用，我们可以发现主要用到了Afero中的两个接口，一个是Fs，另一个是Lstater。 前面一个就是文件系统了，包含打开文件，查询状态等文件相关的操作。 后面的状态机Lstater则在查询状态的后面加上了如果可能的字样，增强了适用性。
那Afero在PathSpec中是怎么得到应用的呢？ 我们知道在创建依赖Deps之初，有将文件信息传入依赖配置项depsCfg中，这里是最原始的文件信息，虽然叫Fs，但并没有提供文件系统的功能。 真正开始组织和构建文件系统的是中间的BaseFs，不仅关联上初始的信息，还包含了文件系统收集完成后的SourceFilesystems。 里面的源文件系统SourceFilesystem都完整的实现了Afero中的Fs和Lstater接口。
这里举一个实际的应用场景，来帮助理解： readAndProcessContent就是用来读取和处理站点内容的函数，将会在下一个章节渲染中进行介绍。 在这里，我们将用这个具体的场景，来帮助我们理解上面的文件系统BaseFs究竟是在为什么做准备。
从上图可以看到，如果我们要开始处理站点内容了。 我们可以通过站点site实例，很容易的得到站点内容的文件系统。 而这个真实的文件系统，正是来自于BaseFs中的Content.Fs。
拿到内容文件系统后，就可以创建好Walkway实例，并对其中的文件进行遍历Walk了。
site又是怎么持有BaseFs的？ 这个不是在PathSpec中吗？
这里就要提到Golang的组合机制了，可以用组合的方式，对结构体进行拓展： 可以清晰地看到他们之间的关系就是Site -> Deps -> PathSpec -> BaseFs，就是有点长，容易迷失方向。
在Walk的过程中，主要用到的就是Lstater中的LstatIfPossible方法。
多个文件系统之间是如何关联的？ # 我们通过一个实际应用场景，了解到为什么要这样组织文件系统。
从Hugo架构设计 文件系统的文件系统章节了解到了Hugo中复杂的文件系统：
虽然这张图能够从基础架构的角度出发，帮我们了解到文件系统是如何组织在一起的。 看起来有些复杂，但仍没能展示所有的文件系统之间的关联。 比如说，在BaseSpec中的SourceFilesystems里面，SourceFilesystem中的Fs究竟指的是哪些文件系统，和OverlayFs又有什么关联呢？"><meta property="og:type" content="article"><meta property="og:url" content="https://hugo.notes.sunwei.xyz/docs/chapter/03/code/deps/pathSpec/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-20T21:09:15+08:00"><title>3.5.2.1 PathSpec | Deep Dive into Hugo: Becoming an Expert in the Static Site Generator Domain</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/zh.search.min.51b5d281c1fd19c00502087975ffc682013444848454b0c5bbd168116aa5d048.js integrity="sha256-UbXSgcH9GcAFAgh5df/GggE0RISEVLDFu9FoEWql0Eg=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-STPKPBQR5Y"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-STPKPBQR5Y",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Deep Dive into Hugo: Becoming an Expert in the Static Site Generator Domain</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=https://hugo.notes.sunwei.xyz/en/>English</a></li></ul></li></ul><ul><li><p><a href=/docs/introduction/><strong>引言</strong></a><br></p></li><li><p><a href=/docs/chapter/01/><strong>第一章 Hugo入门</strong></a></p><ul><li><a href=/docs/chapter/01/ssg/>1.1 静态站点的背景和重要性</a></li><li><a href=/docs/chapter/01/hugo/>1.2 Hugo简介</a></li><li><a href=/docs/chapter/01/install/>1.3 安装Hugo</a></li><li><a href=/docs/chapter/01/site/>1.4 创建第一个站点</a></li><li><a href=/docs/chapter/01/theme/>1.5 自定义主题</a></li><li><a href=/docs/chapter/01/sunweixyz/>1.6 个人站点实例</a><ul><li><a href=/docs/chapter/01/sunweixyz/site/>个人站点</a></li><li><a href=/docs/chapter/01/sunweixyz/theme/>创建新主题</a></li><li><a href=/docs/chapter/01/sunweixyz/deploy/>部署GitHub Pages</a></li></ul></li><li><a href=/docs/chapter/01/qa/>1.7 常见问题和资源</a><br></li></ul></li><li><p><strong>第二章 DDD简介</strong></p><ul><li><a href=/docs/chapter/02/ddd/>2.1 DDD简介</a></li><li><a href=/docs/chapter/02/dddplayer/>2.2 DDD在本书中的应用</a><br></li></ul></li><li><p><a href=/docs/chapter/03/><strong>第三章 Hugo源码精读</strong></a></p><ul><li><a href=/docs/chapter/03/read/>3.1 源码阅读步骤介绍</a></li><li><a href=/docs/chapter/03/prerequisite/>3.2 Hugo本地环境搭建</a></li><li><a href=/docs/chapter/03/dddplayer/>3.3 安装DDDPlayer</a></li><li><a href=/docs/chapter/03/arch/>3.4 Hugo架构设计</a></li><li><a href=/docs/chapter/03/code/>3.5 Hugo源码精读</a><ul><li><a href=/docs/chapter/03/code/config/>3.5.1 配置</a></li><li><a href=/docs/chapter/03/code/deps/>3.5.2 依赖</a><ul><li><a href=/docs/chapter/03/code/deps/pathSpec/ class=active>3.5.2.1 PathSpec</a></li><li><a href=/docs/chapter/03/code/deps/contentSpec/>3.5.2.2 ContentSpec</a></li></ul></li><li><a href=/docs/chapter/03/code/site/>3.5.3 站点</a><ul><li><a href=/docs/chapter/03/code/site/create/>3.5.3.1 创建</a></li><li><a href=/docs/chapter/03/code/site/load/>3.5.3.2 加载</a></li><li><a href=/docs/chapter/03/code/site/markdown/>3.5.3.3 Markdown</a></li></ul></li><li><a href=/docs/chapter/03/code/build/>3.5.4 构建</a><ul><li><a href=/docs/chapter/03/code/build/template/>3.5.4.1 模板</a><br></li></ul></li></ul></li></ul></li><li><p><a href=/docs/chapter/04/><strong>第四章 DDD Hugo</strong></a></p><ul><li><a href=/docs/chapter/04/hugoverse/>4.1 Hugoverse</a></li><li><a href=/docs/chapter/04/demo/>4.2 Hugo 样例工程</a></li><li><a href=/docs/chapter/04/hexagon/>4.3 Hugoverse 六边形架构</a></li><li><a href=/docs/chapter/04/config/>4.4 DDD Hugo 配置信息</a></li><li><a href=/docs/chapter/04/pathspec/>4.5 DDD Hugo PathSpec</a><br></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li><li><a href=https://github.com/sunwei/hugo-book target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>3.5.2.1 PathSpec</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#pathspec>PathSpec</a><ul><li><a href=#newpathspec时序图>NewPathSpec时序图</a></li><li><a href=#什么是文件系统hugo是怎么理解的>什么是文件系统，Hugo是怎么理解的？</a></li><li><a href=#多个文件系统之间是如何关联的>多个文件系统之间是如何关联的？</a></li><li><a href=#modules和文件系统之间又存在什么样的关系>Modules和文件系统之间，又存在什么样的关系？</a></li><li><a href=#什么是overlayfs为什么要用>什么是OverlayFs，为什么要用？</a></li><li><a href=#什么是radix-tree>什么是radix tree?</a></li><li><a href=#源码实现>源码实现</a></li><li><a href=#输入文件系统和所有模块信息输出各组件统一文件系统>输入文件系统和所有模块信息，输出各组件统一文件系统</a></li><li><a href=#pathspec动手实践>PathSpec动手实践</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=pathspec>PathSpec
<a class=anchor href=#pathspec>#</a></h1><p>我们一个个来看，先看<code>PathSpec</code>。
通过Hugo架构设计中介绍的
<a href=/docs/chapter/03/arch/#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%bb%84%e7%bb%87>文件系统的组织</a>我们了解到，<code>PathSepc</code>正是文件系统的关键所在。</p><h2 id=newpathspec时序图>NewPathSpec时序图
<a class=anchor href=#newpathspec%e6%97%b6%e5%ba%8f%e5%9b%be>#</a></h2><p><img src=images/9.3-Hugo-Sites-Deps-PathSpec.svg alt="HugoSites Deps PathSpec"></p><p>从上图可以看出，Hugo为自己量身打造的文件系统，庞大且复杂。
光文件系统就有很多种，仅上面提到的就有<code>BasePathFs</code>，<code>BaseFs</code>，<code>baseFileDecoratorFs</code>，<code>OverlayFs</code>，<code>RootMappingFs</code>，<code>SliceFs</code>, <code>LanguageFs</code>。
可以说琳琅满目，数不胜数。
在感叹的同时，也不禁惊心，学习曲线这么陡，可要怎么学！？</p><p>为了不把深入理解Hugo系列写成从入门到放弃系列，让我们先静下心来，发挥一下跬步千里的精神。
陡坡再陡，一天走一步，也总有到头的时候。</p><p>通过观察，我们发现无论Hugo如何组织这些文件系统，目标实际上只有一个，那就是在使用的时候，简单直接，将复杂的需求封装在内部。
那说一千，道一万，还是个文件系统。</p><p>所以首先我们要弄清楚什么是文件系统，以及Hugo是怎么使用文件系统的。
这么多文件系统之间又是个什么样的关系？</p><p>从最开始准备的<code>Path</code>，我们看到除了一些常见的信息，如基础Fs，配置信息Cfg，主题目录，工作目录还有发布目录外，还包含了所有模块的信息AllModules。
模块和文件系统又是什么样的关系？
接着我们发现在真正构建文件系统的时候，<code>sourceFilesystemBuilder</code>首先做的事情就是创建<code>OverlayFs</code>，为什么这里用到了OverlayFs，要帮助Hugo解决什么样的问题？
在创建OverlayFs的过程中，还用到了<code>Radix Tree</code>基数树数据结构，基数树是什么，又为什么要用？</p><p>通过以上这些疑问，我们可以把这个陡坡分拆成一个个的小坡：</p><ul><li>什么是文件系统，Hugo是怎么理解的？</li><li>多个文件系统之间是如何关联的？</li><li>Modules和文件系统之间，又存在什么样的关系？</li><li>什么是OverlayFs，为什么要用？</li><li>什么是radix tree?</li></ul><p>先弄清楚这些问题，再让我们回过头来查看源码。</p><p>出发吧，伟大的软件工程师啊！</p><h2 id=什么是文件系统hugo是怎么理解的>什么是文件系统，Hugo是怎么理解的？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9fhugo%e6%98%af%e6%80%8e%e4%b9%88%e7%90%86%e8%a7%a3%e7%9a%84>#</a></h2><p>管理人力的，我们叫人力系统；管理招聘的，我们叫招聘系统；那管理文件的，我们就叫文件系统。</p><p>在Hugo架构设计
<a href=/docs/chapter/03/code/#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%bb%84%e7%bb%87>文件系统的组织</a>中，我们有提到Hugo的文件系统是基于<code>Afero</code>库来构建的。</p><p>那我们先来看看<code>Afero</code>是怎么定义文件系统的：
<img src=images/9.4.1-Hugo-Fs-Afero.svg alt="HugoFs Afero"></p><p>通过Hugo对文件系统的实际应用，我们可以发现主要用到了<code>Afero</code>中的两个接口，一个是<code>Fs</code>，另一个是<code>Lstater</code>。
前面一个就是文件系统了，包含打开文件，查询状态等文件相关的操作。
后面的状态机<code>Lstater</code>则在查询状态的后面加上了如果可能的字样，增强了适用性。</p><p>那<code>Afero</code>在<code>PathSpec</code>中是怎么得到应用的呢？
<img src=images/9.4.2-Hugo-Fs-BaseFs.svg alt="HugoFs BaseFs"></p><p>我们知道在创建依赖<code>Deps</code>之初，有将文件信息传入依赖配置项<code>depsCfg</code>中，这里是最原始的文件信息，虽然叫<code>Fs</code>，但并没有提供文件系统的功能。
真正开始组织和构建文件系统的是中间的<code>BaseFs</code>，不仅关联上初始的信息，还包含了文件系统收集完成后的<code>SourceFilesystems</code>。
里面的源文件系统<code>SourceFilesystem</code>都完整的实现了<code>Afero</code>中的<code>Fs</code>和<code>Lstater</code>接口。</p><p>这里举一个实际的应用场景，来帮助理解：
<img src=images/9.4.3-Hugo-Fs-readAndProcessContent.svg alt="HugoFs readAndProcessContent"></p><p><code>readAndProcessContent</code>就是用来读取和处理站点内容的函数，将会在下一个章节渲染中进行介绍。
在这里，我们将用这个具体的场景，来帮助我们理解上面的文件系统<code>BaseFs</code>究竟是在为什么做准备。</p><p>从上图可以看到，如果我们要开始处理站点内容了。
我们可以通过站点<code>site</code>实例，很容易的得到站点内容的文件系统。
而这个真实的文件系统，正是来自于<code>BaseFs</code>中的<code>Content.Fs</code>。</p><p>拿到内容文件系统后，就可以创建好<code>Walkway</code>实例，并对其中的文件进行遍历<code>Walk</code>了。</p><p><code>site</code>又是怎么持有<code>BaseFs</code>的？
这个不是在<code>PathSpec</code>中吗？</p><p>这里就要提到Golang的组合机制了，可以用组合的方式，对结构体进行拓展：
<img src=images/9.4.4-Hugo-Fs-struct-composition.svg alt="HugoFs Struct Composition"></p><p>可以清晰地看到他们之间的关系就是<code>Site -> Deps -> PathSpec -> BaseFs</code>，就是有点长，容易迷失方向。</p><p>在Walk的过程中，主要用到的就是<code>Lstater</code>中的<code>LstatIfPossible</code>方法。</p><p><img src=images/9.4-Hugo-Fs.svg alt=HugoFs></p><h2 id=多个文件系统之间是如何关联的>多个文件系统之间是如何关联的？
<a class=anchor href=#%e5%a4%9a%e4%b8%aa%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e4%b9%8b%e9%97%b4%e6%98%af%e5%a6%82%e4%bd%95%e5%85%b3%e8%81%94%e7%9a%84>#</a></h2><p>我们通过一个实际应用场景，了解到为什么要这样组织文件系统。</p><p>从Hugo架构设计
<a href=/docs/chapter/03/arch/#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%bb%84%e7%bb%87>文件系统</a>的文件系统章节了解到了Hugo中复杂的文件系统：</p><p><img src=images/4.6-hgs-theBigFs.svg alt="Infrastructure HugoFs"></p><p>虽然这张图能够从基础架构的角度出发，帮我们了解到文件系统是如何组织在一起的。
看起来有些复杂，但仍没能展示所有的文件系统之间的关联。
比如说，在BaseSpec中的SourceFilesystems里面，SourceFilesystem中的Fs究竟指的是哪些文件系统，和OverlayFs又有什么关联呢？</p><p><img src=images/9.5-Hugo-Fs-relation.svg alt="HufoFs Relation"></p><p>上图则帮助解答了我们的疑问。
SourceFilesystems包含了Hugo自定义的六大组件，包含Content, Data, I18n, Layouts, Archetypes, Assets。
为每一个组件都提供了一个文件系统实例，类型为SourceFilesystem。
区别就在于里面的Fs字段所指向的文件系统。</p><p>可以看到，Layouts, Archetypes, Assets都一样，都直接指向了BasePathFs，这也是Afero提供的文件系统之一，颜色也标的和Afero一致。
BasePathFs中的Fs实际指向的就是OverlayFs，可以看到她里面的Fs是复数Fss，也就是说有多个文件系统。
具体工作原理，稍后会做介绍。</p><p>再看Data和I18n，指向的都是SliceFs，里面包含的实际是Dirs，也就是多目录，类型则是FileMetaInfo。
拿Data举例，Hugo将所有的数据都集中到一起，这样可以方便统一供页面使用，这样数据之间就不存在从属关系，项目模块里的数据和主题模块里的数据相对独立。</p><p>最后看一下上面的场景中使用到的Content，她在BasePathFs上又封闭了一层，从命名看出提供了Filter的功能，因为针对不同的语言可能需要过滤掉一些其它的文件。</p><h2 id=modules和文件系统之间又存在什么样的关系>Modules和文件系统之间，又存在什么样的关系？
<a class=anchor href=#modules%e5%92%8c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e4%b9%8b%e9%97%b4%e5%8f%88%e5%ad%98%e5%9c%a8%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e5%85%b3%e7%b3%bb>#</a></h2><p>上面已经看到SourceFilesystems为每一个模块都创建了一个文件系统，那Module和文件系统又是怎么关联的呢？</p><p>Hugo的最终目的是构建站点，而一个站点中可能要用到多个模块，为了方便组织构建，模块又定义了六大组件。
在对外提供服务，如上面的站点内容处理场景中，需要对外隐藏文件系统里面的复杂性。
保证文件系统在使用过程中，就是一个整体。</p><p><img src=images/9.6.1-Hugo-Fs-module-overlayFs.svg alt="HugoFs Module and OverlayFs"></p><p>为了让使用者使用起来足够简单，Hugo需要将多模块合并，并保证文件之间正确地依赖关系。</p><p>例如，在Hugo主题中会提供很多不同的layout模板，但如果在项目中也有一个重名的模板，则优先使用项目中的模板，因为这是用户自定义的模板，应优先使用。</p><p>而在主题中数据文件需要保持独立，所以需要将所有模块的数据文件收集到一起，集中管理。</p><p>为了满足这些依赖管理的诉求，Hugo选择使用OverlayFs技术来管理有依赖的文件上，直接用集合来对独立的文件进行管理。</p><p>最终将所有模块的文件系统按依赖关系进行合并，由SourceFilesystems提供统一服务：</p><p><img src=images/9.6-Hugo-Fs-module.svg alt="HugoFs Module"></p><h2 id=什么是overlayfs为什么要用>什么是OverlayFs，为什么要用？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%afoverlayfs%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8>#</a></h2><p>在组织PathSpec中的BaseFs过程中，我们了解到底层文件系统用的是OverlayFs。
和其它文件系统不一样的地方是，她的文件系统是Fss，表明需要同时持有多个文件系统。</p><p><img src=images/9.7-Hugo-Fs-OverlayFs.svg alt="HugoFs OverlayFs"></p><p>将Fss展开，我们得到了上图。</p><p>从右边我们可以看出OverlayFs的工作原理：<strong>将多个文件系统按一定规则进行合并，合并后生成统一的文件系统服务。</strong></p><p>拿上图来做进一步解释。
从上往下看，<code>merge</code>层就是合并后生成的统一文件系统，包含了<code>upper</code>层和<code>lower</code>层的所有文件。
之所以叫upper和lower，是因为文件系统之间有明确的先后顺序关系，OverlayFs会优先选择更上层的文件，来生成合并过后的merge层。
如果多层都有同样的文件，就会优先选择最上面一层的这个文件，比如在上图中，upper层和lower层都有文件a.md，那就会优先选择upper层中的a.md。
如果没有重复，同样的原理，按层级选择最先出现的文件，放入到merge层，像b.md和c.md。</p><p>回到PathSpec中，如上图左边所示。
我们有Project模块和mytheme主题模块，他们都有content文件系统。
这时Project模块是最上层模块，因为这是用户直接提供的内容，也可以理解为用户所提供的自定义信息，对应的就是右边的upper层。
而mytheme主题模块，则对应的是lower层。
如果用户想要自定义站点主页，可以直接在项目中提供相应的layout文件，这样就会覆盖掉主题中对应的layout文件。
合并后的merge层也就是我们之前提到的Fss。</p><p>通过OverlayFs技术，Hugo这样就可以将多模块按需合并了。
并对调用方提供良好的用户体验。</p><p>结合上面的样例，提供源码实现做进一步参考。</p><p>Show me the code:</p><ul><li><a href=https://c.sunwei.xyz/overlayfs.html>OverlayFs</a></li><li><a href=https://c.sunwei.xyz/overlayfs-afero.html>OverlayFs Afero</a></li></ul><h2 id=什么是radix-tree>什么是radix tree?
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%afradix-tree>#</a></h2><p>将多文件系统有效地组织起来后，容易理解，也方便使用。
但组织好的文件系统只是开始，Hugo还需要对文件系统内的文件进行高效操作。
比如查找某一个文件，或者遍历某一路径下的所有文件。</p><p>针对上面的诉求，Hugo选择了Radix Tree - 基数树。</p><p>下面是
<a href=https://en.wikipedia.org/wiki/Radix_tree>Wikipedia Radix tree</a>的示例图：</p><p><img src=images/9.8.1-radix-tree-wiki.svg alt="Wikipedia Radix Tree"></p><p>通过这一数据结构存储单词，不仅存储内容没有重复，提升了空间利用率；路径还清晰，提高了查询效率。</p><p>Hugo当然也不会错过：</p><p><img src=images/9.8-Hugo-Fs-Radix-Tree.svg alt="HugoFs Radix Tree"></p><p>以上面OverlapFs的使用场景作为样例。
当插入第一条信息"/content/a.md"时，因为是第一个结点，没有和其它的结点拥有共同前缀，可以直接插入。
当插入后续结点"/content/b.md, /content/c.md"时，因为都拥有相同前缀"/content/"，首先要对老的结点进行更新。
先提取通用结点"/content/"，并更新老结点为"a.md"。
同时创建后面新加入的结点"b.md, c.md"。
最终状态为步骤二所展示的状态。</p><p>结合上面的样例，可参考以下源码实现，自己动手试一试。</p><p>Show me the code:</p><ul><li><a href=https://c.sunwei.xyz/radix-tree.html>Radix Tree</a></li></ul><p>再来一起快速回顾一下这些问题：</p><ul><li><p>什么是文件系统，Hugo是怎么理解的？</p><p>文件系统就是将多个文件进行系统管理的方法，Hugo用Afero定义了基础文件系统，除了文件系统的基础操作处，还用到了状态机<code>Lstater</code>。</p></li><li><p>多个文件系统之间是如何关联的？</p><p>文件系统源于OverlayFs，终于SourceFilesystems，目标就是为Hugo的各大组件提供属于自己的文件系统服务。</p></li><li><p>Modules和文件系统之间，又存在什么样的关系？</p><p>模块包含了Hugo的通用组件，Hugo需要将多模块按通用组件为单位进行合并，统一途径对外提供服务。</p></li><li><p>什么是OverlayFs，为什么要用？</p><p>是一种可以把多文件系统组合成一个文件系统的技术。</p></li><li><p>什么是radix tree?</p><p>可以快速检索信息，并保证存储信息不重复的数据结构。</p></li></ul><p>对以上问题进行了解答后。
当我们再来看上面的PathSpec全景时序图，我们会发现脉络一下子清晰了起来：</p><p><img src=images/9.3.2-Hugo-Sites-Deps-PathSpec-main-flow.svg alt="HugoSites Deps PathSpec main flow"></p><ul><li>创建Path，将所有基础信息都包含其中</li><li>创建BaseFs，并装饰其中的文件系统</li><li>准备文件系统构建器</li><li>开始创建OverlayFs，准备好文件系统收集器</li><li>根据组件类型，按目录进行整理</li><li>根据整理好的目录信息，为组件分别创建属于自己的文件系统，并保存在构建结果中</li></ul><p>基础知识就绪，流程脉络也梳理清楚。
接下来将流程进一步展开，结合源码来进一步理解Hugo的实现细节。</p><h2 id=源码实现>源码实现
<a class=anchor href=#%e6%ba%90%e7%a0%81%e5%ae%9e%e7%8e%b0>#</a></h2><p><strong>创建Path，将所有基础信息都包含其中</strong></p><p>第一步就是创建Path，我们再将时序图细节还原：</p><p><img src=images/9.9.1-Hugo-Sites-Deps-PathSpec-Path.svg alt="PathSpec Path"></p><p>可以看到Path将所有基础信息都汇集到一起了。</p><p>其中包括最原始的文件系统信息Fs：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Fs holds the core filesystems used by Hugo.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Fs</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Source is Hugo&#39;s source file system.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Note that this will always be a &#34;plain&#34; Afero filesystem:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// * afero.OsFs when running in production
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// * afero.MemMapFs for many of the tests.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Source</span> <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Fs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// PublishDir is where Hugo publishes its rendered content.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// It&#39;s mounted inside publishDir (default /public).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>PublishDir</span> <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Fs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// WorkingDirReadOnly is a 1.read-only file system
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// restricted to the project working dir.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>WorkingDirReadOnly</span> <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Fs</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>还有包含了用户自定义信息和Hugo的默认信息的Config Provider - Cfg。
接着就是ThemesDir, WorkingDir, AbsPublishDir这三个关键目录。
最后就是组织好的所有模块信息AllModules。</p><p>最终创建的Path将包含创建PathSpec所包含的全部信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Paths</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Fs</span>:            <span style=color:#a6e22e>fs</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Cfg</span>:           <span style=color:#a6e22e>cfg</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ThemesDir</span>:  <span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>GetString</span>(<span style=color:#e6db74>&#34;themesDir&#34;</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>WorkingDir</span>: <span style=color:#a6e22e>workingDir</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>AbsPublishDir</span>:   <span style=color:#a6e22e>absPublishDir</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>IsSet</span>(<span style=color:#e6db74>&#34;allModules&#34;</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>AllModules</span> = <span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;allModules&#34;</span>).(<span style=color:#a6e22e>modules</span>.<span style=color:#a6e22e>Modules</span>)
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p><strong>创建BaseFs，并装饰其中的文件系统</strong></p><p>准备好Path后，正式进入到创建基础文件系统的环节：</p><p><img src=images/9.9.2-Hugo-Sites-Deps-PathSpec-BaseFs.svg alt="PathSpec BaseFs"></p><p>可以看到，分别为publishDir，以及由fs.Source和p.WorkingDir组成的PathFs进行了统一装饰。</p><p>先看BasePathFs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// The BasePathFs restricts all operations to a given path within an Fs.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The given file name to the operations on this Fs will be prepended with
</span></span></span><span style=display:flex><span><span style=color:#75715e>// the base path before calling the base Fs.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Any file name (after filepath.Clean()) outside this base path will be
</span></span></span><span style=display:flex><span><span style=color:#75715e>// treated as non existing file.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Note that it does not clean the error messages on return, so you may
</span></span></span><span style=display:flex><span><span style=color:#75715e>// reveal the real path on errors.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>BasePathFs</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>source</span> <span style=color:#a6e22e>Fs</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>path</span>   <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在提供源文件系统source的基础上，进一步指明了路径。
也就是对外只开放源文件系统特定路径下的文件服务。</p><p>再看BaseFileDecorator：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// NewBaseFileDecorator decorates the given Fs to provide the real filename
</span></span></span><span style=display:flex><span><span style=color:#75715e>// and an Opener func.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewBaseFileDecorator</span>(<span style=color:#a6e22e>fs</span> <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Fs</span>) <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Fs</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ffs</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>baseFileDecoratorFs</span>{<span style=color:#a6e22e>Fs</span>: <span style=color:#a6e22e>fs</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>decorator</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>fi</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>FileInfo</span>, <span style=color:#a6e22e>filename</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>FileInfo</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Store away the original in case it&#39;s a symlink.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>meta</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewFileMeta</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>fi</span>.<span style=color:#a6e22e>Name</span>()
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opener</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>() (<span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>File</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ffs</span>.<span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>filename</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fim</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>decorateFileInfo</span>(<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>ffs</span>, <span style=color:#a6e22e>opener</span>, <span style=color:#a6e22e>filename</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>meta</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fim</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ffs</span>.<span style=color:#a6e22e>decorate</span> = <span style=color:#a6e22e>decorator</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ffs</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>baseFileDecoratorFs就是装饰过后的文件信息，实现了Afero的<code>Fs</code>和<code>Lstater</code>接口。
和其它文件系统不同的是，baseFileDecoratorFs提供了一个装饰函数，在查询文件状态的时候都会被调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>fs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>baseFileDecoratorFs</span>) <span style=color:#a6e22e>Stat</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>FileInfo</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Fs</span>.<span style=color:#a6e22e>Stat</span>(<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>decorate</span>(<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>fs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>baseFileDecoratorFs</span>) <span style=color:#a6e22e>LstatIfPossible</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>FileInfo</span>, <span style=color:#66d9ef>bool</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lstater</span>, <span style=color:#a6e22e>isLstater</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Fs</span>.(<span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Lstater</span>); <span style=color:#a6e22e>isLstater</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>ok</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>lstater</span>.<span style=color:#a6e22e>LstatIfPossible</span>(<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Fs</span>.<span style=color:#a6e22e>Stat</span>(<span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>decorate</span>(<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>ok</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这就像钩子函数一样，在原始信息准备好后，触发装饰器，在返回信息前，对信息进行统一处理。
这样提供了足够的灵活性，也方便标准化服务信息。</p><p><strong>准备文件系统构建器</strong></p><p>将原始文件系统进行装饰，并将处理后的系统放入BaseFs实例中。
有了文件系统构建所需要的信息后，Hugo就开始着手构建了。</p><p><img src=images/9.9.3-Hugo-Sites-Deps-PathSpec-fs-builder.svg alt="PathSpec Fs Builder"></p><p>先创建构建器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newSourceFilesystemsBuilder</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>paths</span>.<span style=color:#a6e22e>Paths</span>, <span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>BaseFs</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>sourceFilesystemsBuilder</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sourceFs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewBaseFileDecorator</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Fs</span>.<span style=color:#a6e22e>Source</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sourceFilesystemsBuilder</span>{<span style=color:#a6e22e>p</span>: <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>sourceFs</span>: <span style=color:#a6e22e>sourceFs</span>, <span style=color:#a6e22e>theBigFs</span>: <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span>, <span style=color:#a6e22e>result</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>SourceFilesystems</span>{}}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在构建器中，用到了Path，装饰过后的源文件系统p.Fs.Source，这些之前都出现过，相对好理解一些。</p><p>而theBigFs第一次出现，直译过来就是大文件系统，从这个泛指的名字很难看出是干什么用的。</p><p>SourceFileSystems类型的result较为直观，应该就是构建后的结果，包含了所有Hugo组件的文件系统集合。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sourceFilesystemsBuilder</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>paths</span>.<span style=color:#a6e22e>Paths</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sourceFs</span> <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Fs</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>result</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>SourceFilesystems</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>theBigFs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>filesystemsCollector</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过sourceFilesystemsBuilder结构体的申明可以帮助理解新出现的theBigFs，原来是filesystemsCollector收集器。</p><p><strong>开始创建OverlayFs，准备好文件系统收集器</strong></p><p>准备好站点构建器后，就正式开始构建了。</p><p><img src=images/9.9.4-Hugo-Sites-Deps-PathSpec-sourceFilesystemsBuilder.svg alt="PathSpec sourceFilesystemsCollector"></p><p>首先就是检查theBigFs是否设置好，如果没有，需要通过创建Main OverlayFs来给theBigFs赋值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/filesystems/basefs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 454
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>theBigFs</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>createMainOverlayFs</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span> = <span style=color:#a6e22e>theBigFs</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>进入createMainOverlayFs可以看到Hugo是如何设计filesystemsCollector的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/filesystems/basefs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 518
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sourceFilesystemsBuilder</span>) <span style=color:#a6e22e>createMainOverlayFs</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>paths</span>.<span style=color:#a6e22e>Paths</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>filesystemsCollector</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>collector</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>filesystemsCollector</span>{
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>overlayDirs</span>:   make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>][]<span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>FileMetaInfo</span>),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>overlayMounts</span>:        <span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>Options</span>{}),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>overlayMountsContent</span>: <span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>Options</span>{<span style=color:#a6e22e>DirsMerger</span>: <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>LanguageDirsMerger</span>}),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>overlayMountsStatic</span>:  <span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>Options</span>{<span style=color:#a6e22e>DirsMerger</span>: <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>LanguageDirsMerger</span>}),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>overlayFull</span>:          <span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>Options</span>{}),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>overlayResources</span>:     <span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>Options</span>{<span style=color:#a6e22e>FirstWritable</span>: <span style=color:#66d9ef>true</span>}),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Module has same folder structure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// need to merge, like static files
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mods</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>AllModules</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mounts</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>mountsDescriptor</span>, len(<span style=color:#a6e22e>mods</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>mods</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mod</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mods</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>dir</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mod</span>.<span style=color:#a6e22e>Dir</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>isMainProject</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mod</span>.<span style=color:#a6e22e>Owner</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mounts</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>mountsDescriptor</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Module</span>:        <span style=color:#a6e22e>mod</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>dir</span>:           <span style=color:#a6e22e>dir</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>isMainProject</span>: <span style=color:#a6e22e>isMainProject</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>ordinal</span>:       <span style=color:#a6e22e>i</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>createOverlayFs</span>(<span style=color:#a6e22e>collector</span>, <span style=color:#a6e22e>mounts</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>collector</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>filesystemsCollector的思路很清晰。
首先为不同的收集内容准备好各自的容器，像overlayDirs，用来存放Dir的FileMetaInfo，用来存储所有Content OverlayFs的overlayMountsContent，等等。
然后将所有的模块AllModules转换成mountsDescriptor，根据mounts创建各自的OverlayFs，并放在上一步准备好的容器里。</p><p>createOverlayFs源码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/filesystems/basefs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 562
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sourceFilesystemsBuilder</span>) <span style=color:#a6e22e>createOverlayFs</span>(
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>collector</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>filesystemsCollector</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mounts</span> []<span style=color:#a6e22e>mountsDescriptor</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>md</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>mounts</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fromTo</span>        []<span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fromToContent</span> []<span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fromToStatic</span>  []<span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>		)
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>mount</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>Mounts</span>() {
</span></span><span style=display:flex><span>			<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>filename</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>absPathify</span>(<span style=color:#a6e22e>mount</span>.<span style=color:#a6e22e>Source</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rm</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>RootMapping</span>{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>From</span>:      <span style=color:#a6e22e>mount</span>.<span style=color:#a6e22e>Target</span>, <span style=color:#75715e>// content
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>To</span>:        <span style=color:#a6e22e>filename</span>,     <span style=color:#75715e>// mycontent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>ToBasedir</span>: <span style=color:#a6e22e>base</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Module</span>:    <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>Module</span>.<span style=color:#a6e22e>Path</span>(),
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>IsProject</span>: <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>isMainProject</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Meta</span>: <span style=color:#f92672>...</span>,
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>isContentMount</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>isContentMount</span>(<span style=color:#a6e22e>mount</span>)
</span></span><span style=display:flex><span>			<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isContentMount</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fromToContent</span> = append(<span style=color:#a6e22e>fromToContent</span>, <span style=color:#a6e22e>rm</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>isStaticMount</span>(<span style=color:#a6e22e>mount</span>) {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fromToStatic</span> = append(<span style=color:#a6e22e>fromToStatic</span>, <span style=color:#a6e22e>rm</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fromTo</span> = append(<span style=color:#a6e22e>fromTo</span>, <span style=color:#a6e22e>rm</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>modBase</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>sourceProject</span> <span style=color:#75715e>// source fs, project module
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rmfs</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewRootMappingFs</span>(<span style=color:#a6e22e>modBase</span>, <span style=color:#a6e22e>fromTo</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rmfsContent</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewRootMappingFs</span>(<span style=color:#a6e22e>modBase</span>, <span style=color:#a6e22e>fromToContent</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rmfsStatic</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewRootMappingFs</span>(<span style=color:#a6e22e>sourceStatic</span>, <span style=color:#a6e22e>fromToStatic</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// TODO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// addDirs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// overlayMounts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看出createOverlayFs进行了两层循环。
外层对module进行了循环，内层对mount里的mounts进行了循环。
内层为每一个mount都准备了一个RootMapping，并根据类型，分别放到fromToContent， fromToStatic， fromTo的集合中。
紧接着为每一个集合创建了一个RootMappingFs。
然后用创建好的RootMappingFs信息，统一对Dir和overlayMount进行处理。
这里让我们暂时先专注在NewRootMappingFs，下一章节我们将对上面的TODO内容进行展开。</p><p><img src=images/9.9.4.1-Hugo-Sites-Deps-PathSpec-NewRootMappingFs.svg alt="PathSpec NewRootMappingFs"></p><p>从时序图中，可以观察到正是在这里，Hugo引入了Radix Tree，用来管理补充了信息的RootMapping，并用模块名做为索引key进行存储。
最终返回包含Radix Tree实例的RootMappingFs。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugofs/rootmapping_fs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 30
</span></span></span><span style=display:flex><span><span style=color:#75715e>// NewRootMappingFs creates a new RootMappingFs on top of the provided with
</span></span></span><span style=display:flex><span><span style=color:#75715e>// root mappings with some optional metadata about the root.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Note that From represents a virtual root that maps to the actual filename in To.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewRootMappingFs</span>(<span style=color:#a6e22e>fs</span> <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Fs</span>, <span style=color:#a6e22e>rms</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>RootMapping</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>RootMappingFs</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rootMapToReal</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>radix</span>.<span style=color:#a6e22e>New</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>virtualRoots</span> []<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>rm</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rms</span> {
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>Meta</span>.<span style=color:#a6e22e>SourceRoot</span> = <span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>To</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>Meta</span>.<span style=color:#a6e22e>BaseDir</span> = <span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>ToBasedir</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>Meta</span>.<span style=color:#a6e22e>MountRoot</span> = <span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>path</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>Meta</span>.<span style=color:#a6e22e>Module</span> = <span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>Module</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>Meta</span>.<span style=color:#a6e22e>IsProject</span> = <span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>IsProject</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>meta</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>Meta</span>.<span style=color:#a6e22e>Copy</span>()
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>fi</span> = <span style=color:#a6e22e>NewFileMetaInfo</span>(<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>meta</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepathSeparator</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>From</span> <span style=color:#75715e>// only /layouts and /content
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mappings</span> []<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>found</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rootMapToReal</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mappings</span> = append(<span style=color:#a6e22e>mappings</span>, <span style=color:#a6e22e>rm</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rootMapToReal</span>.<span style=color:#a6e22e>Insert</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>mappings</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>virtualRoots</span> = append(<span style=color:#a6e22e>virtualRoots</span>, <span style=color:#a6e22e>rm</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rootMapToReal</span>.<span style=color:#a6e22e>Insert</span>(<span style=color:#a6e22e>filepathSeparator</span>, <span style=color:#a6e22e>virtualRoots</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rfs</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>RootMappingFs</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Fs</span>:            <span style=color:#a6e22e>fs</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rootMapToReal</span>: <span style=color:#a6e22e>rootMapToReal</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rfs</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>源码中rootMapToReal就是包含了所有RootMapping信息的Radix Tree。
这样一来，利用Radix Tree的特性，我们将很方便按前缀对文件进行走查。</p><p><strong>根据组件类型，按目录进行整理</strong></p><p>Hugo首先将组件都以Mount的形式存储在Module中。
在创建OverlayFs的过程中，先将Mount转换成RootMapping，再由上面的NewRootMappingFs方法，将RootMapping转换成RootMappingFs内部的Radix Tree结构。</p><p>接下来就让我们回到createOverlayFs中，来看看RootMappingFs将如何被使用。</p><p>让我们实例TODO部分的addDirs和overlayMounts操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/filesystems/basefs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 562
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sourceFilesystemsBuilder</span>) <span style=color:#a6e22e>createOverlayFs</span>(
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>collector</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>filesystemsCollector</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mounts</span> []<span style=color:#a6e22e>mountsDescriptor</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rmfs</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewRootMappingFs</span>(<span style=color:#a6e22e>modBase</span>, <span style=color:#a6e22e>fromTo</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rmfsContent</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewRootMappingFs</span>(<span style=color:#a6e22e>modBase</span>, <span style=color:#a6e22e>fromToContent</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rmfsStatic</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewRootMappingFs</span>(<span style=color:#a6e22e>sourceStatic</span>, <span style=color:#a6e22e>fromToStatic</span><span style=color:#f92672>...</span>)	
</span></span><span style=display:flex><span>	    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We need to keep the ordered list of directories for watching and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// some special merge operations (data, i18n).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>addDirs</span>(<span style=color:#a6e22e>rmfs</span>)        <span style=color:#75715e>// add other folders
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>addDirs</span>(<span style=color:#a6e22e>rmfsContent</span>) <span style=color:#75715e>// only has /content, why need to go through all components?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>addDirs</span>(<span style=color:#a6e22e>rmfsStatic</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>getResourcesDir</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>isMainProject</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>AbsResourcesDir</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>filename</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>absPathify</span>(<span style=color:#a6e22e>files</span>.<span style=color:#a6e22e>FolderResources</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>filename</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMounts</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMounts</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>rmfs</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsContent</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsContent</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>rmfsContent</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsStatic</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsStatic</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>rmfsStatic</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayFull</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayFull</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>NewBasePathFs</span>(<span style=color:#a6e22e>modBase</span>, <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>dir</span>))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayResources</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayResources</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>NewBasePathFs</span>(<span style=color:#a6e22e>modBase</span>, <span style=color:#a6e22e>getResourcesDir</span>()))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将上面新增部分的代码对应上我们的时序图：</p><p><img src=images/9.9.5-Hugo-Sites-Deps-PathSpec-addDirs.svg alt="PathSpec addDirs"></p><p>在拿到创建好的RootMappingFs后，先对其收集了一波Dir，然后将其加入到相应的overlayMounts中。</p><p>先来看addDirs：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/filesystems/basefs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 712
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>filesystemsCollector</span>) <span style=color:#a6e22e>addDirs</span>(<span style=color:#a6e22e>rfs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>RootMappingFs</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>componentFolder</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>files</span>.<span style=color:#a6e22e>ComponentFolders</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>addDir</span>(<span style=color:#a6e22e>rfs</span>, <span style=color:#a6e22e>componentFolder</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>filesystemsCollector</span>) <span style=color:#a6e22e>addDir</span>(<span style=color:#a6e22e>rfs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>RootMappingFs</span>, <span style=color:#a6e22e>componentFolder</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dirs</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rfs</span>.<span style=color:#a6e22e>Dirs</span>(<span style=color:#a6e22e>componentFolder</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// event dirs is nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// merge all the same component folder from different rfs in the same array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>overlayDirs</span>[<span style=color:#a6e22e>componentFolder</span>] = append(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>overlayDirs</span>[<span style=color:#a6e22e>componentFolder</span>], <span style=color:#a6e22e>dirs</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对Hugo所有的组件进行轮询，从RootMappingFs中获取Dirs，并添加到overlayDirs中。
让我们展开rfs.Dirs：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugofs/rootmapping_fs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 165
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>fs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RootMappingFs</span>) <span style=color:#a6e22e>Dirs</span>(<span style=color:#a6e22e>base</span> <span style=color:#66d9ef>string</span>) ([]<span style=color:#a6e22e>FileMetaInfo</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>base</span> = <span style=color:#a6e22e>filepathSeparator</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>cleanName</span>(<span style=color:#a6e22e>base</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>roots</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>getRootsWithPrefix</span>(<span style=color:#a6e22e>base</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fss</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>FileMetaInfo</span>, len(<span style=color:#a6e22e>roots</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>roots</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>bfs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>NewBasePathFs</span>(<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Fs</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>To</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bfs</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fi</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Stat</span>(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fss</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>fi</span>.(<span style=color:#a6e22e>FileMetaInfo</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fss</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>先通过RootMappingFs.getRootsWithPrefix来获取RootMapping，再获取根目录的Stat，最终返回所有目录的FileMetaInfo。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugofs/rootmapping_fs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 292
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>fs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RootMappingFs</span>) <span style=color:#a6e22e>getRootsWithPrefix</span>(<span style=color:#a6e22e>prefix</span> <span style=color:#66d9ef>string</span>) []<span style=color:#a6e22e>RootMapping</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>roots</span> []<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>rootMapToReal</span>.<span style=color:#a6e22e>WalkPrefix</span>(<span style=color:#a6e22e>prefix</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>v</span> <span style=color:#a6e22e>any</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>roots</span> = append(<span style=color:#a6e22e>roots</span>, <span style=color:#a6e22e>v</span>.([]<span style=color:#a6e22e>RootMapping</span>)<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>roots</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这里，用上了Radix Tree类型的rootMapToReal，通过走查组件前缀，查询存储在树上的根节点RootMapping信息。</p><p>经过上面的处理后，addDirs就将所有组件根目录的FileMetaInfo都成功存储在了collector.overlayDirs中。</p><p>那collector中的其它Mounts呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMounts</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMounts</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>rmfs</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsContent</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsContent</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>rmfsContent</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsStatic</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsStatic</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>rmfsStatic</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayFull</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayFull</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>NewBasePathFs</span>(<span style=color:#a6e22e>modBase</span>, <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>dir</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayResources</span> = <span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayResources</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>NewBasePathFs</span>(<span style=color:#a6e22e>modBase</span>, <span style=color:#a6e22e>getResourcesDir</span>()))
</span></span></code></pre></div><p>将得到的RootMappingFs直接添加到overlay的不同Mounts中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Append creates a shallow copy of the filesystem and appends the given filesystems to it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ofs</span> <span style=color:#a6e22e>OverlayFs</span>) <span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>fss</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>Fs</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>OverlayFs</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ofs</span>.<span style=color:#a6e22e>fss</span> = append(<span style=color:#a6e22e>ofs</span>.<span style=color:#a6e22e>fss</span>, <span style=color:#a6e22e>fss</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ofs</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>并按顺序在放在了fss中。</p><p>到这里，thyBigFs也就是Collector已经准备妥当，按模块收到到了所有的RootMappingFs，并将她们都依次放入了OverlayMounts和OverlayDirs中。</p><p><strong>根据整理好的目录信息，为组件分别创建属于自己的文件系统，并保存在构建结果中</strong></p><p>拿到准备就绪地收集器后，是时候开始为每一个组件生成自己的SourceFilesystem了：</p><p><img src=images/9.9.6-Hugo-Sites-Deps-PathSpec-SourceFilesystem.svg alt="PathSpec SourceFilesystem"></p><p>从时序图中可以看出，拿到theBigFs后，就开始着手准备构建结果SourceFilesystems了。</p><p>通过构建方式可以分为三类：</p><p><strong>Data和I18N为一类</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/filesystems/basefs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 479
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Data, i18n and content cannot use the overlay fs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>dataDirs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span>.<span style=color:#a6e22e>overlayDirs</span>[<span style=color:#a6e22e>files</span>.<span style=color:#a6e22e>ComponentFolderData</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>dataFs</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewSliceFs</span>(<span style=color:#a6e22e>dataDirs</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>Data</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>newSourceFilesystem</span>(<span style=color:#a6e22e>files</span>.<span style=color:#a6e22e>ComponentFolderData</span>, <span style=color:#a6e22e>dataFs</span>, <span style=color:#a6e22e>dataDirs</span>)
</span></span></code></pre></div><p>直接从overlayDirs中通过组件键值获取相应的文件信息，并用SliceFs进行封装</p><p><strong>Layouts, Archetypes, Assets为一类</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/filesystems/basefs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 464
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>createView</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>componentID</span> <span style=color:#66d9ef>string</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>SourceFilesystem</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span>.<span style=color:#a6e22e>overlayMounts</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>newSourceFilesystem</span>(<span style=color:#a6e22e>componentID</span>, <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NoOpFs</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>dirs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span>.<span style=color:#a6e22e>overlayDirs</span>[<span style=color:#a6e22e>componentID</span>]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>newSourceFilesystem</span>(<span style=color:#a6e22e>componentID</span>, <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>NewBasePathFs</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span>.<span style=color:#a6e22e>overlayMounts</span>, <span style=color:#a6e22e>componentID</span>), <span style=color:#a6e22e>dirs</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>Layouts</span> = <span style=color:#a6e22e>createView</span>(<span style=color:#a6e22e>files</span>.<span style=color:#a6e22e>ComponentFolderLayouts</span>)
</span></span></code></pre></div><p>从overlayDirs中获取目录信息，并用overlayMounts找到相应的OverlayFs，一起生成SourceFilesystem。</p><p><strong>Content为一类</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// hugo-playground/hugolib/filesystems/basefs.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// line 495
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>contentDirs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span>.<span style=color:#a6e22e>overlayDirs</span>[<span style=color:#a6e22e>files</span>.<span style=color:#a6e22e>ComponentFolderContent</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>contentBfs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>afero</span>.<span style=color:#a6e22e>NewBasePathFs</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>theBigFs</span>.<span style=color:#a6e22e>overlayMountsContent</span>, <span style=color:#a6e22e>files</span>.<span style=color:#a6e22e>ComponentFolderContent</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>contentFs</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hugofs</span>.<span style=color:#a6e22e>NewLanguageFs</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>LanguagesDefaultFirst</span>.<span style=color:#a6e22e>AsOrdinalSet</span>(), <span style=color:#a6e22e>contentBfs</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;create content filesystem: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>Content</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>newSourceFilesystem</span>(<span style=color:#a6e22e>files</span>.<span style=color:#a6e22e>ComponentFolderContent</span>, <span style=color:#a6e22e>contentFs</span>, <span style=color:#a6e22e>contentDirs</span>)
</span></span></code></pre></div><p>和上面相比，在BasePathFs前又多加了一层LanguageFs，并且直接用到了overlayMountsContent。</p><p>这样，我们通过基础知识介绍，加上时序图局部拆解，就梳理完了PathSpec的完整创建流程。</p><h2 id=输入文件系统和所有模块信息输出各组件统一文件系统>输入文件系统和所有模块信息，输出各组件统一文件系统
<a class=anchor href=#%e8%be%93%e5%85%a5%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%92%8c%e6%89%80%e6%9c%89%e6%a8%a1%e5%9d%97%e4%bf%a1%e6%81%af%e8%be%93%e5%87%ba%e5%90%84%e7%bb%84%e4%bb%b6%e7%bb%9f%e4%b8%80%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h2><p><img src=images/9.10-Hugo-Sites-PathSpec-input-output.svg alt="PathSpec Input Output Model"></p><p>在创建Deps的过程中，第一个创建的就是PathSpec。
在这之前，我们已经准备好了配置信息，其中包含了所有的模块信息。
PathSpec正是要将所有模块的信息，统一管理，按Hugo对文件系统的要求，将所有的模块按组件组合起来，对外提供统一类型的服务。</p><p>Hugo的实现思路，正如上图中间部分所示。
先将前面准备好的基础信息，如原始Fs，和包含了所有模块信息的AllModules，都放在Path之中。
想要获得最终的结果，还需要一个构建器Builder。
Builder首先准备好承载构建中间状态的容器，如OverlayDirs，OverlayMounts。
然后用Collector也就是我们的theBigFs，将所有Module中的Mount转换成RootMapping，并转换成RootMappingFs做好准备。
因为在创建OverlayFs的时候，需要将不同横块相同组件的RootMappingFs按顺序放在Fss中。
当这些基础信息都准备好后，就可以为每个组件构建自己的SourceFilesystem了，最终组合成SourceFilesystems，也就是PathSpec中的BaseFs。
既标准统一的文件系统集合。</p><h2 id=pathspec动手实践>PathSpec动手实践
<a class=anchor href=#pathspec%e5%8a%a8%e6%89%8b%e5%ae%9e%e8%b7%b5>#</a></h2><p>在理解<code>PathSpec</code>的实现原理后，通过抽象总结，我们将其进行简化。
照葫芦画瓢，动动小手，让我们用代码来总结代码，验证一下这个知识点。</p><p>可以这里线上尝试，
<a href=https://c.sunwei.xyz/pathspec.html>Show Me the Code, try it yourself</a></p><p>代码里有注解说明，代码样例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/sunwei/gobyexample/modules/overlayfs&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/sunwei/gobyexample/modules/radixtree&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;golang.org/x/tools/txtar&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;io&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;io/fs&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;path&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;path/filepath&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dir</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>MkdirTemp</span>(<span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;hugo&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>RemoveAll</span>(<span style=color:#a6e22e>dir</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>myContentPath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>dir</span>, <span style=color:#e6db74>&#34;mycontent&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Mkdir</span>(<span style=color:#a6e22e>myContentPath</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ModePerm</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>myContent2Path</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>dir</span>, <span style=color:#e6db74>&#34;mycontent2&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Mkdir</span>(<span style=color:#a6e22e>myContent2Path</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ModePerm</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>themePath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>dir</span>, <span style=color:#e6db74>&#34;mytheme&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Mkdir</span>(<span style=color:#a6e22e>themePath</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ModePerm</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mcs</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;-- a.md --\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;mycontent: a\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;-- c.md --\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;mycontent: c&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>writeFiles</span>(<span style=color:#a6e22e>mcs</span>, <span style=color:#a6e22e>myContentPath</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mc2s</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;-- a.md --\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;mycontent2: a\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;-- d.md --\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;mycontent2: d&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>writeFiles</span>(<span style=color:#a6e22e>mc2s</span>, <span style=color:#a6e22e>myContent2Path</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ts</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;-- a.md --\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;mytheme: a\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;-- b.md --\n&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;mytheme: b&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>writeFiles</span>(<span style=color:#a6e22e>ts</span>, <span style=color:#a6e22e>themePath</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Paths</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>WorkingDir</span>: <span style=color:#a6e22e>dir</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>AllModules</span>: []<span style=color:#a6e22e>Module</span>{
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>ProjectMod</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Dir</span>:        <span style=color:#a6e22e>dir</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Mounts</span>: []<span style=color:#a6e22e>Mount</span>{
</span></span><span style=display:flex><span>					{<span style=color:#a6e22e>Source</span>: <span style=color:#e6db74>&#34;mycontent&#34;</span>,
</span></span><span style=display:flex><span>						<span style=color:#a6e22e>Target</span>: <span style=color:#e6db74>&#34;content&#34;</span>},
</span></span><span style=display:flex><span>					{<span style=color:#a6e22e>Source</span>: <span style=color:#e6db74>&#34;mycontent2&#34;</span>,
</span></span><span style=display:flex><span>						<span style=color:#a6e22e>Target</span>: <span style=color:#e6db74>&#34;content&#34;</span>},
</span></span><span style=display:flex><span>				},
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>ProjectMod</span>: <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Dir</span>:        <span style=color:#a6e22e>dir</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Mounts</span>: []<span style=color:#a6e22e>Mount</span>{
</span></span><span style=display:flex><span>					{<span style=color:#a6e22e>Source</span>: <span style=color:#e6db74>&#34;mytheme&#34;</span>,
</span></span><span style=display:flex><span>						<span style=color:#a6e22e>Target</span>: <span style=color:#e6db74>&#34;content&#34;</span>},
</span></span><span style=display:flex><span>				},
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>collector</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>filesystemsCollector</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>overlayMountsContent</span>: <span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>New</span>(
</span></span><span style=display:flex><span>			[]<span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>AbsStatFss</span>{}),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>createOverlayFs</span>(<span style=color:#a6e22e>collector</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>f</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>File</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fis</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>collector</span>.
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>overlayMountsContent</span>.<span style=color:#a6e22e>ReadDir</span>(<span style=color:#a6e22e>filepathSeparator</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>fi</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>fis</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>fi</span>.<span style=color:#a6e22e>Name</span>())
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>collector</span>.
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>overlayMountsContent</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>fi</span>.<span style=color:#a6e22e>Name</span>())
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>f</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>b</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>writeFiles</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>dir</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>txtar</span>.<span style=color:#a6e22e>Parse</span>([]byte(<span style=color:#a6e22e>s</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>Files</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>WriteFile</span>(
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>dir</span>, <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Name</span>),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>TrimSuffix</span>(<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Data</span>, []byte(<span style=color:#e6db74>&#34;\n&#34;</span>)),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ModePerm</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>filepathSeparator</span> = string(<span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Separator</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// RootMapping describes a virtual file or directory mount.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RootMapping</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The virtual mount.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>From</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The source directory or file.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>To</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The base of To. May be empty if an
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// absolute path was provided.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ToBasedir</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Whether this is a mount in the main project.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>IsProject</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The virtual mount point, e.g. &#34;blog&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>path</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Mount</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Source</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Target</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Module</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ProjectMod</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Mounts</span>     []<span style=color:#a6e22e>Mount</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Dir</span>        <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Modules</span> []<span style=color:#a6e22e>Module</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Paths</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AllModules</span> <span style=color:#a6e22e>Modules</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>WorkingDir</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// A RootMappingFs maps several roots into one.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Note that the root of this filesystem
</span></span></span><span style=display:flex><span><span style=color:#75715e>// is directories only, and they will be returned
</span></span></span><span style=display:flex><span><span style=color:#75715e>// in Readdir and Readdirnames
</span></span></span><span style=display:flex><span><span style=color:#75715e>// in the order given.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RootMappingFs</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fs</span>            <span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>AbsStatFss</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rootMapToReal</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>radixtree</span>.<span style=color:#a6e22e>Tree</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>filesystemsCollector</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>overlayMountsContent</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>overlayfs</span>.<span style=color:#a6e22e>OverlayFs</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createOverlayFs</span>(
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>collector</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>filesystemsCollector</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>path</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Paths</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>md</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>AllModules</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fromToContent</span> []<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>mount</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>Mounts</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rm</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>RootMapping</span>{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>From</span>:      <span style=color:#a6e22e>mount</span>.<span style=color:#a6e22e>Target</span>, <span style=color:#75715e>// content
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>To</span>:        <span style=color:#a6e22e>mount</span>.<span style=color:#a6e22e>Source</span>, <span style=color:#75715e>// mycontent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>ToBasedir</span>: <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>Dir</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>IsProject</span>: <span style=color:#a6e22e>md</span>.<span style=color:#a6e22e>ProjectMod</span>,
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fromToContent</span> = append(<span style=color:#a6e22e>fromToContent</span>, <span style=color:#a6e22e>rm</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rmfsContent</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newRootMappingFs</span>(<span style=color:#a6e22e>fromToContent</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>collector</span>.<span style=color:#a6e22e>overlayMountsContent</span> = <span style=color:#a6e22e>collector</span>.
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>overlayMountsContent</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>rmfsContent</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// NewRootMappingFs creates a new RootMappingFs
</span></span></span><span style=display:flex><span><span style=color:#75715e>// on top of the provided with root mappings with
</span></span></span><span style=display:flex><span><span style=color:#75715e>// some optional metadata about the root.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Note that From represents a virtual root
</span></span></span><span style=display:flex><span><span style=color:#75715e>// that maps to the actual filename in To.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newRootMappingFs</span>(
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rms</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>RootMapping</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>RootMappingFs</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>radixtree</span>.<span style=color:#a6e22e>New</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>virtualRoots</span> []<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>rm</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rms</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepathSeparator</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>rm</span>.<span style=color:#a6e22e>From</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mappings</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRms</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mappings</span> = append(<span style=color:#a6e22e>mappings</span>, <span style=color:#a6e22e>rm</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Insert</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>mappings</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>virtualRoots</span> = append(<span style=color:#a6e22e>virtualRoots</span>, <span style=color:#a6e22e>rm</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Insert</span>(<span style=color:#a6e22e>filepathSeparator</span>, <span style=color:#a6e22e>virtualRoots</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>RootMappingFs</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rootMapToReal</span>: <span style=color:#a6e22e>t</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RootMappingFs</span>) <span style=color:#a6e22e>Abs</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) []<span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mappings</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRms</span>(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>rootMapToReal</span>, <span style=color:#a6e22e>name</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>paths</span> []<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>mappings</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>paths</span> = append(<span style=color:#a6e22e>paths</span>, <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>Join</span>(
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>ToBasedir</span>, <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>To</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>paths</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RootMappingFs</span>) <span style=color:#a6e22e>Fss</span>() []<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>StatFS</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mappings</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRms</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>rootMapToReal</span>, <span style=color:#a6e22e>filepathSeparator</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fss</span> []<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>StatFS</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>mappings</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fss</span> = append(<span style=color:#a6e22e>fss</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>DirFS</span>(
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>ToBasedir</span>, <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>To</span>)).(<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>StatFS</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fss</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getRms</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>radixtree</span>.<span style=color:#a6e22e>Tree</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>) []<span style=color:#a6e22e>RootMapping</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mappings</span> []<span style=color:#a6e22e>RootMapping</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>found</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>found</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mappings</span> = <span style=color:#a6e22e>v</span>.([]<span style=color:#a6e22e>RootMapping</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mappings</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出样例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>a.md
</span></span><span style=display:flex><span>mycontent: a
</span></span><span style=display:flex><span>b.md
</span></span><span style=display:flex><span>mytheme: b
</span></span><span style=display:flex><span>c.md
</span></span><span style=display:flex><span>mycontent: c
</span></span><span style=display:flex><span>d.md
</span></span><span style=display:flex><span>mycontent2: d
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Program exited.
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/sunwei/hugo-notes/commit/1d95a266b0290ad7b3b4459d6bd478659f3d12e9 title='最后修改者 sunwei | November 20, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 20, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/sunwei/hugo-notes/edit/main/content.zh/docs/chapter/03/code/deps/pathSpec/index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#pathspec>PathSpec</a><ul><li><a href=#newpathspec时序图>NewPathSpec时序图</a></li><li><a href=#什么是文件系统hugo是怎么理解的>什么是文件系统，Hugo是怎么理解的？</a></li><li><a href=#多个文件系统之间是如何关联的>多个文件系统之间是如何关联的？</a></li><li><a href=#modules和文件系统之间又存在什么样的关系>Modules和文件系统之间，又存在什么样的关系？</a></li><li><a href=#什么是overlayfs为什么要用>什么是OverlayFs，为什么要用？</a></li><li><a href=#什么是radix-tree>什么是radix tree?</a></li><li><a href=#源码实现>源码实现</a></li><li><a href=#输入文件系统和所有模块信息输出各组件统一文件系统>输入文件系统和所有模块信息，输出各组件统一文件系统</a></li><li><a href=#pathspec动手实践>PathSpec动手实践</a></li></ul></li></ul></nav></div></aside></main></body></html>